{
  "permissions": {
    "allow": [
      "mcp__plugin_serena_serena__get_symbols_overview",
      "WebFetch(domain:github.com)",
      "Bash(gh issue comment 39 --repo ruaan-deysel/unraid-management-agent --body '## Technical Implementation Notes\n\n### Existing Infrastructure to Leverage\n\nThe codebase already has significant infrastructure that makes this feature easier to implement:\n\n- **`CollectorManager`** in `daemon/services/collector_manager.go` already handles:\n  - Enable/disable collectors at runtime\n  - Interval updates with automatic restart\n  - Factory pattern for creating collector instances\n  - Status tracking \\(`GetStatus\\(\\)`, `GetAllStatus\\(\\)`\\)\n  - State change broadcasting via PubSub\n\n- **Collector pattern**: Each collector \\(e.g., `SystemCollector`\\) has a public `Collect\\(\\)` method, but:\n  - These methods publish to the event bus \\(`ctx.Hub.Pub\\(\\)`\\) rather than returning data\n  - The `Collector` interface only defines `Start\\(ctx, interval\\)` — not `Collect\\(\\)`\n  - **Key change needed**: Extend interface to include `CollectNow\\(\\) \\(interface{}, error\\)`\n\n### Key Implementation Decisions Needed\n\n1. **Return semantics** — Should on-demand:\n   - \\(A\\) Call existing `Collect\\(\\)`, wait for event propagation, return cached data, OR\n   - \\(B\\) Add new `CollectNow\\(\\)` method that returns data directly without event bus?\n   \n   **Recommendation**: Option B — cleaner separation, avoids race conditions with cache updates.\n\n2. **Concurrency handling** — If timer-triggered collection is already running:\n   - \\(A\\) Wait and return that result \\(deduplication\\), OR\n   - \\(B\\) Return 409 Conflict, OR\n   - \\(C\\) Run parallel collection \\(wasteful\\)?\n   \n   **Recommendation**: Option A with a wait channel per collector.\n\n3. **Rate limiting implementation** — Recommend `golang.org/x/time/rate` with:\n   - Per-collector token buckets stored in `CollectorManager`\n   - Configurable burst and sustained rate\n   - Return 429 with `Retry-After` header when limited\n\n### Collector List \\(15 total\\)\n\n```\nsystem, array, disk, docker, vm, ups, nut, gpu, shares, \nnetwork, hardware, zfs, notification, registration, unassigned\n```\n\n### Suggested Interface Change\n\n```go\n// In daemon/services/collector_manager.go\ntype Collector interface {\n    Start\\(ctx context.Context, interval time.Duration\\)\n    CollectNow\\(\\) \\(interface{}, error\\)  // New method for on-demand\n}\n\n// Add to CollectorManager\nfunc \\(cm *CollectorManager\\) TriggerCollect\\(name string\\) \\(interface{}, error\\) {\n    // 1. Check rate limit\n    // 2. Check if collection already in progress \\(dedup\\)\n    // 3. Create collector via factory\n    // 4. Call CollectNow\\(\\)\n    // 5. Optionally publish to event bus for WebSocket clients\n    // 6. Return data directly\n}\n```\n\n### Simpler Alternative: Query Parameter Approach\n\nInstead of new endpoints, consider adding `?refresh=true` to existing endpoints:\n\n```\nGET /api/v1/system              → Returns cached data \\(current behavior\\)\nGET /api/v1/system?refresh=true → Triggers collection, returns fresh data\n```\n\n**Benefits**: Fewer new endpoints, backwards compatible, natural REST semantics.\n\n### Acceptance Criteria\n\n- [ ] `POST /api/v1/collectors/{name}/collect-now` returns fresh data within timeout\n- [ ] Rate-limited requests return `429 Too Many Requests` with `Retry-After` header\n- [ ] Disabled collectors return `503 Service Unavailable`\n- [ ] Unknown collectors return `404 Not Found`\n- [ ] In-progress collections are deduplicated \\(concurrent requests wait for same result\\)\n- [ ] WebSocket broadcasts `collector_refresh` event on completion\n- [ ] All existing timer-based collection continues unchanged \\(backward compatible\\)\n- [ ] Batch endpoint handles partial failures gracefully\n\n### Estimated Effort \\(Revised\\)\n\nGiven existing `CollectorManager` infrastructure:\n\n| Phase | Task | Hours |\n|-------|------|-------|\n| 1 | Extend `Collector` interface, add `CollectNow\\(\\)` to all collectors | 2-3 |\n| 2 | Add `TriggerCollect\\(\\)` to `CollectorManager` with rate limiting | 2-3 |\n| 3 | Add API endpoints and handlers | 1-2 |\n| 4 | Testing \\(unit + integration\\) | 2-3 |\n| 5 | Documentation | 1 |\n\n**Total: ~8-12 hours** \\(reduced from 14-21 due to existing infrastructure\\)')",
      "mcp__plugin_context7_context7__resolve-library-id",
      "mcp__plugin_context7_context7__query-docs"
    ]
  }
}
