
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ruaan-deysel/unraid-management-agent/daemon/cmd/boot.go (0.0%)</option>
				
				<option value="file1">github.com/ruaan-deysel/unraid-management-agent/daemon/dto/nut.go (100.0%)</option>
				
				<option value="file2">github.com/ruaan-deysel/unraid-management-agent/daemon/lib/dmidecode.go (20.8%)</option>
				
				<option value="file3">github.com/ruaan-deysel/unraid-management-agent/daemon/lib/ethtool.go (68.4%)</option>
				
				<option value="file4">github.com/ruaan-deysel/unraid-management-agent/daemon/lib/parser.go (100.0%)</option>
				
				<option value="file5">github.com/ruaan-deysel/unraid-management-agent/daemon/lib/shell.go (89.7%)</option>
				
				<option value="file6">github.com/ruaan-deysel/unraid-management-agent/daemon/lib/testutil/testutil.go (88.9%)</option>
				
				<option value="file7">github.com/ruaan-deysel/unraid-management-agent/daemon/lib/utils.go (100.0%)</option>
				
				<option value="file8">github.com/ruaan-deysel/unraid-management-agent/daemon/lib/validation.go (98.6%)</option>
				
				<option value="file9">github.com/ruaan-deysel/unraid-management-agent/daemon/logger/logger.go (95.8%)</option>
				
				<option value="file10">github.com/ruaan-deysel/unraid-management-agent/daemon/services/api/handlers.go (81.8%)</option>
				
				<option value="file11">github.com/ruaan-deysel/unraid-management-agent/daemon/services/api/logs.go (11.9%)</option>
				
				<option value="file12">github.com/ruaan-deysel/unraid-management-agent/daemon/services/api/middleware.go (100.0%)</option>
				
				<option value="file13">github.com/ruaan-deysel/unraid-management-agent/daemon/services/api/server.go (41.7%)</option>
				
				<option value="file14">github.com/ruaan-deysel/unraid-management-agent/daemon/services/api/websocket.go (44.8%)</option>
				
				<option value="file15">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/array.go (0.8%)</option>
				
				<option value="file16">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/config.go (6.3%)</option>
				
				<option value="file17">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/disk.go (8.8%)</option>
				
				<option value="file18">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/docker.go (30.1%)</option>
				
				<option value="file19">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/gpu.go (0.3%)</option>
				
				<option value="file20">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/hardware.go (1.8%)</option>
				
				<option value="file21">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/network.go (2.5%)</option>
				
				<option value="file22">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/notification.go (1.2%)</option>
				
				<option value="file23">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/nut.go (0.5%)</option>
				
				<option value="file24">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/parity.go (36.8%)</option>
				
				<option value="file25">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/registration.go (1.8%)</option>
				
				<option value="file26">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/share.go (1.0%)</option>
				
				<option value="file27">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/system.go (21.2%)</option>
				
				<option value="file28">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/unassigned.go (0.7%)</option>
				
				<option value="file29">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/ups.go (0.9%)</option>
				
				<option value="file30">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/vm.go (2.7%)</option>
				
				<option value="file31">github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors/zfs.go (15.1%)</option>
				
				<option value="file32">github.com/ruaan-deysel/unraid-management-agent/daemon/services/controllers/array.go (73.8%)</option>
				
				<option value="file33">github.com/ruaan-deysel/unraid-management-agent/daemon/services/controllers/docker.go (100.0%)</option>
				
				<option value="file34">github.com/ruaan-deysel/unraid-management-agent/daemon/services/controllers/notification.go (50.0%)</option>
				
				<option value="file35">github.com/ruaan-deysel/unraid-management-agent/daemon/services/controllers/system.go (73.3%)</option>
				
				<option value="file36">github.com/ruaan-deysel/unraid-management-agent/daemon/services/controllers/userscripts.go (18.0%)</option>
				
				<option value="file37">github.com/ruaan-deysel/unraid-management-agent/daemon/services/controllers/vm.go (100.0%)</option>
				
				<option value="file38">github.com/ruaan-deysel/unraid-management-agent/daemon/services/orchestrator.go (0.0%)</option>
				
				<option value="file39">github.com/ruaan-deysel/unraid-management-agent/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package cmd provides command implementations for the Unraid Management Agent.
package cmd

import (
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/services"
)

// Boot represents the boot command that starts the Unraid Management Agent.
type Boot struct{}

// Run executes the boot command by creating and running the orchestrator.
func (b *Boot) Run(ctx *domain.Context) error <span class="cov0" title="0">{
        return services.CreateOrchestrator(ctx).Run()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package dto

import "time"

// NUTStatus contains detailed NUT (Network UPS Tools) status information.
// This provides more comprehensive UPS data than the basic UPSStatus struct.
type NUTStatus struct {
        // Connection and detection info
        Connected   bool   `json:"connected"`
        DeviceName  string `json:"device_name"`  // e.g., "ups"
        Host        string `json:"host"`         // e.g., "localhost" or remote IP
        Driver      string `json:"driver"`       // e.g., "usbhid-ups"
        DriverState string `json:"driver_state"` // e.g., "quiet", "running"

        // UPS identification
        Manufacturer string `json:"manufacturer"`
        Model        string `json:"model"`
        Serial       string `json:"serial"`
        Type         string `json:"type"` // e.g., "ups"

        // UPS status
        Status         string   `json:"status"`        // e.g., "OL" (Online), "OB" (On Battery)
        StatusText     string   `json:"status_text"`   // Human-readable status
        Alarms         []string `json:"alarms"`        // Active alarms if any
        BeeperStatus   string   `json:"beeper_status"` // e.g., "enabled", "disabled"
        TestResult     string   `json:"test_result"`   // Last test result
        TestResultDate string   `json:"test_result_date"`

        // Battery info
        BatteryCharge         float64 `json:"battery_charge_percent"`
        BatteryChargeLow      float64 `json:"battery_charge_low_percent"`
        BatteryChargeWarning  float64 `json:"battery_charge_warning_percent"`
        BatteryRuntime        int     `json:"battery_runtime_seconds"`
        BatteryRuntimeLow     int     `json:"battery_runtime_low_seconds"`
        BatteryVoltage        float64 `json:"battery_voltage"`
        BatteryVoltageNominal float64 `json:"battery_voltage_nominal"`
        BatteryType           string  `json:"battery_type"` // e.g., "PbAcid"
        BatteryStatus         string  `json:"battery_status"`
        BatteryMfrDate        string  `json:"battery_mfr_date"`

        // Input power
        InputVoltage        float64 `json:"input_voltage"`
        InputVoltageNominal float64 `json:"input_voltage_nominal"`
        InputFrequency      float64 `json:"input_frequency"`
        InputTransferHigh   float64 `json:"input_transfer_high"`
        InputTransferLow    float64 `json:"input_transfer_low"`
        InputCurrent        float64 `json:"input_current"`

        // Output power
        OutputVoltage   float64 `json:"output_voltage"`
        OutputFrequency float64 `json:"output_frequency"`
        OutputCurrent   float64 `json:"output_current"`

        // Load and power
        LoadPercent          float64 `json:"load_percent"`
        RealPower            float64 `json:"realpower_watts"`
        RealPowerNominal     float64 `json:"realpower_nominal_watts"`
        ApparentPower        float64 `json:"apparent_power_va"`
        ApparentPowerNominal float64 `json:"apparent_power_nominal_va"`

        // Timing
        DelayShutdown int `json:"delay_shutdown_seconds"`
        DelayStart    int `json:"delay_start_seconds"`
        TimerShutdown int `json:"timer_shutdown"`
        TimerStart    int `json:"timer_start"`

        // Driver info
        DriverVersion     string `json:"driver_version"`
        DriverVersionData string `json:"driver_version_data"`
        DriverVersionUSB  string `json:"driver_version_usb"`
        ProductID         string `json:"product_id"`
        VendorID          string `json:"vendor_id"`

        // Raw variables for advanced users
        RawVariables map[string]string `json:"raw_variables,omitempty"`

        // Metadata
        Timestamp time.Time `json:"timestamp"`
}

// NUTConfig represents the NUT plugin configuration from nut-dw.cfg
type NUTConfig struct {
        ServiceEnabled bool   `json:"service_enabled"`
        Mode           string `json:"mode"`          // "standalone", "netserver", "netclient"
        UPSName        string `json:"ups_name"`      // e.g., "ups"
        Driver         string `json:"driver"`        // e.g., "usbhid-ups"
        Port           string `json:"port"`          // e.g., "auto"
        IPAddress      string `json:"ip_address"`    // For netclient mode
        PollInterval   int    `json:"poll_interval"` // Seconds between polls
        ShutdownMode   string `json:"shutdown_mode"` // e.g., "sec_timer", "fsd"
        BatteryLevel   int    `json:"battery_level"` // Low battery threshold
        RuntimeValue   int    `json:"runtime_value"` // Low runtime threshold
        Timeout        int    `json:"timeout"`       // Shutdown timeout
}

// NUTDevice represents a single NUT UPS device
type NUTDevice struct {
        Name        string `json:"name"`
        Description string `json:"description"`
        Available   bool   `json:"available"`
}

// NUTResponse is the complete response for the /api/v1/nut endpoint
type NUTResponse struct {
        Installed bool        `json:"installed"` // Is NUT plugin installed?
        Running   bool        `json:"running"`   // Is NUT service running?
        Config    *NUTConfig  `json:"config,omitempty"`
        Devices   []NUTDevice `json:"devices,omitempty"`
        Status    *NUTStatus  `json:"status,omitempty"`
        Timestamp time.Time   `json:"timestamp"`
}

// NUTStatusText converts NUT status codes to human-readable text
func NUTStatusText(status string) string <span class="cov8" title="1">{
        statusMap := map[string]string{
                "OL":      "Online",
                "OB":      "On Battery",
                "LB":      "Low Battery",
                "HB":      "High Battery",
                "RB":      "Replace Battery",
                "CHRG":    "Charging",
                "DISCHRG": "Discharging",
                "BYPASS":  "Bypass",
                "CAL":     "Calibrating",
                "OFF":     "Offline",
                "OVER":    "Overloaded",
                "TRIM":    "Trimming Voltage",
                "BOOST":   "Boosting Voltage",
                "FSD":     "Forced Shutdown",
        }

        // Handle multiple status codes (e.g., "OL CHRG")
        if text, ok := statusMap[status]; ok </span><span class="cov8" title="1">{
                return text
        }</span>
        <span class="cov8" title="1">return status</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package lib

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
)

// ParseDmidecodeType parses dmidecode output for a specific type
// Returns a map of sections, where each section is a map of key-value pairs
func ParseDmidecodeType(typeNum string) ([]map[string]string, error) <span class="cov0" title="0">{
        output, err := ExecCommandOutput("dmidecode", "-t", typeNum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute dmidecode: %w", err)
        }</span>

        <span class="cov0" title="0">return parseDmidecodeOutput(output), nil</span>
}

// parseDmidecodeOutput parses dmidecode output into sections
func parseDmidecodeOutput(output string) []map[string]string <span class="cov8" title="1">{
        var sections []map[string]string
        var currentSection map[string]string
        var currentKey string

        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                // Skip empty lines and header lines
                if strings.TrimSpace(line) == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "SMBIOS") || strings.HasPrefix(line, "Getting") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // New section starts with non-indented line
                <span class="cov8" title="1">if !strings.HasPrefix(line, "\t") &amp;&amp; !strings.HasPrefix(line, " ") </span><span class="cov8" title="1">{
                        if len(currentSection) &gt; 0 </span><span class="cov8" title="1">{
                                sections = append(sections, currentSection)
                        }</span>
                        <span class="cov8" title="1">currentSection = make(map[string]string)
                        currentKey = ""
                        continue</span>
                }

                // Parse key-value pairs
                <span class="cov8" title="1">trimmed := strings.TrimSpace(line)
                if strings.Contains(trimmed, ":") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(trimmed, ":", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                key := strings.TrimSpace(parts[0])
                                value := strings.TrimSpace(parts[1])
                                currentSection[key] = value
                                currentKey = key
                        }</span>
                } else<span class="cov8" title="1"> if currentKey != "" </span><span class="cov8" title="1">{
                        // Continuation of previous value (multi-line)
                        if existing, ok := currentSection[currentKey]; ok </span><span class="cov8" title="1">{
                                currentSection[currentKey] = existing + " " + trimmed
                        }</span>
                }
        }

        // Add last section
        <span class="cov8" title="1">if len(currentSection) &gt; 0 </span><span class="cov8" title="1">{
                sections = append(sections, currentSection)
        }</span>

        <span class="cov8" title="1">return sections</span>
}

// ParseBIOSInfo parses BIOS information from dmidecode type 0
func ParseBIOSInfo() (*dto.BIOSInfo, error) <span class="cov0" title="0">{
        sections, err := ParseDmidecodeType("0")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(sections) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no BIOS information found")
        }</span>

        <span class="cov0" title="0">section := sections[0]
        bios := &amp;dto.BIOSInfo{
                Vendor:      section["Vendor"],
                Version:     section["Version"],
                ReleaseDate: section["Release Date"],
                Address:     section["Address"],
                RuntimeSize: section["Runtime Size"],
                ROMSize:     section["ROM Size"],
                Revision:    section["BIOS Revision"],
        }

        // Parse characteristics
        if chars, ok := section["Characteristics"]; ok </span><span class="cov0" title="0">{
                bios.Characteristics = strings.Split(chars, ",")
                for i := range bios.Characteristics </span><span class="cov0" title="0">{
                        bios.Characteristics[i] = strings.TrimSpace(bios.Characteristics[i])
                }</span>
        }

        <span class="cov0" title="0">return bios, nil</span>
}

// ParseBaseboardInfo parses baseboard information from dmidecode type 2
func ParseBaseboardInfo() (*dto.BaseboardInfo, error) <span class="cov0" title="0">{
        sections, err := ParseDmidecodeType("2")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(sections) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no baseboard information found")
        }</span>

        <span class="cov0" title="0">section := sections[0]
        baseboard := &amp;dto.BaseboardInfo{
                Manufacturer:      section["Manufacturer"],
                ProductName:       section["Product Name"],
                Version:           section["Version"],
                SerialNumber:      section["Serial Number"],
                AssetTag:          section["Asset Tag"],
                LocationInChassis: section["Location In Chassis"],
                Type:              section["Type"],
        }

        // Parse features
        if features, ok := section["Features"]; ok </span><span class="cov0" title="0">{
                baseboard.Features = strings.Split(features, ",")
                for i := range baseboard.Features </span><span class="cov0" title="0">{
                        baseboard.Features[i] = strings.TrimSpace(baseboard.Features[i])
                }</span>
        }

        <span class="cov0" title="0">return baseboard, nil</span>
}

// ParseCPUInfo parses CPU information from dmidecode type 4
func ParseCPUInfo() (*dto.CPUHardwareInfo, error) <span class="cov0" title="0">{
        sections, err := ParseDmidecodeType("4")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(sections) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no CPU information found")
        }</span>

        <span class="cov0" title="0">section := sections[0]
        cpu := &amp;dto.CPUHardwareInfo{
                SocketDesignation: section["Socket Designation"],
                Family:            section["Family"],
                Manufacturer:      section["Manufacturer"],
                Signature:         section["Signature"],
                Voltage:           section["Voltage"],
                Status:            section["Status"],
                Upgrade:           section["Upgrade"],
                SerialNumber:      section["Serial Number"],
                AssetTag:          section["Asset Tag"],
                PartNumber:        section["Part Number"],
        }

        // Parse integer fields
        if val, ok := section["External Clock"]; ok </span><span class="cov0" title="0">{
                if mhz, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(val), " MHz")); err == nil </span><span class="cov0" title="0">{
                        cpu.ExternalClock = mhz
                }</span>
        }
        <span class="cov0" title="0">if val, ok := section["Max Speed"]; ok </span><span class="cov0" title="0">{
                if mhz, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(val), " MHz")); err == nil </span><span class="cov0" title="0">{
                        cpu.MaxSpeed = mhz
                }</span>
        }
        <span class="cov0" title="0">if val, ok := section["Current Speed"]; ok </span><span class="cov0" title="0">{
                if mhz, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(val), " MHz")); err == nil </span><span class="cov0" title="0">{
                        cpu.CurrentSpeed = mhz
                }</span>
        }
        <span class="cov0" title="0">if val, ok := section["Core Enabled"]; ok </span><span class="cov0" title="0">{
                if cores, err := strconv.Atoi(strings.TrimSpace(val)); err == nil </span><span class="cov0" title="0">{
                        cpu.CoreEnabled = cores
                }</span>
        }
        <span class="cov0" title="0">if val, ok := section["Thread Count"]; ok </span><span class="cov0" title="0">{
                if threads, err := strconv.Atoi(strings.TrimSpace(val)); err == nil </span><span class="cov0" title="0">{
                        cpu.ThreadCount = threads
                }</span>
        }

        // Parse flags
        <span class="cov0" title="0">if flags, ok := section["Flags"]; ok </span><span class="cov0" title="0">{
                cpu.Flags = strings.Fields(flags)
        }</span>

        // Parse characteristics
        <span class="cov0" title="0">if chars, ok := section["Characteristics"]; ok </span><span class="cov0" title="0">{
                cpu.Characteristics = strings.Split(chars, ",")
                for i := range cpu.Characteristics </span><span class="cov0" title="0">{
                        cpu.Characteristics[i] = strings.TrimSpace(cpu.Characteristics[i])
                }</span>
        }

        <span class="cov0" title="0">return cpu, nil</span>
}

// ParseCPUCacheInfo parses CPU cache information from dmidecode type 7
func ParseCPUCacheInfo() ([]dto.CPUCacheInfo, error) <span class="cov0" title="0">{
        sections, err := ParseDmidecodeType("7")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var caches []dto.CPUCacheInfo
        for _, section := range sections </span><span class="cov0" title="0">{
                cache := dto.CPUCacheInfo{
                        SocketDesignation:   section["Socket Designation"],
                        Configuration:       section["Configuration"],
                        OperationalMode:     section["Operational Mode"],
                        Location:            section["Location"],
                        InstalledSize:       section["Installed Size"],
                        MaximumSize:         section["Maximum Size"],
                        InstalledSRAMType:   section["Installed SRAM Type"],
                        ErrorCorrectionType: section["Error Correction Type"],
                        SystemType:          section["System Type"],
                        Associativity:       section["Associativity"],
                }

                // Parse level from socket designation (e.g., "L1-Cache", "L2-Cache")
                switch </span>{
                case strings.Contains(cache.SocketDesignation, "L1"):<span class="cov0" title="0">
                        cache.Level = 1</span>
                case strings.Contains(cache.SocketDesignation, "L2"):<span class="cov0" title="0">
                        cache.Level = 2</span>
                case strings.Contains(cache.SocketDesignation, "L3"):<span class="cov0" title="0">
                        cache.Level = 3</span>
                }

                // Parse supported SRAM types
                <span class="cov0" title="0">if types, ok := section["Supported SRAM Types"]; ok </span><span class="cov0" title="0">{
                        cache.SupportedSRAMTypes = strings.Split(types, ",")
                        for i := range cache.SupportedSRAMTypes </span><span class="cov0" title="0">{
                                cache.SupportedSRAMTypes[i] = strings.TrimSpace(cache.SupportedSRAMTypes[i])
                        }</span>
                }

                <span class="cov0" title="0">caches = append(caches, cache)</span>
        }

        <span class="cov0" title="0">return caches, nil</span>
}

// ParseMemoryArrayInfo parses memory array information from dmidecode type 16
func ParseMemoryArrayInfo() (*dto.MemoryArrayInfo, error) <span class="cov0" title="0">{
        sections, err := ParseDmidecodeType("16")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(sections) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no memory array information found")
        }</span>

        <span class="cov0" title="0">section := sections[0]
        memArray := &amp;dto.MemoryArrayInfo{
                Location:            section["Location"],
                Use:                 section["Use"],
                ErrorCorrectionType: section["Error Correction Type"],
                MaximumCapacity:     section["Maximum Capacity"],
        }

        // Parse number of devices
        if val, ok := section["Number Of Devices"]; ok </span><span class="cov0" title="0">{
                if num, err := strconv.Atoi(strings.TrimSpace(val)); err == nil </span><span class="cov0" title="0">{
                        memArray.NumberOfDevices = num
                }</span>
        }

        <span class="cov0" title="0">return memArray, nil</span>
}

// ParseMemoryDevices parses memory device information from dmidecode type 17
func ParseMemoryDevices() ([]dto.MemoryDeviceInfo, error) <span class="cov0" title="0">{
        sections, err := ParseDmidecodeType("17")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var devices []dto.MemoryDeviceInfo
        for _, section := range sections </span><span class="cov0" title="0">{
                // Skip empty slots
                if section["Size"] == "No Module Installed" || section["Size"] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">device := dto.MemoryDeviceInfo{
                        Locator:           section["Locator"],
                        BankLocator:       section["Bank Locator"],
                        Size:              section["Size"],
                        FormFactor:        section["Form Factor"],
                        Type:              section["Type"],
                        TypeDetail:        section["Type Detail"],
                        Speed:             section["Speed"],
                        Manufacturer:      section["Manufacturer"],
                        SerialNumber:      section["Serial Number"],
                        AssetTag:          section["Asset Tag"],
                        PartNumber:        section["Part Number"],
                        ConfiguredSpeed:   section["Configured Memory Speed"],
                        MinimumVoltage:    section["Minimum Voltage"],
                        MaximumVoltage:    section["Maximum Voltage"],
                        ConfiguredVoltage: section["Configured Voltage"],
                }

                // Parse integer fields
                if val, ok := section["Rank"]; ok </span><span class="cov0" title="0">{
                        if rank, err := strconv.Atoi(strings.TrimSpace(val)); err == nil </span><span class="cov0" title="0">{
                                device.Rank = rank
                        }</span>
                }
                <span class="cov0" title="0">if val, ok := section["Data Width"]; ok </span><span class="cov0" title="0">{
                        if width, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(val), " bits")); err == nil </span><span class="cov0" title="0">{
                                device.DataWidth = width
                        }</span>
                }
                <span class="cov0" title="0">if val, ok := section["Total Width"]; ok </span><span class="cov0" title="0">{
                        if width, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(val), " bits")); err == nil </span><span class="cov0" title="0">{
                                device.TotalWidth = width
                        }</span>
                }

                <span class="cov0" title="0">devices = append(devices, device)</span>
        }

        <span class="cov0" title="0">return devices, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package lib

import (
        "fmt"
        "strconv"
        "strings"
)

// EthtoolInfo contains parsed ethtool information for a network interface
type EthtoolInfo struct {
        SupportedPorts       []string
        SupportedLinkModes   []string
        SupportedPauseFrame  string
        SupportsAutoNeg      bool
        SupportedFECModes    []string
        AdvertisedLinkModes  []string
        AdvertisedPauseFrame string
        AdvertisedAutoNeg    bool
        AdvertisedFECModes   []string
        Duplex               string
        AutoNegotiation      string
        Port                 string
        PHYAD                int
        Transceiver          string
        MDIX                 string
        SupportsWakeOn       []string
        WakeOn               string
        MessageLevel         string
        LinkDetected         bool
        MTU                  int
}

// ParseEthtool parses ethtool output for a network interface
func ParseEthtool(ifName string) (*EthtoolInfo, error) <span class="cov0" title="0">{
        // Check if ethtool is available
        if !CommandExists("ethtool") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ethtool command not found")
        }</span>

        <span class="cov0" title="0">output, err := ExecCommandOutput("ethtool", ifName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute ethtool: %w", err)
        }</span>

        <span class="cov0" title="0">info := &amp;EthtoolInfo{}
        lines := strings.Split(output, "\n")

        var inSupportedLinkModes bool
        var inAdvertisedLinkModes bool

        for _, line := range lines </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(line)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse key-value pairs
                <span class="cov0" title="0">if strings.Contains(trimmed, ":") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(trimmed, ":", 2)
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                        value := strings.TrimSpace(parts[1])

                        inSupportedLinkModes, inAdvertisedLinkModes = parseEthtoolKeyValue(
                                info, key, value, inSupportedLinkModes, inAdvertisedLinkModes,
                        )</span>
                } else<span class="cov0" title="0"> {
                        // Handle multi-line values (link modes)
                        if inSupportedLinkModes &amp;&amp; trimmed != "" </span><span class="cov0" title="0">{
                                info.SupportedLinkModes = append(info.SupportedLinkModes, trimmed)
                        }</span> else<span class="cov0" title="0"> if inAdvertisedLinkModes &amp;&amp; trimmed != "" </span><span class="cov0" title="0">{
                                info.AdvertisedLinkModes = append(info.AdvertisedLinkModes, trimmed)
                        }</span>
                }
        }

        <span class="cov0" title="0">return info, nil</span>
}

// parseEthtoolKeyValue parses a single key-value pair from ethtool output
func parseEthtoolKeyValue(info *EthtoolInfo, key, value string, inSupported, inAdvertised bool) (bool, bool) <span class="cov8" title="1">{
        switch key </span>{
        case "Supported ports":<span class="cov8" title="1">
                info.SupportedPorts = parseListValue(value)</span>
        case "Supported link modes":<span class="cov8" title="1">
                inSupported = true
                inAdvertised = false
                if value != "" </span><span class="cov8" title="1">{
                        info.SupportedLinkModes = append(info.SupportedLinkModes, value)
                }</span>
        case "Supported pause frame use":<span class="cov8" title="1">
                info.SupportedPauseFrame = value</span>
        case "Supports auto-negotiation":<span class="cov8" title="1">
                info.SupportsAutoNeg = value == "Yes"</span>
        case "Supported FEC modes":<span class="cov8" title="1">
                info.SupportedFECModes = parseListValue(value)</span>
        case "Advertised link modes":<span class="cov8" title="1">
                inAdvertised = true
                inSupported = false
                if value != "" </span><span class="cov8" title="1">{
                        info.AdvertisedLinkModes = append(info.AdvertisedLinkModes, value)
                }</span>
        case "Advertised pause frame use":<span class="cov8" title="1">
                info.AdvertisedPauseFrame = value</span>
        case "Advertised auto-negotiation":<span class="cov8" title="1">
                info.AdvertisedAutoNeg = value == "Yes"</span>
        case "Advertised FEC modes":<span class="cov8" title="1">
                info.AdvertisedFECModes = parseListValue(value)</span>
        case "Speed":<span class="cov8" title="1"></span>
                // Speed is already parsed elsewhere, skip
        case "Duplex":<span class="cov8" title="1">
                info.Duplex = value</span>
        case "Auto-negotiation":<span class="cov8" title="1">
                info.AutoNegotiation = value</span>
        case "Port":<span class="cov8" title="1">
                info.Port = value</span>
        case "PHYAD":<span class="cov8" title="1">
                if phyad, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        info.PHYAD = phyad
                }</span>
        case "Transceiver":<span class="cov8" title="1">
                info.Transceiver = value</span>
        case "MDI-X":<span class="cov8" title="1">
                info.MDIX = value</span>
        case "Supports Wake-on":<span class="cov8" title="1">
                info.SupportsWakeOn = parseWakeOnFlags(value)</span>
        case "Wake-on":<span class="cov8" title="1">
                info.WakeOn = value</span>
        case "Current message level":<span class="cov8" title="1">
                info.MessageLevel = value</span>
        case "Link detected":<span class="cov8" title="1">
                info.LinkDetected = value == "yes"</span>
        }
        <span class="cov8" title="1">return inSupported, inAdvertised</span>
}

// parseListValue parses a comma-separated or space-separated list
func parseListValue(value string) []string <span class="cov8" title="1">{
        if value == "" || value == "Not reported" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var result []string
        if strings.Contains(value, ",") </span><span class="cov8" title="1">{
                parts := strings.Split(value, ",")
                for _, part := range parts </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(part)
                        if trimmed != "" </span><span class="cov8" title="1">{
                                result = append(result, trimmed)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                parts := strings.Fields(value)
                result = append(result, parts...)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// parseWakeOnFlags parses Wake-on-LAN flags
func parseWakeOnFlags(value string) []string <span class="cov8" title="1">{
        if value == "" || value == "Not supported" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var flags []string
        for _, char := range value </span><span class="cov8" title="1">{
                switch char </span>{
                case 'p':<span class="cov8" title="1">
                        flags = append(flags, "PHY activity")</span>
                case 'u':<span class="cov8" title="1">
                        flags = append(flags, "Unicast")</span>
                case 'm':<span class="cov8" title="1">
                        flags = append(flags, "Multicast")</span>
                case 'b':<span class="cov8" title="1">
                        flags = append(flags, "Broadcast")</span>
                case 'a':<span class="cov8" title="1">
                        flags = append(flags, "ARP")</span>
                case 'g':<span class="cov8" title="1">
                        flags = append(flags, "MagicPacket")</span>
                case 's':<span class="cov8" title="1">
                        flags = append(flags, "SecureOn password")</span>
                case 'd':<span class="cov8" title="1">
                        flags = append(flags, "Disabled")</span>
                }
        }

        <span class="cov8" title="1">return flags</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package lib provides utility functions for parsing, validation, and shell command execution.
package lib

import (
        "fmt"

        "gopkg.in/ini.v1"
)

// ParseINIFile parses an INI file and returns a map
func ParseINIFile(path string) (map[string]string, error) <span class="cov8" title="1">{
        cfg, err := ini.Load(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse INI file %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">result := make(map[string]string)
        // Get the default section (unnamed section)
        defaultSection := cfg.Section("")
        for _, key := range defaultSection.Keys() </span><span class="cov8" title="1">{
                result[key.Name()] = key.String()
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// GetINIValue gets a value from INI file with default
func GetINIValue(iniData map[string]string, key string, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := iniData[key]; ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package lib

import (
        "bufio"
        "context"
        "fmt"
        "os/exec"
        "time"
)

// ExecCommand executes a shell command with timeout
func ExecCommand(command string, args ...string) ([]string, error) <span class="cov8" title="1">{
        return ExecCommandWithTimeout(60*time.Second, command, args...)
}</span>

// ExecCommandWithTimeout executes a command with a specific timeout
func ExecCommandWithTimeout(timeout time.Duration, command string, args ...string) ([]string, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        cmd := exec.CommandContext(ctx, command, args...)
        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov8" title="1">if err := cmd.Start(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to start command: %w", err)
        }</span>

        <span class="cov8" title="1">var lines []string
        scanner := bufio.NewScanner(stdout)
        for scanner.Scan() </span><span class="cov8" title="1">{
                lines = append(lines, scanner.Text())
        }</span>

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return lines, fmt.Errorf("error reading output: %w", err)
        }</span>

        <span class="cov8" title="1">if err := cmd.Wait(); err != nil </span><span class="cov8" title="1">{
                // Check if it was a timeout
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov8" title="1">{
                        return lines, fmt.Errorf("command timed out after %v", timeout)
                }</span>
                <span class="cov0" title="0">return lines, fmt.Errorf("command failed: %w", err)</span>
        }

        <span class="cov8" title="1">return lines, nil</span>
}

// ExecCommandOutput executes a command and returns combined output
func ExecCommandOutput(command string, args ...string) (string, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        cmd := exec.CommandContext(ctx, command, args...)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov8" title="1">{
                return string(output), fmt.Errorf("command failed: %w", err)
        }</span>

        <span class="cov8" title="1">return string(output), nil</span>
}

// CommandExists checks if a command exists in PATH
func CommandExists(command string) bool <span class="cov8" title="1">{
        _, err := exec.LookPath(command)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package testutil provides test utilities and mocks for unit testing.
package testutil

import (
        "os"
        "path/filepath"
        "testing"
)

// TempDir creates a temporary directory and returns its path and a cleanup function.
func TempDir(t *testing.T) (string, func()) <span class="cov8" title="1">{
        t.Helper()
        dir, err := os.MkdirTemp("", "unraid-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp dir: %v", err)
        }</span>
        <span class="cov8" title="1">return dir, func() </span><span class="cov8" title="1">{
                //nolint:gosec,errcheck // G104: Cleanup in tests - errors are acceptable
                _ = os.RemoveAll(dir)
        }</span>
}

// WriteFile writes content to a file in the given directory.
func WriteFile(t *testing.T, dir, filename, content string) string <span class="cov8" title="1">{
        t.Helper()
        path := filepath.Join(dir, filename)
        //nolint:gosec // G301: Test directory permissions - 0755 is acceptable for tests
        if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create directory: %v", err)
        }</span>
        //nolint:gosec // G306: Test file permissions - 0644 is acceptable for tests
        <span class="cov8" title="1">if err := os.WriteFile(path, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write file %s: %v", path, err)
        }</span>
        <span class="cov8" title="1">return path</span>
}

// ReadFileContent reads file content or fails the test.
func ReadFileContent(t *testing.T, path string) string <span class="cov8" title="1">{
        t.Helper()
        //nolint:gosec // G304: Test utility - path comes from test code, not user input
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to read file %s: %v", path, err)
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

// SampleProcMeminfo returns sample /proc/meminfo content.
func SampleProcMeminfo() string <span class="cov8" title="1">{
        return `MemTotal:       32653968 kB
MemFree:        15234568 kB
MemAvailable:   20123456 kB
Buffers:          512000 kB
Cached:          4876900 kB
SwapCached:            0 kB
Active:          8765432 kB
Inactive:        5432100 kB
`
}</span>

// SampleProcStat returns sample /proc/stat content.
func SampleProcStat() string <span class="cov8" title="1">{
        return `cpu  10132153 290696 3084719 46828483 16683 0 25195 0 0 0
cpu0 1292830 36410 386526 5765120 3479 0 11149 0 0 0
cpu1 1291881 36252 385618 5764888 2500 0 3146 0 0 0
cpu2 1291758 36194 385598 5764817 2413 0 2674 0 0 0
cpu3 1291737 36194 385572 5764808 2396 0 2339 0 0 0
intr 2063079 0 9 0 0 0 0 4 0 1 0 0 0 156 0 0 0 0 0 0 0 0 0 0 0 0
ctxt 123456789
btime 1609459200
processes 123456
procs_running 2
procs_blocked 0
`
}</span>

// SampleProcUptime returns sample /proc/uptime content.
func SampleProcUptime() string <span class="cov8" title="1">{
        return `12345.67 98765.43`
}</span>

// SampleProcCPUInfo returns sample /proc/cpuinfo content.
func SampleProcCPUInfo() string <span class="cov8" title="1">{
        return `processor        : 0
vendor_id        : GenuineIntel
cpu family        : 6
model                : 158
model name        : Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz
stepping        : 10
microcode        : 0xea
cpu MHz                : 3700.000
cache size        : 12288 KB
physical id        : 0
siblings        : 12
core id                : 0
cpu cores        : 6
apicid                : 0
initial apicid        : 0
fpu                : yes
fpu_exception        : yes
cpuid level        : 22
wp                : yes
flags                : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single pti ssbd ibrs ibpb stibp tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d
vmx flags        : vnmi preemption_timer invvpid ept_x_only ept_ad ept_1gb flexpriority tsc_offset vtpr mtf vapic ept vpid unrestricted_guest ple shadow_vmcs pml ept_mode_based_exec
bugs                : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit
bogomips        : 7399.70
clflush size        : 64
cache_alignment        : 64
address sizes        : 39 bits physical, 48 bits virtual
power management:

processor        : 1
vendor_id        : GenuineIntel
cpu family        : 6
model                : 158
model name        : Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz
stepping        : 10
cpu MHz                : 3700.000
physical id        : 0
siblings        : 12
core id                : 1
cpu cores        : 6
flags                : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single pti ssbd ibrs ibpb stibp
bogomips        : 7399.70
`
}</span>

// SampleDmidecodeOutput returns sample dmidecode output for BIOS (type 0).
func SampleDmidecodeOutput() string <span class="cov8" title="1">{
        return `# dmidecode 3.3
Getting SMBIOS data from sysfs.
SMBIOS 3.1.1 present.

Handle 0x0000, DMI type 0, 26 bytes
BIOS Information
        Vendor: American Megatrends Inc.
        Version: 1.80
        Release Date: 05/17/2019
        Address: 0xF0000
        Runtime Size: 64 kB
        ROM Size: 16 MB
        Characteristics:
                PCI is supported
                BIOS is upgradeable
        BIOS Revision: 5.13
`
}</span>

// SampleEthtoolOutput returns sample ethtool output.
func SampleEthtoolOutput() string <span class="cov8" title="1">{
        return `Settings for eth0:
        Supported ports: [ TP ]
        Supported link modes:   10baseT/Half 10baseT/Full
                                100baseT/Half 100baseT/Full
                                1000baseT/Full
        Supported pause frame use: Symmetric
        Supports auto-negotiation: Yes
        Supported FEC modes: Not reported
        Advertised link modes:  10baseT/Half 10baseT/Full
                                100baseT/Half 100baseT/Full
                                1000baseT/Full
        Advertised pause frame use: Symmetric
        Advertised auto-negotiation: Yes
        Advertised FEC modes: Not reported
        Speed: 1000Mb/s
        Duplex: Full
        Auto-negotiation: on
        Port: Twisted Pair
        PHYAD: 1
        Transceiver: internal
        MDI-X: off (auto)
        Supports Wake-on: pumbg
        Wake-on: g
        Current message level: 0x00000007 (7)
                               drv probe link
        Link detected: yes
`
}</span>

// SampleINIFile returns sample INI file content.
func SampleINIFile() string <span class="cov8" title="1">{
        return `version="7.2.0"
name="Tower"
timeZone="America/Los_Angeles"
port=80
localMaster=yes
flashGUID=1234-5678-9ABC-DEF0
`
}</span>

// SampleSensorsOutput returns sample sensors -u output.
func SampleSensorsOutput() string <span class="cov8" title="1">{
        return `coretemp-isa-0000
Adapter: ISA adapter
Core 0:
  temp2_input: 45.000
  temp2_max: 100.000
  temp2_crit: 100.000
Core 1:
  temp3_input: 46.000
  temp3_max: 100.000
  temp3_crit: 100.000
MB Temp:
  temp1_input: 38.000

nct6792-isa-0a20
Adapter: ISA adapter
fan1:
  fan1_input: 1200.000
fan2:
  fan2_input: 800.000
`
}</span>

// SampleDockerPSOutput returns sample docker ps --format json output.
func SampleDockerPSOutput() string <span class="cov8" title="1">{
        return `{"ID":"abc123","Names":"nginx","Image":"nginx:latest","State":"running","Status":"Up 2 hours"}
{"ID":"def456","Names":"redis","Image":"redis:alpine","State":"running","Status":"Up 1 hour"}`
}</span>

// SampleVirshListOutput returns sample virsh list --all output.
func SampleVirshListOutput() string <span class="cov8" title="1">{
        return ` Id   Name        State
-----------------------------
 1    ubuntu20    running
 -    windows10   shut off
 -    debian11    shut off
`
}</span>

// SampleArrayINI returns sample array configuration.
func SampleArrayINI() string <span class="cov8" title="1">{
        return `mdState=STARTED
mdNumDisks=4
mdNumParity=1
sbSynced="Mon Jan  1 00:00:01 2024 18645 MB/s + 38044 MB/s"
sbSynced2=0
`
}</span>

// SampleDisksINI returns sample disks configuration.
func SampleDisksINI() string <span class="cov8" title="1">{
        return `[disk1]
name=disk1
device=sda
id=WDC_WD40EFAX-68JH4N1_WD-WX11D80D1234
size=4000787030016
status=DISK_OK
temp=35

[disk2]
name=disk2
device=sdb
id=WDC_WD40EFAX-68JH4N1_WD-WX11D80D5678
size=4000787030016
status=DISK_OK
temp=36
`
}</span>

// SampleNetworkINI returns sample network configuration.
func SampleNetworkINI() string <span class="cov8" title="1">{
        return `[eth0]
NAME=eth0
IPADDR=192.168.1.100
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
DNS_SERVER1=8.8.8.8
DNS_SERVER2=8.8.4.4
`
}</span>

// SampleSharesINI returns sample shares configuration.
func SampleSharesINI() string <span class="cov8" title="1">{
        return `[appdata]
name=appdata
comment=Application Data
allocator=highwater
splitLevel=
include=disk1,disk2
exclude=
useCache=yes

[media]
name=media
comment=Media Files
allocator=highwater
splitLevel=
include=
exclude=
useCache=no
`
}</span>

// SampleNvidiaSMIOutput returns sample nvidia-smi output.
func SampleNvidiaSMIOutput() string <span class="cov8" title="1">{
        return `==============NVSMI LOG==============

Timestamp                                 : Thu Jan  1 00:00:00 2024
Driver Version                            : 535.154.05
CUDA Version                              : 12.2

Attached GPUs                             : 1
GPU 00000000:01:00.0
    Product Name                          : NVIDIA GeForce RTX 3080
    Product Brand                         : GeForce
    GPU UUID                              : GPU-12345678-1234-1234-1234-123456789abc
    Fan Speed                             : 45 %
    Temperature
        GPU Current Temp                  : 55 C
        GPU Shutdown Temp                 : 98 C
        GPU Max Operating Temp            : 93 C
    Power Readings
        Power Draw                        : 120.50 W
        Power Limit                       : 320.00 W
    Memory Usage
        Total                             : 10240 MiB
        Used                              : 2048 MiB
        Free                              : 8192 MiB
    Utilization
        Gpu                               : 25 %
        Memory                            : 20 %
`
}</span>

// SampleUPSOutput returns sample apcaccess output.
func SampleUPSOutput() string <span class="cov8" title="1">{
        return `APC      : 001,034,0856
DATE     : 2024-01-01 00:00:00 +0000
HOSTNAME : tower
VERSION  : 3.14.14
UPSNAME  : Back-UPS RS 1500
CABLE    : USB Cable
DRIVER   : USB UPS Driver
UPSMODE  : Stand Alone
STARTTIME: 2024-01-01 00:00:00 +0000
MODEL    : Back-UPS RS 1500MS
STATUS   : ONLINE
LINEV    : 120.0 Volts
LOADPCT  : 25.0 Percent
BCHARGE  : 100.0 Percent
TIMELEFT : 45.0 Minutes
MBATTCHG : 5 Percent
MINTIMEL : 3 Minutes
MAXTIME  : 0 Seconds
OUTPUTV  : 120.0 Volts
SENSE    : Medium
DWAKE    : -1 Seconds
DSHUTD   : 0 Seconds
LOTRANS  : 88.0 Volts
HITRANS  : 139.0 Volts
ALARMDEL : 30 Seconds
BATTV    : 27.1 Volts
LASTXFER : Automatic or explicit self test
NUMXFERS : 0
TONBATT  : 0 Seconds
CUMONBATT: 0 Seconds
XOFFBATT : N/A
SELFTEST : NO
STATFLAG : 0x05000008
SERIALNO : 1B2345C67890
BATTDATE : 2023-01-15
NOMINV   : 120 Volts
NOMBATTV : 24.0 Volts
NOMPOWER : 900 Watts
FIRMWARE : 928.a9 .D USB FW:a9
END APC  : 2024-01-01 00:00:00 +0000
`
}</span>

// SampleZFSPoolOutput returns sample zpool list output.
func SampleZFSPoolOutput() string <span class="cov8" title="1">{
        return `NAME    SIZE  ALLOC   FREE  CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP    HEALTH  ALTROOT
pool1  3.62T  1.21T  2.41T        -         -     5%    33%  1.00x    ONLINE  -
pool2  7.27T  3.50T  3.77T        -         -    10%    48%  1.00x    ONLINE  -
`
}</span>

// SampleZFSDatasetOutput returns sample zfs list output.
func SampleZFSDatasetOutput() string <span class="cov8" title="1">{
        return `NAME                   USED  AVAIL     REFER  MOUNTPOINT
pool1                 1.21T  2.30T       96K  /mnt/pool1
pool1/data            500G  2.30T      500G  /mnt/pool1/data
pool1/backup          720G  2.30T      720G  /mnt/pool1/backup
`
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package lib

import (
        "fmt"
        "math"
        "os"
        "strconv"
        "strings"
)

// FileExists checks if a file exists
func FileExists(path string) bool <span class="cov8" title="1">{
        _, err := os.Stat(path)
        return err == nil
}</span>

// ReadFile reads entire file contents
func ReadFile(path string) (string, error) <span class="cov8" title="1">{
        //nolint:gosec // G304: Path is from trusted sources (system files, config files), not user input
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to read file %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">return string(data), nil</span>
}

// ReadLines reads a file and returns lines
func ReadLines(path string) ([]string, error) <span class="cov8" title="1">{
        content, err := ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return strings.Split(content, "\n"), nil</span>
}

// ParseFloat safely parses a float from string
func ParseFloat(s string) float64 <span class="cov8" title="1">{
        f, err := strconv.ParseFloat(strings.TrimSpace(s), 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return f</span>
}

// ParseInt safely parses an integer from string
func ParseInt(s string) int <span class="cov8" title="1">{
        i, err := strconv.Atoi(strings.TrimSpace(s))
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return i</span>
}

// ParseUint64 safely parses uint64 from string
func ParseUint64(s string) uint64 <span class="cov8" title="1">{
        i, err := strconv.ParseUint(strings.TrimSpace(s), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return i</span>
}

// Round rounds a float to nearest integer
func Round(f float64) int <span class="cov8" title="1">{
        if f &lt; 0 </span><span class="cov8" title="1">{
                return int(f - 0.5)
        }</span>
        <span class="cov8" title="1">return int(f + 0.5)</span>
}

// RoundFloat rounds a float to n decimal places
func RoundFloat(f float64, decimals int) float64 <span class="cov8" title="1">{
        multiplier := math.Pow(10, float64(decimals))
        return math.Round(f*multiplier) / multiplier
}</span>

// ParseKeyValue parses "key=value" format
func ParseKeyValue(line string) (string, string) <span class="cov8" title="1">{
        parts := strings.SplitN(line, "=", 2)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return "", ""
        }</span>
        <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
        value := strings.Trim(strings.TrimSpace(parts[1]), "\"")
        return key, value</span>
}

// ParseKeyValueMap parses multiple key=value lines into a map
func ParseKeyValueMap(lines []string) map[string]string <span class="cov8" title="1">{
        result := make(map[string]string)
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">key, value := ParseKeyValue(line)
                if key != "" </span><span class="cov8" title="1">{
                        result[key] = value
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// BytesToGB converts bytes to gigabytes
func BytesToGB(bytes uint64) float64 <span class="cov8" title="1">{
        return float64(bytes) / 1024 / 1024 / 1024
}</span>

// BytesToMB converts bytes to megabytes
func BytesToMB(bytes uint64) float64 <span class="cov8" title="1">{
        return float64(bytes) / 1024 / 1024
}</span>

// GBToBytes converts gigabytes to bytes
func GBToBytes(gb float64) uint64 <span class="cov8" title="1">{
        return uint64(gb * 1024 * 1024 * 1024)
}</span>

// MBToBytes converts megabytes to bytes
func MBToBytes(mb float64) uint64 <span class="cov8" title="1">{
        return uint64(mb * 1024 * 1024)
}</span>

// KBToBytes converts kilobytes to bytes
func KBToBytes(kb float64) uint64 <span class="cov8" title="1">{
        return uint64(kb * 1024)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package lib

import (
        "fmt"
        "regexp"
        "strings"
)

var (
        // Docker container IDs are either 12 or 64 hexadecimal characters
        containerIDShortRegex = regexp.MustCompile(`^[a-f0-9]{12}$`)
        containerIDFullRegex  = regexp.MustCompile(`^[a-f0-9]{64}$`)

        // VM names: alphanumeric, spaces, hyphens, underscores, dots (max 253 chars)
        // Based on common VM naming practices (allows spaces for user-friendly names)
        vmNameRegex = regexp.MustCompile(`^[a-zA-Z0-9 _.-]{1,253}$`)

        // Disk IDs: common Linux disk naming patterns
        // Examples: sda, sdb1, nvme0n1, nvme0n1p1, md0, loop0
        diskIDRegex = regexp.MustCompile(`^(sd[a-z]|nvme[0-9]+n[0-9]+|md[0-9]+|loop[0-9]+)(p?[0-9]+)?$`)

        // Share names: alphanumeric, hyphens, underscores (max 255 chars)
        // Must not contain path separators or parent directory references
        shareNameRegex = regexp.MustCompile(`^[a-zA-Z0-9_-]{1,255}$`)

        // User script names: alphanumeric, hyphens, underscores, dots (max 255 chars)
        // Must not contain path separators or parent directory references
        userScriptNameRegex = regexp.MustCompile(`^[a-zA-Z0-9_.-]{1,255}$`)
)

// ValidateContainerID validates a Docker container ID format
// Accepts both short (12 chars) and full (64 chars) hexadecimal IDs
func ValidateContainerID(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("container ID cannot be empty")
        }</span>

        // Convert to lowercase for validation
        <span class="cov8" title="1">id = strings.ToLower(id)

        // Check if it matches either short or full format
        if containerIDShortRegex.MatchString(id) || containerIDFullRegex.MatchString(id) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("invalid container ID format: must be 12 or 64 hexadecimal characters")</span>
}

// ValidateVMName validates a virtual machine name
// Allows alphanumeric characters, spaces, hyphens, underscores, and dots
// Maximum length: 253 characters (DNS hostname limit)
func ValidateVMName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("VM name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 253 </span><span class="cov8" title="1">{
                return fmt.Errorf("VM name too long: maximum 253 characters, got %d", len(name))
        }</span>

        <span class="cov8" title="1">if !vmNameRegex.MatchString(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid VM name format: must contain only alphanumeric characters, spaces, hyphens, underscores, and dots")
        }</span>

        // Additional checks for common issues
        <span class="cov8" title="1">if strings.HasPrefix(name, "-") || strings.HasSuffix(name, "-") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid VM name: cannot start or end with hyphen")
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(name, ".") || strings.HasSuffix(name, ".") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid VM name: cannot start or end with dot")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateDiskID validates a disk identifier
// Supports common Linux disk naming patterns
func ValidateDiskID(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("disk ID cannot be empty")
        }</span>

        <span class="cov8" title="1">if !diskIDRegex.MatchString(id) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid disk ID format: must match Linux disk naming pattern (e.g., sda, nvme0n1, md0)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateShareName validates an Unraid share name
// Prevents path traversal attacks by ensuring the name contains only safe characters
// and does not contain path separators or parent directory references
func ValidateShareName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("share name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov8" title="1">{
                return fmt.Errorf("share name too long: maximum 255 characters, got %d", len(name))
        }</span>

        // Check for parent directory references first (more specific check)
        <span class="cov8" title="1">if strings.Contains(name, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid share name: cannot contain parent directory references")
        }</span>

        // Check for path separators
        <span class="cov8" title="1">if strings.Contains(name, "/") || strings.Contains(name, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid share name: cannot contain path separators")
        }</span>

        // Validate against regex pattern (alphanumeric, hyphens, underscores only)
        <span class="cov8" title="1">if !shareNameRegex.MatchString(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid share name format: must contain only alphanumeric characters, hyphens, and underscores")
        }</span>

        // Additional checks for common issues
        <span class="cov8" title="1">if strings.HasPrefix(name, "-") || strings.HasSuffix(name, "-") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid share name: cannot start or end with hyphen")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateNonEmpty validates that a string is not empty or whitespace-only
func ValidateNonEmpty(value, fieldName string) error <span class="cov8" title="1">{
        if strings.TrimSpace(value) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%s cannot be empty", fieldName)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateMaxLength validates that a string does not exceed maximum length
func ValidateMaxLength(value, fieldName string, maxLength int) error <span class="cov8" title="1">{
        if len(value) &gt; maxLength </span><span class="cov8" title="1">{
                return fmt.Errorf("%s too long: maximum %d characters, got %d", fieldName, maxLength, len(value))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateUserScriptName validates a user script name
// Prevents path traversal attacks by ensuring the name contains only safe characters
// and does not contain path separators or parent directory references
func ValidateUserScriptName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("user script name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov8" title="1">{
                return fmt.Errorf("user script name too long: maximum 255 characters, got %d", len(name))
        }</span>

        // Check for parent directory references first (more specific check)
        <span class="cov8" title="1">if strings.Contains(name, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid user script name: cannot contain parent directory references")
        }</span>

        // Check for path separators
        <span class="cov8" title="1">if strings.Contains(name, "/") || strings.Contains(name, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid user script name: cannot contain path separators")
        }</span>

        // Check for absolute paths
        <span class="cov8" title="1">if strings.HasPrefix(name, "/") || strings.HasPrefix(name, "\\") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid user script name: cannot be an absolute path")
        }</span>

        // Validate against regex pattern (alphanumeric, hyphens, underscores, dots only)
        <span class="cov8" title="1">if !userScriptNameRegex.MatchString(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid user script name format: must contain only alphanumeric characters, hyphens, underscores, and dots")
        }</span>

        // Additional checks for common issues
        <span class="cov8" title="1">if strings.HasPrefix(name, "-") || strings.HasSuffix(name, "-") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid user script name: cannot start or end with hyphen")
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(name, ".") || strings.HasSuffix(name, ".") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid user script name: cannot start or end with dot")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateLogFilename validates a log filename
// Prevents path traversal attacks (CWE-22) by ensuring the filename contains only safe characters
// and does not contain path separators or parent directory references
func ValidateLogFilename(name string) bool <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for parent directory references (CWE-22 path traversal)
        <span class="cov8" title="1">if strings.Contains(name, "..") </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for path separators (only allow forward slashes for plugin log paths like "plugin/file.log")
        <span class="cov8" title="1">if strings.Contains(name, "\\") </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for absolute paths
        <span class="cov8" title="1">if strings.HasPrefix(name, "/") </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for null bytes (CWE-158)
        <span class="cov8" title="1">if strings.Contains(name, "\x00") </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package logger provides structured logging functionality with color-coded output and log rotation.
package logger

import (
        "fmt"
        "log"
)

// LogLevel represents the logging verbosity level
type LogLevel int

const (
        // LevelDebug enables all logging including debug messages
        LevelDebug LogLevel = iota
        // LevelInfo enables info, warning, and error messages
        LevelInfo
        // LevelWarning enables warning and error messages only
        LevelWarning
        // LevelError enables error messages only
        LevelError
)

var currentLevel = LevelWarning // Default to WARNING level for production

// Color codes for terminal output
const (
        ColorReset  = "\033[0m"
        ColorRed    = "\033[31m"
        ColorGreen  = "\033[32m"
        ColorYellow = "\033[33m"
        ColorBlue   = "\033[34m"
        ColorPurple = "\033[35m"
        ColorCyan   = "\033[36m"
        ColorWhite  = "\033[37m"
)

// SetLevel sets the global logging level
func SetLevel(level LogLevel) <span class="cov8" title="1">{
        currentLevel = level
}</span>

// GetLevel returns the current logging level
func GetLevel() LogLevel <span class="cov8" title="1">{
        return currentLevel
}</span>

// Info logs informational messages in blue
func Info(format string, v ...interface{}) <span class="cov8" title="1">{
        if currentLevel &lt;= LevelInfo </span><span class="cov8" title="1">{
                log.Printf(ColorBlue+format+ColorReset, v...)
        }</span>
}

// Success logs success messages in green
func Success(format string, v ...interface{}) <span class="cov8" title="1">{
        if currentLevel &lt;= LevelInfo </span><span class="cov8" title="1">{
                log.Printf(ColorGreen+format+ColorReset, v...)
        }</span>
}

// Warning logs warning messages in yellow
func Warning(format string, v ...interface{}) <span class="cov8" title="1">{
        if currentLevel &lt;= LevelWarning </span><span class="cov8" title="1">{
                log.Printf(ColorYellow+"WARNING: "+format+ColorReset, v...)
        }</span>
}

// Error logs error messages in red
func Error(format string, v ...interface{}) <span class="cov8" title="1">{
        if currentLevel &lt;= LevelError </span><span class="cov8" title="1">{
                log.Printf(ColorRed+"ERROR: "+format+ColorReset, v...)
        }</span>
}

// Debug logs debug messages in cyan (only if debug level is enabled)
func Debug(format string, v ...interface{}) <span class="cov8" title="1">{
        if currentLevel &lt;= LevelDebug </span><span class="cov8" title="1">{
                log.Printf(ColorCyan+"DEBUG: "+format+ColorReset, v...)
        }</span>
}

// Fatal logs fatal error and exits
func Fatal(format string, v ...interface{}) <span class="cov0" title="0">{
        log.Fatalf(ColorRed+"FATAL: "+format+ColorReset, v...)
}</span>

// Plain logs without color
func Plain(format string, v ...interface{}) <span class="cov8" title="1">{
        log.Printf(format, v...)
}</span>

// Blue alias for Info
func Blue(format string, v ...interface{}) <span class="cov8" title="1">{
        Info(format, v...)
}</span>

// Yellow alias for Warning
func Yellow(format string, v ...interface{}) <span class="cov8" title="1">{
        Warning(format, v...)
}</span>

// Green alias for Success
func Green(format string, v ...interface{}) <span class="cov8" title="1">{
        Success(format, v...)
}</span>

// LightGreen logs in light green
func LightGreen(format string, v ...interface{}) <span class="cov8" title="1">{
        if currentLevel &lt;= LevelInfo </span><span class="cov8" title="1">{
                log.Printf("\033[92m"+format+ColorReset, v...)
        }</span>
}

// Printf is a wrapper for standard log.Printf
func Printf(format string, v ...interface{}) <span class="cov8" title="1">{
        if currentLevel &lt;= LevelInfo </span><span class="cov8" title="1">{
                log.Printf(format, v...)
        }</span>
}

// Println is a wrapper for standard log.Println
func Println(v ...interface{}) <span class="cov8" title="1">{
        if currentLevel &lt;= LevelInfo </span><span class="cov8" title="1">{
                log.Println(v...)
        }</span>
}

// Sprintf formats and returns a string
func Sprintf(format string, v ...interface{}) string <span class="cov8" title="1">{
        return fmt.Sprintf(format, v...)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package api provides HTTP REST API handlers and WebSocket functionality for the Unraid Management Agent.
package api

import (
        "encoding/json"
        "fmt"
        "net/http"
        "path/filepath"
        "time"

        "github.com/gorilla/mux"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/services/controllers"
)

func (s *Server) handleHealth(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        respondJSON(w, http.StatusOK, map[string]string{"status": "ok"})
}</span>

func (s *Server) handleSystem(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest system info from cache
        s.cacheMutex.RLock()
        info := s.systemCache
        s.cacheMutex.RUnlock()

        if info == nil </span><span class="cov8" title="1">{
                info = &amp;dto.SystemInfo{
                        Hostname:  "unknown",
                        Version:   s.ctx.Version,
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, info)</span>
}

// handleSystemReboot initiates a system reboot
func (s *Server) handleSystemReboot(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Info("API: System reboot requested")

        systemCtrl := controllers.NewSystemController(s.ctx)
        err := systemCtrl.Reboot()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to initiate reboot: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to initiate reboot: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Server reboot initiated",
                Timestamp: time.Now(),
        })</span>
}

// handleSystemShutdown initiates a system shutdown
func (s *Server) handleSystemShutdown(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Info("API: System shutdown requested")

        systemCtrl := controllers.NewSystemController(s.ctx)
        err := systemCtrl.Shutdown()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to initiate shutdown: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to initiate shutdown: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Server shutdown initiated",
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleArray(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest array status from cache
        s.cacheMutex.RLock()
        status := s.arrayCache
        s.cacheMutex.RUnlock()

        if status == nil </span><span class="cov8" title="1">{
                status = &amp;dto.ArrayStatus{
                        State:     "unknown",
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, status)</span>
}

func (s *Server) handleDisks(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest disk list from cache
        s.cacheMutex.RLock()
        disks := s.disksCache
        s.cacheMutex.RUnlock()

        if disks == nil </span><span class="cov8" title="1">{
                disks = []dto.DiskInfo{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, disks)</span>
}

func (s *Server) handleDisk(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        diskID := vars["id"]
        logger.Debug("API: Getting disk info for %s", diskID)

        s.cacheMutex.RLock()
        disks := s.disksCache
        s.cacheMutex.RUnlock()

        // Find disk by ID
        for _, disk := range disks </span><span class="cov8" title="1">{
                if disk.ID == diskID || disk.Device == diskID || disk.Name == diskID </span><span class="cov8" title="1">{
                        respondJSON(w, http.StatusOK, disk)
                        return
                }</span>
        }

        // Disk not found
        <span class="cov8" title="1">respondJSON(w, http.StatusNotFound, dto.Response{
                Success:   false,
                Message:   fmt.Sprintf("Disk not found: %s", diskID),
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleShares(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest share list from cache
        s.cacheMutex.RLock()
        shares := s.sharesCache
        s.cacheMutex.RUnlock()

        if shares == nil </span><span class="cov8" title="1">{
                shares = []dto.ShareInfo{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, shares)</span>
}

func (s *Server) handleDockerList(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest container list from cache
        s.cacheMutex.RLock()
        containers := s.dockerCache
        s.cacheMutex.RUnlock()

        if containers == nil </span><span class="cov8" title="1">{
                containers = []dto.ContainerInfo{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, containers)</span>
}

func (s *Server) handleDockerInfo(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        containerID := vars["id"]
        logger.Debug("API: Getting container info for %s", containerID)

        s.cacheMutex.RLock()
        containers := s.dockerCache
        s.cacheMutex.RUnlock()

        // Find container by ID or name
        for _, container := range containers </span><span class="cov8" title="1">{
                if container.ID == containerID || container.Name == containerID </span><span class="cov8" title="1">{
                        respondJSON(w, http.StatusOK, container)
                        return
                }</span>
        }

        // Container not found
        <span class="cov8" title="1">respondJSON(w, http.StatusNotFound, dto.Response{
                Success:   false,
                Message:   fmt.Sprintf("Container not found: %s", containerID),
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleVMList(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest VM list from cache
        s.cacheMutex.RLock()
        vms := s.vmsCache
        s.cacheMutex.RUnlock()

        if vms == nil </span><span class="cov8" title="1">{
                vms = []dto.VMInfo{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, vms)</span>
}

func (s *Server) handleVMInfo(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        vmID := vars["id"]
        logger.Debug("API: Getting VM info for %s", vmID)

        s.cacheMutex.RLock()
        vms := s.vmsCache
        s.cacheMutex.RUnlock()

        // Find VM by ID or name
        for _, vm := range vms </span><span class="cov8" title="1">{
                if vm.ID == vmID || vm.Name == vmID </span><span class="cov8" title="1">{
                        respondJSON(w, http.StatusOK, vm)
                        return
                }</span>
        }

        // VM not found
        <span class="cov8" title="1">respondJSON(w, http.StatusNotFound, dto.Response{
                Success:   false,
                Message:   fmt.Sprintf("VM not found: %s", vmID),
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleUPS(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest UPS status from cache
        s.cacheMutex.RLock()
        ups := s.upsCache
        s.cacheMutex.RUnlock()

        if ups == nil </span><span class="cov8" title="1">{
                ups = &amp;dto.UPSStatus{
                        Connected: false,
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, ups)</span>
}

func (s *Server) handleNUT(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest NUT status from cache
        s.cacheMutex.RLock()
        nut := s.nutCache
        s.cacheMutex.RUnlock()

        if nut == nil </span><span class="cov8" title="1">{
                nut = &amp;dto.NUTResponse{
                        Installed: false,
                        Running:   false,
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, nut)</span>
}

func (s *Server) handleGPU(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest GPU metrics from cache
        s.cacheMutex.RLock()
        gpus := s.gpuCache
        s.cacheMutex.RUnlock()

        if gpus == nil </span><span class="cov8" title="1">{
                gpus = []*dto.GPUMetrics{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, gpus)</span>
}

func (s *Server) handleNetwork(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Get latest network interfaces from cache
        s.cacheMutex.RLock()
        interfaces := s.networkCache
        s.cacheMutex.RUnlock()

        if interfaces == nil </span><span class="cov8" title="1">{
                interfaces = []dto.NetworkInfo{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, interfaces)</span>
}

// Generic Docker operation handler to reduce code duplication
//
//nolint:dupl // Similar to handleVMOperation but serves different purpose (Docker vs VM)
func (s *Server) handleDockerOperation(w http.ResponseWriter, r *http.Request, operation string, operationFunc func(string) error) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        containerID := vars["id"]

        // Validate container ID format
        if err := lib.ValidateContainerID(containerID); err != nil </span><span class="cov8" title="1">{
                logger.Warning("Invalid container ID for %s operation: %s - %v", operation, containerID, err)
                respondJSON(w, http.StatusBadRequest, dto.Response{
                        Success:   false,
                        Message:   err.Error(),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">logger.Info("%s container %s", operation, containerID)

        if err := operationFunc(containerID); err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to %s container %s: %v", operation, containerID, err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to %s container: %v", operation, err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   fmt.Sprintf("Container %s", operation),
                Timestamp: time.Now(),
        })</span>
}

// Generic VM operation handler to reduce code duplication
//
//nolint:dupl // Similar to handleDockerOperation but serves different purpose (VM vs Docker)
func (s *Server) handleVMOperation(w http.ResponseWriter, r *http.Request, operation string, operationFunc func(string) error) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        vmName := vars["name"]

        // Validate VM name format
        if err := lib.ValidateVMName(vmName); err != nil </span><span class="cov8" title="1">{
                logger.Warning("Invalid VM name for %s operation: %s - %v", operation, vmName, err)
                respondJSON(w, http.StatusBadRequest, dto.Response{
                        Success:   false,
                        Message:   err.Error(),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">logger.Info("%s VM %s", operation, vmName)

        if err := operationFunc(vmName); err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to %s VM %s: %v", operation, vmName, err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to %s VM: %v", operation, err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   fmt.Sprintf("VM %s", operation),
                Timestamp: time.Now(),
        })</span>
}

// Docker control handlers
func (s *Server) handleDockerStart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewDockerController()
        s.handleDockerOperation(w, r, "started", controller.Start)
}</span>

func (s *Server) handleDockerStop(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewDockerController()
        s.handleDockerOperation(w, r, "stopped", controller.Stop)
}</span>

func (s *Server) handleDockerRestart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewDockerController()
        s.handleDockerOperation(w, r, "restarted", controller.Restart)
}</span>

func (s *Server) handleDockerPause(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewDockerController()
        s.handleDockerOperation(w, r, "paused", controller.Pause)
}</span>

func (s *Server) handleDockerUnpause(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewDockerController()
        s.handleDockerOperation(w, r, "unpaused", controller.Unpause)
}</span>

// VM control handlers
func (s *Server) handleVMStart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewVMController()
        s.handleVMOperation(w, r, "started", controller.Start)
}</span>

func (s *Server) handleVMStop(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewVMController()
        s.handleVMOperation(w, r, "stopped", controller.Stop)
}</span>

func (s *Server) handleVMRestart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewVMController()
        s.handleVMOperation(w, r, "restarted", controller.Restart)
}</span>

func (s *Server) handleVMPause(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewVMController()
        s.handleVMOperation(w, r, "paused", controller.Pause)
}</span>

func (s *Server) handleVMResume(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewVMController()
        s.handleVMOperation(w, r, "resumed", controller.Resume)
}</span>

func (s *Server) handleVMHibernate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewVMController()
        s.handleVMOperation(w, r, "hibernated", controller.Hibernate)
}</span>

func (s *Server) handleVMForceStop(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        controller := controllers.NewVMController()
        s.handleVMOperation(w, r, "force stopped", controller.ForceStop)
}</span>

// Array control handlers
func (s *Server) handleArrayStart(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Info("API: Starting array")

        arrayCtrl := controllers.NewArrayController(s.ctx)
        err := arrayCtrl.StartArray()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to start array: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to start array: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Array started successfully",
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleArrayStop(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Info("API: Stopping array")

        arrayCtrl := controllers.NewArrayController(s.ctx)
        err := arrayCtrl.StopArray()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to stop array: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to stop array: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Array stopped successfully",
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleParityCheckStart(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Read optional 'correcting' parameter from query
        correcting := r.URL.Query().Get("correcting") == "true"
        logger.Info("API: Starting parity check (correcting: %v)", correcting)

        arrayCtrl := controllers.NewArrayController(s.ctx)
        err := arrayCtrl.StartParityCheck(correcting)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to start parity check: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to start parity check: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Parity check started successfully",
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleParityCheckStop(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Info("API: Stopping parity check")

        arrayCtrl := controllers.NewArrayController(s.ctx)
        err := arrayCtrl.StopParityCheck()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to stop parity check: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to stop parity check: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Parity check stopped successfully",
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleParityCheckPause(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Info("API: Pausing parity check")

        arrayCtrl := controllers.NewArrayController(s.ctx)
        err := arrayCtrl.PauseParityCheck()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to pause parity check: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to pause parity check: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Parity check paused successfully",
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleParityCheckResume(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Info("API: Resuming parity check")

        arrayCtrl := controllers.NewArrayController(s.ctx)
        err := arrayCtrl.ResumeParityCheck()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to resume parity check: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to resume parity check: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Parity check resumed successfully",
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleParityCheckHistory(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Debug("API: Getting parity check history")

        parityCollector := collectors.NewParityCollector()
        history, err := parityCollector.GetParityHistory()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("API: Failed to get parity check history: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to get parity check history: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, history)</span>
}

// Configuration handlers
func (s *Server) handleShareConfig(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        shareName := vars["name"]
        logger.Debug("API: Getting share config for %s", shareName)

        // Validate share name to prevent path traversal attacks
        if err := lib.ValidateShareName(shareName); err != nil </span><span class="cov0" title="0">{
                logger.Error("API: Invalid share name: %v", err)
                respondJSON(w, http.StatusBadRequest, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Invalid share name: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">configCollector := collectors.NewConfigCollector()
        config, err := configCollector.GetShareConfig(shareName)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to get share config: %v", err)
                respondJSON(w, http.StatusNotFound, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to get share config: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, config)</span>
}

func (s *Server) handleNetworkConfig(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        interfaceName := vars["interface"]
        logger.Debug("API: Getting network config for %s", interfaceName)

        configCollector := collectors.NewConfigCollector()
        config, err := configCollector.GetNetworkConfig(interfaceName)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to get network config: %v", err)
                respondJSON(w, http.StatusNotFound, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to get network config: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, config)</span>
}

func (s *Server) handleSystemSettings(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Debug("API: Getting system settings")

        configCollector := collectors.NewConfigCollector()
        settings, err := configCollector.GetSystemSettings()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to get system settings: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to get system settings: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, settings)</span>
}

func (s *Server) handleDockerSettings(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Debug("API: Getting Docker settings")

        configCollector := collectors.NewConfigCollector()
        settings, err := configCollector.GetDockerSettings()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("API: Failed to get Docker settings: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to get Docker settings: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, settings)</span>
}

func (s *Server) handleVMSettings(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Debug("API: Getting VM settings")

        configCollector := collectors.NewConfigCollector()
        settings, err := configCollector.GetVMSettings()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("API: Failed to get VM settings: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to get VM settings: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, settings)</span>
}

func (s *Server) handleDiskSettings(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Debug("API: Getting disk settings")

        configCollector := collectors.NewConfigCollector()
        settings, err := configCollector.GetDiskSettings()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to get disk settings: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to get disk settings: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, settings)</span>
}

func (s *Server) handleUpdateShareConfig(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        shareName := vars["name"]
        logger.Info("API: Updating share config for %s", shareName)

        // Validate share name to prevent path traversal attacks
        if err := lib.ValidateShareName(shareName); err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Invalid share name: %v", err)
                respondJSON(w, http.StatusBadRequest, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Invalid share name: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">var config dto.ShareConfig
        if err := json.NewDecoder(r.Body).Decode(&amp;config); err != nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusBadRequest, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Invalid request body: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        // Ensure name matches URL parameter
        <span class="cov0" title="0">config.Name = shareName

        configCollector := collectors.NewConfigCollector()
        if err := configCollector.UpdateShareConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                logger.Error("API: Failed to update share config: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to update share config: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "Share config updated successfully",
                Timestamp: time.Now(),
        })</span>
}

func (s *Server) handleUpdateSystemSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger.Info("API: Updating system settings")

        var settings dto.SystemSettings
        if err := json.NewDecoder(r.Body).Decode(&amp;settings); err != nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusBadRequest, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Invalid request body: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">configCollector := collectors.NewConfigCollector()
        if err := configCollector.UpdateSystemSettings(&amp;settings); err != nil </span><span class="cov0" title="0">{
                logger.Error("API: Failed to update system settings: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to update system settings: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, dto.Response{
                Success:   true,
                Message:   "System settings updated successfully",
                Timestamp: time.Now(),
        })</span>
}

// handleUserScripts returns a list of all available user scripts
func (s *Server) handleUserScripts(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        scripts, err := controllers.ListUserScripts()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("API: Failed to list user scripts: %v", err)
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Failed to list user scripts: %v", err),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, scripts)</span>
}

// handleUserScriptExecute executes a user script
func (s *Server) handleUserScriptExecute(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        scriptName := vars["name"]

        // Parse request body for execution options
        var req dto.UserScriptExecuteRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                // Use defaults if no body provided
                req.Background = true
                req.Wait = false
        }</span>

        // Execute the script
        <span class="cov8" title="1">response, err := controllers.ExecuteUserScript(scriptName, req.Background, req.Wait)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("API: Failed to execute user script %s: %v", scriptName, err)
                respondJSON(w, http.StatusInternalServerError, response)
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, response)</span>
}

// Hardware endpoints

func (s *Server) handleHardwareFull(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        hardware := s.hardwareCache
        s.cacheMutex.RUnlock()

        if hardware == nil </span><span class="cov8" title="1">{
                hardware = &amp;dto.HardwareInfo{
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, hardware)</span>
}

func (s *Server) handleHardwareBIOS(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        hardware := s.hardwareCache
        s.cacheMutex.RUnlock()

        if hardware == nil || hardware.BIOS == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusNotFound, map[string]string{"error": "BIOS information not available"})
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, hardware.BIOS)</span>
}

func (s *Server) handleHardwareBaseboard(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        hardware := s.hardwareCache
        s.cacheMutex.RUnlock()

        if hardware == nil || hardware.Baseboard == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusNotFound, map[string]string{"error": "Baseboard information not available"})
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, hardware.Baseboard)</span>
}

func (s *Server) handleHardwareCPU(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        hardware := s.hardwareCache
        s.cacheMutex.RUnlock()

        if hardware == nil || hardware.CPU == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusNotFound, map[string]string{"error": "CPU hardware information not available"})
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, hardware.CPU)</span>
}

func (s *Server) handleHardwareCache(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        hardware := s.hardwareCache
        s.cacheMutex.RUnlock()

        if hardware == nil || len(hardware.Cache) == 0 </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusNotFound, map[string]string{"error": "CPU cache information not available"})
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, hardware.Cache)</span>
}

func (s *Server) handleHardwareMemoryArray(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        hardware := s.hardwareCache
        s.cacheMutex.RUnlock()

        if hardware == nil || hardware.MemoryArray == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusNotFound, map[string]string{"error": "Memory array information not available"})
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, hardware.MemoryArray)</span>
}

func (s *Server) handleHardwareMemoryDevices(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        hardware := s.hardwareCache
        s.cacheMutex.RUnlock()

        if hardware == nil || len(hardware.MemoryDevices) == 0 </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusNotFound, map[string]string{"error": "Memory device information not available"})
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, hardware.MemoryDevices)</span>
}

func (s *Server) handleRegistration(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        logger.Debug("API: Getting registration information")

        s.cacheMutex.RLock()
        registration := s.registrationCache
        s.cacheMutex.RUnlock()

        if registration == nil </span><span class="cov8" title="1">{
                registration = &amp;dto.Registration{
                        Type:      "unknown",
                        State:     "invalid",
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, registration)</span>
}

func (s *Server) handleLogs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger.Debug("API: Getting logs")

        // Get query parameters
        path := r.URL.Query().Get("path")
        linesParam := r.URL.Query().Get("lines")
        startParam := r.URL.Query().Get("start")

        // If no path specified, list all available logs
        if path == "" </span><span class="cov8" title="1">{
                logs := s.listLogFiles()
                respondJSON(w, http.StatusOK, map[string]interface{}{"logs": logs})
                return
        }</span>

        // Get log content with optional pagination
        <span class="cov0" title="0">content, err := s.getLogContent(path, linesParam, startParam)
        if err != nil </span><span class="cov0" title="0">{
                respondJSON(w, http.StatusInternalServerError, map[string]string{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, content)</span>
}

// handleLogFile retrieves a specific log file by filename
// This provides a cleaner REST endpoint for accessing known log files
func (s *Server) handleLogFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        filename := vars["filename"]
        logger.Debug("API: Getting log file: %s", filename)

        // Validate filename to prevent directory traversal (CWE-22)
        if !lib.ValidateLogFilename(filename) </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusBadRequest, dto.Response{
                        Success:   false,
                        Message:   "Invalid filename",
                        Timestamp: time.Now(),
                })
                return
        }</span>

        // Find the log file in our known log paths
        <span class="cov8" title="1">logs := s.listLogFiles()
        var foundPath string
        for _, log := range logs </span><span class="cov8" title="1">{
                // Match by filename (base name) or full name (for plugin logs)
                if log.Name == filename || filepath.Base(log.Path) == filename </span><span class="cov0" title="0">{
                        foundPath = log.Path
                        break</span>
                }
        }

        <span class="cov8" title="1">if foundPath == "" </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusNotFound, dto.Response{
                        Success:   false,
                        Message:   fmt.Sprintf("Log file not found: %s", filename),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        // Get optional query parameters for pagination
        <span class="cov0" title="0">linesParam := r.URL.Query().Get("lines")
        startParam := r.URL.Query().Get("start")

        // Get log content
        content, err := s.getLogContent(foundPath, linesParam, startParam)
        if err != nil </span><span class="cov0" title="0">{
                respondJSON(w, http.StatusInternalServerError, dto.Response{
                        Success:   false,
                        Message:   err.Error(),
                        Timestamp: time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, content)</span>
}

// Helper function to respond with JSON
func respondJSON(w http.ResponseWriter, status int, payload interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(payload); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to encode JSON response: %v", err)
        }</span>
}

// Helper function to respond with error
func respondWithError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        respondJSON(w, status, map[string]string{"error": message})
}</span>

// handleNotifications returns all notifications with overview
func (s *Server) handleNotifications(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        notificationList := s.notificationsCache
        s.cacheMutex.RUnlock()

        if notificationList == nil </span><span class="cov8" title="1">{
                notificationList = &amp;dto.NotificationList{
                        Overview: dto.NotificationOverview{
                                Unread:  dto.NotificationCounts{},
                                Archive: dto.NotificationCounts{},
                        },
                        Notifications: []dto.Notification{},
                        Timestamp:     time.Now(),
                }
        }</span>

        // Filter by importance if specified
        <span class="cov8" title="1">importance := r.URL.Query().Get("importance")
        if importance != "" </span><span class="cov0" title="0">{
                filtered := []dto.Notification{}
                for _, n := range notificationList.Notifications </span><span class="cov0" title="0">{
                        if n.Importance == importance </span><span class="cov0" title="0">{
                                filtered = append(filtered, n)
                        }</span>
                }
                <span class="cov0" title="0">notificationList.Notifications = filtered</span>
        }

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, notificationList)</span>
}

// handleNotificationsUnread returns only unread notifications
func (s *Server) handleNotificationsUnread(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        notificationList := s.notificationsCache
        s.cacheMutex.RUnlock()

        if notificationList == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusOK, map[string]interface{}{
                        "notifications": []dto.Notification{},
                        "count":         0,
                })
                return
        }</span>

        <span class="cov0" title="0">unread := []dto.Notification{}
        for _, n := range notificationList.Notifications </span><span class="cov0" title="0">{
                if n.Type == "unread" </span><span class="cov0" title="0">{
                        unread = append(unread, n)
                }</span>
        }

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]interface{}{
                "notifications": unread,
                "count":         len(unread),
        })</span>
}

// handleNotificationsArchive returns only archived notifications
func (s *Server) handleNotificationsArchive(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        notificationList := s.notificationsCache
        s.cacheMutex.RUnlock()

        if notificationList == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusOK, map[string]interface{}{
                        "notifications": []dto.Notification{},
                        "count":         0,
                })
                return
        }</span>

        <span class="cov0" title="0">archived := []dto.Notification{}
        for _, n := range notificationList.Notifications </span><span class="cov0" title="0">{
                if n.Type == "archive" </span><span class="cov0" title="0">{
                        archived = append(archived, n)
                }</span>
        }

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]interface{}{
                "notifications": archived,
                "count":         len(archived),
        })</span>
}

// handleNotificationsOverview returns only the overview counts
func (s *Server) handleNotificationsOverview(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        notificationList := s.notificationsCache
        s.cacheMutex.RUnlock()

        if notificationList == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusOK, dto.NotificationOverview{
                        Unread:  dto.NotificationCounts{},
                        Archive: dto.NotificationCounts{},
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, notificationList.Overview)</span>
}

// handleNotificationByID returns a specific notification by ID
func (s *Server) handleNotificationByID(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id := vars["id"]

        s.cacheMutex.RLock()
        notificationList := s.notificationsCache
        s.cacheMutex.RUnlock()

        if notificationList == nil </span><span class="cov8" title="1">{
                respondWithError(w, http.StatusNotFound, "Notification not found")
                return
        }</span>

        <span class="cov0" title="0">for _, n := range notificationList.Notifications </span><span class="cov0" title="0">{
                if n.ID == id </span><span class="cov0" title="0">{
                        respondJSON(w, http.StatusOK, n)
                        return
                }</span>
        }

        <span class="cov0" title="0">respondWithError(w, http.StatusNotFound, "Notification not found")</span>
}

// handleCreateNotification creates a new notification
func (s *Server) handleCreateNotification(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req struct {
                Title       string `json:"title"`
                Subject     string `json:"subject"`
                Description string `json:"description"`
                Importance  string `json:"importance"`
                Link        string `json:"link"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                respondWithError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov8" title="1">if req.Title == "" </span><span class="cov8" title="1">{
                respondWithError(w, http.StatusBadRequest, "Title is required")
                return
        }</span>

        <span class="cov0" title="0">if req.Importance == "" </span><span class="cov0" title="0">{
                req.Importance = "info"
        }</span>

        <span class="cov0" title="0">if err := controllers.CreateNotification(req.Title, req.Subject, req.Description, req.Importance, req.Link); err != nil </span><span class="cov0" title="0">{
                respondWithError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusCreated, map[string]string{"message": "Notification created successfully"})</span>
}

// handleArchiveNotification archives a specific notification
func (s *Server) handleArchiveNotification(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id := vars["id"]

        if err := controllers.ArchiveNotification(id); err != nil </span><span class="cov8" title="1">{
                respondWithError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{"message": "Notification archived successfully"})</span>
}

// handleUnarchiveNotification unarchives a specific notification
func (s *Server) handleUnarchiveNotification(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id := vars["id"]

        if err := controllers.UnarchiveNotification(id); err != nil </span><span class="cov8" title="1">{
                respondWithError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{"message": "Notification unarchived successfully"})</span>
}

// handleDeleteNotification deletes a specific notification
func (s *Server) handleDeleteNotification(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        id := vars["id"]

        // Check if notification is in archive
        isArchived := r.URL.Query().Get("archived") == "true"

        if err := controllers.DeleteNotification(id, isArchived); err != nil </span><span class="cov8" title="1">{
                respondWithError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{"message": "Notification deleted successfully"})</span>
}

// handleArchiveAllNotifications archives all unread notifications
func (s *Server) handleArchiveAllNotifications(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        if err := controllers.ArchiveAllNotifications(); err != nil </span><span class="cov8" title="1">{
                respondWithError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]string{"message": "All notifications archived successfully"})</span>
}

// handleUnassignedDevices returns all unassigned devices and remote shares
func (s *Server) handleUnassignedDevices(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        defer s.cacheMutex.RUnlock()

        if s.unassignedCache == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusOK, map[string]interface{}{
                        "devices":       []interface{}{},
                        "remote_shares": []interface{}{},
                        "timestamp":     time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, s.unassignedCache)</span>
}

// handleUnassignedDevicesList returns only unassigned devices (no remote shares)
func (s *Server) handleUnassignedDevicesList(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        defer s.cacheMutex.RUnlock()

        if s.unassignedCache == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusOK, map[string]interface{}{
                        "devices":   []interface{}{},
                        "timestamp": time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]interface{}{
                "devices":   s.unassignedCache.Devices,
                "timestamp": s.unassignedCache.Timestamp,
        })</span>
}

// handleUnassignedRemoteShares returns only remote shares (no devices)
func (s *Server) handleUnassignedRemoteShares(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        defer s.cacheMutex.RUnlock()

        if s.unassignedCache == nil </span><span class="cov8" title="1">{
                respondJSON(w, http.StatusOK, map[string]interface{}{
                        "remote_shares": []interface{}{},
                        "timestamp":     time.Now(),
                })
                return
        }</span>

        <span class="cov0" title="0">respondJSON(w, http.StatusOK, map[string]interface{}{
                "remote_shares": s.unassignedCache.RemoteShares,
                "timestamp":     s.unassignedCache.Timestamp,
        })</span>
}

// ============================================================================
// ZFS Handlers
// ============================================================================

// handleZFSPools returns all ZFS pools
func (s *Server) handleZFSPools(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        pools := s.zfsPoolsCache
        s.cacheMutex.RUnlock()

        if pools == nil </span><span class="cov8" title="1">{
                pools = []dto.ZFSPool{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, pools)</span>
}

// handleZFSPool returns a specific ZFS pool by name
func (s *Server) handleZFSPool(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        poolName := vars["name"]

        s.cacheMutex.RLock()
        pools := s.zfsPoolsCache
        s.cacheMutex.RUnlock()

        // Find pool by name
        for _, pool := range pools </span><span class="cov0" title="0">{
                if pool.Name == poolName </span><span class="cov0" title="0">{
                        respondJSON(w, http.StatusOK, pool)
                        return
                }</span>
        }

        // Pool not found
        <span class="cov8" title="1">respondJSON(w, http.StatusNotFound, dto.Response{
                Success:   false,
                Message:   fmt.Sprintf("ZFS pool not found: %s", poolName),
                Timestamp: time.Now(),
        })</span>
}

// handleZFSDatasets returns all ZFS datasets
func (s *Server) handleZFSDatasets(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        datasets := s.zfsDatasetsCache
        s.cacheMutex.RUnlock()

        if datasets == nil </span><span class="cov8" title="1">{
                datasets = []dto.ZFSDataset{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, datasets)</span>
}

// handleZFSSnapshots returns all ZFS snapshots
func (s *Server) handleZFSSnapshots(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        snapshots := s.zfsSnapshotsCache
        s.cacheMutex.RUnlock()

        if snapshots == nil </span><span class="cov8" title="1">{
                snapshots = []dto.ZFSSnapshot{}
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, snapshots)</span>
}

// handleZFSARC returns ZFS ARC statistics
func (s *Server) handleZFSARC(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        s.cacheMutex.RLock()
        arcStats := s.zfsARCStatsCache
        s.cacheMutex.RUnlock()

        if arcStats == nil </span><span class="cov8" title="1">{
                arcStats = &amp;dto.ZFSARCStats{
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, arcStats)</span>
}

// handleCollectorsStatus returns the status of all collectors including enabled/disabled state
func (s *Server) handleCollectorsStatus(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        // Define all collectors with their names and interval references
        type collectorDef struct {
                name     string
                interval int
        }

        collectors := []collectorDef{
                {"system", s.ctx.Intervals.System},
                {"array", s.ctx.Intervals.Array},
                {"disk", s.ctx.Intervals.Disk},
                {"docker", s.ctx.Intervals.Docker},
                {"vm", s.ctx.Intervals.VM},
                {"ups", s.ctx.Intervals.UPS},
                {"nut", s.ctx.Intervals.NUT},
                {"gpu", s.ctx.Intervals.GPU},
                {"shares", s.ctx.Intervals.Shares},
                {"network", s.ctx.Intervals.Network},
                {"hardware", s.ctx.Intervals.Hardware},
                {"zfs", s.ctx.Intervals.ZFS},
                {"notification", s.ctx.Intervals.Notification},
                {"registration", s.ctx.Intervals.Registration},
                {"unassigned", s.ctx.Intervals.Unassigned},
        }

        var statuses []dto.CollectorStatus
        enabledCount := 0
        disabledCount := 0

        for _, c := range collectors </span><span class="cov8" title="1">{
                enabled := c.interval &gt; 0
                status := "running"
                if !enabled </span><span class="cov8" title="1">{
                        status = "disabled"
                        disabledCount++
                }</span> else<span class="cov0" title="0"> {
                        enabledCount++
                }</span>

                <span class="cov8" title="1">statuses = append(statuses, dto.CollectorStatus{
                        Name:     c.name,
                        Enabled:  enabled,
                        Interval: c.interval,
                        Status:   status,
                })</span>
        }

        <span class="cov8" title="1">respondJSON(w, http.StatusOK, dto.CollectorsStatusResponse{
                Collectors:    statuses,
                Total:         len(collectors),
                EnabledCount:  enabledCount,
                DisabledCount: disabledCount,
                Timestamp:     time.Now(),
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// Common log file locations on Unraid
// Expanded to match Unraid GraphQL API coverage per issue #28
var commonLogPaths = []string{
        // Core system logs
        "/var/log/syslog",
        "/var/log/dmesg",
        "/var/log/messages",
        "/var/log/cron",
        "/var/log/debug",
        "/var/log/btmp",
        "/var/log/lastlog",
        "/var/log/wtmp",

        // Unraid-specific logs
        "/var/log/docker.log",
        "/var/log/libvirt/libvirtd.log",
        "/var/log/unraid-management-agent.log",
        "/var/log/graphql-api.log",
        "/var/log/unraid-api.log",
        "/var/log/recycle.log",
        "/var/log/dhcplog",
        "/var/log/pkgtools/script.log",
        "/var/log/mover.log",

        // UPS logs
        "/var/log/apcupsd.events",
        "/var/log/nohup.out",

        // Web server logs
        "/var/log/nginx/error.log",
        "/var/log/nginx/access.log",

        // VFS and share logs
        "/var/log/vfsd.log",
        "/var/log/smbd.log",
        "/var/log/nfsd.log",

        // Plugin and system logs
        "/var/log/plugins",
        "/var/log/samba/log.smbd",
        "/var/log/samba/log.nmbd",
}

// listLogFiles returns a list of available log files
func (s *Server) listLogFiles() []dto.LogFile <span class="cov8" title="1">{
        var logs []dto.LogFile

        // Check common log paths
        for _, path := range commonLogPaths </span><span class="cov8" title="1">{
                if info, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        logs = append(logs, dto.LogFile{
                                Name:       filepath.Base(path),
                                Path:       path,
                                Size:       info.Size(),
                                ModifiedAt: info.ModTime(),
                        })
                }</span>
        }

        // Check plugin logs
        <span class="cov8" title="1">pluginLogsDir := "/boot/config/plugins"
        if entries, err := os.ReadDir(pluginLogsDir); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.IsDir() </span><span class="cov0" title="0">{
                                logsPath := filepath.Join(pluginLogsDir, entry.Name(), "logs")
                                if logEntries, err := os.ReadDir(logsPath); err == nil </span><span class="cov0" title="0">{
                                        for _, logEntry := range logEntries </span><span class="cov0" title="0">{
                                                if !logEntry.IsDir() &amp;&amp; strings.HasSuffix(logEntry.Name(), ".log") </span><span class="cov0" title="0">{
                                                        fullPath := filepath.Join(logsPath, logEntry.Name())
                                                        if info, err := os.Stat(fullPath); err == nil </span><span class="cov0" title="0">{
                                                                logs = append(logs, dto.LogFile{
                                                                        Name:       fmt.Sprintf("%s/%s", entry.Name(), logEntry.Name()),
                                                                        Path:       fullPath,
                                                                        Size:       info.Size(),
                                                                        ModifiedAt: info.ModTime(),
                                                                })
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return logs</span>
}

// getLogContent retrieves log file content with optional pagination
func (s *Server) getLogContent(path, linesParam, startParam string) (*dto.LogFileContent, error) <span class="cov0" title="0">{
        // Validate path (prevent directory traversal)
        if strings.Contains(path, "..") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid path: directory traversal not allowed")
        }</span>

        // Check if file exists
        <span class="cov0" title="0">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("log file not found: %s", path)
        }</span>

        // Read file
        <span class="cov0" title="0">file, err := os.Open(path) // #nosec G304 - path is validated above
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to open log file %s: %v", path, err)
                return nil, fmt.Errorf("failed to open log file: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to close log file %s: %v", path, err)
                }</span>
        }()

        // Read all lines
        <span class="cov0" title="0">var allLines []string
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                allLines = append(allLines, scanner.Text())
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read log file %s: %v", path, err)
                return nil, fmt.Errorf("failed to read log file: %v", err)
        }</span>

        <span class="cov0" title="0">totalLines := len(allLines)

        // Parse pagination parameters
        var startLine, numLines int
        startSpecified := startParam != ""
        linesSpecified := linesParam != ""

        if startSpecified </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(startParam); err == nil </span><span class="cov0" title="0">{
                        startLine = val
                }</span>
        }
        <span class="cov0" title="0">if linesSpecified </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(linesParam); err == nil </span><span class="cov0" title="0">{
                        numLines = val
                }</span>
        }

        // Default: return all lines if no pagination specified
        <span class="cov0" title="0">if !linesSpecified &amp;&amp; !startSpecified </span><span class="cov0" title="0">{
                return &amp;dto.LogFileContent{
                        Path:          path,
                        Content:       strings.Join(allLines, "\n"),
                        Lines:         allLines,
                        TotalLines:    totalLines,
                        LinesReturned: totalLines,
                        StartLine:     0,
                        EndLine:       totalLines,
                }, nil
        }</span>

        // If only lines specified (no start), return last N lines (tail behavior)
        <span class="cov0" title="0">if linesSpecified &amp;&amp; !startSpecified </span><span class="cov0" title="0">{
                if numLines &gt; totalLines </span><span class="cov0" title="0">{
                        numLines = totalLines
                }</span>
                <span class="cov0" title="0">startLine = totalLines - numLines</span>
        }

        // Validate and adjust range
        <span class="cov0" title="0">if startLine &lt; 0 </span><span class="cov0" title="0">{
                startLine = 0
        }</span>
        <span class="cov0" title="0">if startLine &gt;= totalLines </span><span class="cov0" title="0">{
                return &amp;dto.LogFileContent{
                        Path:          path,
                        Content:       "",
                        Lines:         []string{},
                        TotalLines:    totalLines,
                        LinesReturned: 0,
                        StartLine:     startLine,
                        EndLine:       startLine,
                }, nil
        }</span>

        <span class="cov0" title="0">endLine := startLine + numLines
        if endLine &gt; totalLines </span><span class="cov0" title="0">{
                endLine = totalLines
        }</span>

        <span class="cov0" title="0">selectedLines := allLines[startLine:endLine]

        return &amp;dto.LogFileContent{
                Path:          path,
                Content:       strings.Join(selectedLines, "\n"),
                Lines:         selectedLines,
                TotalLines:    totalLines,
                LinesReturned: len(selectedLines),
                StartLine:     startLine,
                EndLine:       endLine,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "net/http"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

func corsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

func loggingMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                logger.Debug("%s %s", r.Method, r.URL.Path)
                next.ServeHTTP(w, r)
                logger.Debug("Completed in %v", time.Since(start))
        }</span>)
}

func recoveryMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                logger.Error("Panic recovered: %v", err)
                                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                        }</span>
                }()
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/mux"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// Server represents the HTTP API server that handles REST endpoints and WebSocket connections.
// It maintains an in-memory cache of data from collectors and broadcasts updates to WebSocket clients.
type Server struct {
        ctx        *domain.Context
        httpServer *http.Server
        router     *mux.Router
        wsHub      *WSHub
        cancelCtx  context.Context
        cancelFunc context.CancelFunc

        // Cache for latest data from collectors
        cacheMutex         sync.RWMutex
        systemCache        *dto.SystemInfo
        arrayCache         *dto.ArrayStatus
        disksCache         []dto.DiskInfo
        sharesCache        []dto.ShareInfo
        dockerCache        []dto.ContainerInfo
        vmsCache           []dto.VMInfo
        upsCache           *dto.UPSStatus
        gpuCache           []*dto.GPUMetrics
        networkCache       []dto.NetworkInfo
        hardwareCache      *dto.HardwareInfo
        registrationCache  *dto.Registration
        notificationsCache *dto.NotificationList
        unassignedCache    *dto.UnassignedDeviceList
        zfsPoolsCache      []dto.ZFSPool
        zfsDatasetsCache   []dto.ZFSDataset
        zfsSnapshotsCache  []dto.ZFSSnapshot
        zfsARCStatsCache   *dto.ZFSARCStats
        nutCache           *dto.NUTResponse
}

// NewServer creates a new API server instance with the given context.
// It initializes the HTTP router, WebSocket hub, and sets up all API routes.
func NewServer(ctx *domain.Context) *Server <span class="cov8" title="1">{
        cancelCtx, cancelFunc := context.WithCancel(context.Background())
        s := &amp;Server{
                ctx:        ctx,
                router:     mux.NewRouter(),
                wsHub:      NewWSHub(),
                cancelCtx:  cancelCtx,
                cancelFunc: cancelFunc,
        }

        s.setupRoutes()
        return s
}</span>

func (s *Server) setupRoutes() <span class="cov8" title="1">{
        // Apply middleware
        s.router.Use(corsMiddleware)
        s.router.Use(loggingMiddleware)
        s.router.Use(recoveryMiddleware)

        api := s.router.PathPrefix("/api/v1").Subrouter()

        // Health check
        api.HandleFunc("/health", s.handleHealth).Methods("GET")

        // Monitoring endpoints
        api.HandleFunc("/system", s.handleSystem).Methods("GET")
        api.HandleFunc("/array", s.handleArray).Methods("GET")
        api.HandleFunc("/disks", s.handleDisks).Methods("GET")
        api.HandleFunc("/disks/{id}", s.handleDisk).Methods("GET")
        api.HandleFunc("/shares", s.handleShares).Methods("GET")
        api.HandleFunc("/docker", s.handleDockerList).Methods("GET")
        api.HandleFunc("/docker/{id}", s.handleDockerInfo).Methods("GET")
        api.HandleFunc("/vm", s.handleVMList).Methods("GET")
        api.HandleFunc("/vm/{id}", s.handleVMInfo).Methods("GET")
        api.HandleFunc("/ups", s.handleUPS).Methods("GET")
        api.HandleFunc("/nut", s.handleNUT).Methods("GET")
        api.HandleFunc("/gpu", s.handleGPU).Methods("GET")

        // System control endpoints
        api.HandleFunc("/system/reboot", s.handleSystemReboot).Methods("POST")
        api.HandleFunc("/system/shutdown", s.handleSystemShutdown).Methods("POST")
        api.HandleFunc("/network", s.handleNetwork).Methods("GET")

        // ZFS endpoints
        api.HandleFunc("/zfs/pools", s.handleZFSPools).Methods("GET")
        api.HandleFunc("/zfs/pools/{name}", s.handleZFSPool).Methods("GET")
        api.HandleFunc("/zfs/datasets", s.handleZFSDatasets).Methods("GET")
        api.HandleFunc("/zfs/snapshots", s.handleZFSSnapshots).Methods("GET")
        api.HandleFunc("/zfs/arc", s.handleZFSARC).Methods("GET")

        // Hardware endpoints
        api.HandleFunc("/hardware/full", s.handleHardwareFull).Methods("GET")
        api.HandleFunc("/hardware/bios", s.handleHardwareBIOS).Methods("GET")
        api.HandleFunc("/hardware/baseboard", s.handleHardwareBaseboard).Methods("GET")
        api.HandleFunc("/hardware/cpu", s.handleHardwareCPU).Methods("GET")
        api.HandleFunc("/hardware/cache", s.handleHardwareCache).Methods("GET")
        api.HandleFunc("/hardware/memory-array", s.handleHardwareMemoryArray).Methods("GET")
        api.HandleFunc("/hardware/memory-devices", s.handleHardwareMemoryDevices).Methods("GET")

        // Control endpoints
        api.HandleFunc("/docker/{id}/start", s.handleDockerStart).Methods("POST")
        api.HandleFunc("/docker/{id}/stop", s.handleDockerStop).Methods("POST")
        api.HandleFunc("/docker/{id}/restart", s.handleDockerRestart).Methods("POST")
        api.HandleFunc("/docker/{id}/pause", s.handleDockerPause).Methods("POST")
        api.HandleFunc("/docker/{id}/unpause", s.handleDockerUnpause).Methods("POST")

        api.HandleFunc("/vm/{name}/start", s.handleVMStart).Methods("POST")
        api.HandleFunc("/vm/{name}/stop", s.handleVMStop).Methods("POST")
        api.HandleFunc("/vm/{name}/restart", s.handleVMRestart).Methods("POST")
        api.HandleFunc("/vm/{name}/pause", s.handleVMPause).Methods("POST")
        api.HandleFunc("/vm/{name}/resume", s.handleVMResume).Methods("POST")
        api.HandleFunc("/vm/{name}/hibernate", s.handleVMHibernate).Methods("POST")
        api.HandleFunc("/vm/{name}/force-stop", s.handleVMForceStop).Methods("POST")

        // Array control endpoints
        api.HandleFunc("/array/start", s.handleArrayStart).Methods("POST")
        api.HandleFunc("/array/stop", s.handleArrayStop).Methods("POST")
        api.HandleFunc("/array/parity-check/start", s.handleParityCheckStart).Methods("POST")
        api.HandleFunc("/array/parity-check/stop", s.handleParityCheckStop).Methods("POST")
        api.HandleFunc("/array/parity-check/pause", s.handleParityCheckPause).Methods("POST")
        api.HandleFunc("/array/parity-check/resume", s.handleParityCheckResume).Methods("POST")
        api.HandleFunc("/array/parity-check/history", s.handleParityCheckHistory).Methods("GET")

        // Configuration endpoints (read-only)
        api.HandleFunc("/shares/{name}/config", s.handleShareConfig).Methods("GET")
        api.HandleFunc("/network/{interface}/config", s.handleNetworkConfig).Methods("GET")
        api.HandleFunc("/settings/system", s.handleSystemSettings).Methods("GET")
        api.HandleFunc("/settings/docker", s.handleDockerSettings).Methods("GET")
        api.HandleFunc("/settings/vm", s.handleVMSettings).Methods("GET")
        api.HandleFunc("/settings/disks", s.handleDiskSettings).Methods("GET")

        // Configuration endpoints (write)
        api.HandleFunc("/shares/{name}/config", s.handleUpdateShareConfig).Methods("POST")
        api.HandleFunc("/settings/system", s.handleUpdateSystemSettings).Methods("POST")

        // User Scripts endpoints
        api.HandleFunc("/user-scripts", s.handleUserScripts).Methods("GET")
        api.HandleFunc("/user-scripts/{name}/execute", s.handleUserScriptExecute).Methods("POST")

        // Registration/License endpoint
        api.HandleFunc("/registration", s.handleRegistration).Methods("GET")

        // Log file endpoints
        api.HandleFunc("/logs", s.handleLogs).Methods("GET")
        api.HandleFunc("/logs/{filename}", s.handleLogFile).Methods("GET")

        // Notification endpoints (monitoring)
        api.HandleFunc("/notifications", s.handleNotifications).Methods("GET")
        api.HandleFunc("/notifications/unread", s.handleNotificationsUnread).Methods("GET")
        api.HandleFunc("/notifications/archive", s.handleNotificationsArchive).Methods("GET")
        api.HandleFunc("/notifications/overview", s.handleNotificationsOverview).Methods("GET")
        api.HandleFunc("/notifications/{id}", s.handleNotificationByID).Methods("GET")

        // Notification endpoints (control)
        api.HandleFunc("/notifications", s.handleCreateNotification).Methods("POST")
        api.HandleFunc("/notifications/{id}/archive", s.handleArchiveNotification).Methods("POST")
        api.HandleFunc("/notifications/{id}/unarchive", s.handleUnarchiveNotification).Methods("POST")
        api.HandleFunc("/notifications/{id}", s.handleDeleteNotification).Methods("DELETE")
        api.HandleFunc("/notifications/archive/all", s.handleArchiveAllNotifications).Methods("POST")

        // Unassigned Devices endpoints (monitoring)
        api.HandleFunc("/unassigned", s.handleUnassignedDevices).Methods("GET")
        api.HandleFunc("/unassigned/devices", s.handleUnassignedDevicesList).Methods("GET")
        api.HandleFunc("/unassigned/remote-shares", s.handleUnassignedRemoteShares).Methods("GET")

        // Collectors status endpoint
        api.HandleFunc("/collectors/status", s.handleCollectorsStatus).Methods("GET")

        // WebSocket endpoint
        api.HandleFunc("/ws", s.handleWebSocket)
}</span>

// StartSubscriptions initializes event subscriptions and WebSocket hub
// This should be called before collectors start to avoid race conditions
func (s *Server) StartSubscriptions() <span class="cov0" title="0">{
        logger.Info("Starting API server subscriptions...")

        // Start WebSocket hub
        go s.wsHub.Run(s.cancelCtx)

        // Subscribe to events and update cache
        go s.subscribeToEvents(s.cancelCtx)

        // Broadcast events to WebSocket clients
        go s.broadcastEvents(s.cancelCtx)

        logger.Info("API server subscriptions started")
}</span>

// StartHTTP starts the HTTP server
func (s *Server) StartHTTP() error <span class="cov0" title="0">{
        s.httpServer = &amp;http.Server{
                Addr:         fmt.Sprintf(":%d", s.ctx.Port),
                Handler:      s.router,
                ReadTimeout:  30 * time.Second,
                WriteTimeout: 30 * time.Second,
        }

        logger.Info("HTTP server listening on %s", s.httpServer.Addr)
        return s.httpServer.ListenAndServe()
}</span>

// Start starts both subscriptions and HTTP server (legacy method)
func (s *Server) Start() error <span class="cov0" title="0">{
        s.StartSubscriptions()
        return s.StartHTTP()
}</span>

// Stop gracefully shuts down the API server.
// It cancels all background goroutines and shuts down the HTTP server with a 5-second timeout.
func (s *Server) Stop() <span class="cov0" title="0">{
        // Cancel all background goroutines
        s.cancelFunc()

        // Shutdown HTTP server with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := s.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server shutdown error: %v", err)
        }</span>
}

func (s *Server) subscribeToEvents(ctx context.Context) <span class="cov0" title="0">{
        // Subscribe to specific events to update cache
        logger.Info("Cache: Subscribing to event topics...")
        ch := s.ctx.Hub.Sub(
                "system_update",
                "array_status_update",
                "disk_list_update",
                "share_list_update",
                "container_list_update",
                "vm_list_update",
                "ups_status_update",
                "nut_status_update",
                "gpu_metrics_update",
                "network_list_update",
                "hardware_update",
                "registration_update",
                "notifications_update",
                "unassigned_devices_update",
                "zfs_pools_update",
                "zfs_datasets_update",
                "zfs_snapshots_update",
                "zfs_arc_stats_update",
        )
        logger.Info("Cache: Subscription ready, waiting for events...")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Cache subscription stopping due to context cancellation")
                        s.ctx.Hub.Unsub(ch)
                        return</span>
                case msg := &lt;-ch:<span class="cov0" title="0">
                        // Update cache based on message type
                        switch v := msg.(type) </span>{
                        case *dto.SystemInfo:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.systemCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated system info - CPU: %.1f%%, RAM: %.1f%%", v.CPUUsage, v.RAMUsage)</span>
                        case *dto.ArrayStatus:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.arrayCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated array status - state=%s, disks=%d", v.State, v.NumDisks)</span>
                        case []dto.DiskInfo:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.disksCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated disk list - count=%d", len(v))</span>
                        case []dto.ShareInfo:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.sharesCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated share list - count=%d", len(v))</span>
                        case []*dto.ContainerInfo:<span class="cov0" title="0">
                                // Convert pointer slice to value slice for cache
                                containers := make([]dto.ContainerInfo, len(v))
                                for i, c := range v </span><span class="cov0" title="0">{
                                        containers[i] = *c
                                }</span>
                                <span class="cov0" title="0">s.cacheMutex.Lock()
                                s.dockerCache = containers
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated container list - count=%d", len(v))</span>
                        case []*dto.VMInfo:<span class="cov0" title="0">
                                // Convert pointer slice to value slice for cache
                                vms := make([]dto.VMInfo, len(v))
                                for i, vm := range v </span><span class="cov0" title="0">{
                                        vms[i] = *vm
                                }</span>
                                <span class="cov0" title="0">s.cacheMutex.Lock()
                                s.vmsCache = vms
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated VM list - count=%d", len(v))</span>
                        case *dto.UPSStatus:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.upsCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated UPS status - %s", v.Status)</span>
                        case *dto.NUTResponse:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.nutCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated NUT status - installed=%t, running=%t", v.Installed, v.Running)</span>
                        case []*dto.GPUMetrics:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.gpuCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated GPU metrics - count=%d", len(v))</span>
                        case []dto.NetworkInfo:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.networkCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated network list - count=%d", len(v))</span>
                        case *dto.HardwareInfo:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.hardwareCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated hardware info - BIOS: %s, Baseboard: %s",
                                        func() string </span><span class="cov0" title="0">{
                                                if v.BIOS != nil </span><span class="cov0" title="0">{
                                                        return v.BIOS.Vendor
                                                }</span>
                                                <span class="cov0" title="0">return "N/A"</span>
                                        }(),
                                        func() string <span class="cov0" title="0">{
                                                if v.Baseboard != nil </span><span class="cov0" title="0">{
                                                        return v.Baseboard.Manufacturer
                                                }</span>
                                                <span class="cov0" title="0">return "N/A"</span>
                                        }())
                        case *dto.Registration:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.registrationCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated registration info - type=%s, state=%s", v.Type, v.State)</span>
                        case *dto.NotificationList:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.notificationsCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated notifications - unread=%d, archived=%d",
                                        v.Overview.Unread.Total, v.Overview.Archive.Total)</span>
                        case *dto.UnassignedDeviceList:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.unassignedCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated unassigned devices - devices=%d, remote_shares=%d",
                                        len(v.Devices), len(v.RemoteShares))</span>
                        case []dto.ZFSPool:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.zfsPoolsCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated ZFS pools - count=%d", len(v))</span>
                        case []dto.ZFSDataset:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.zfsDatasetsCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated ZFS datasets - count=%d", len(v))</span>
                        case []dto.ZFSSnapshot:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.zfsSnapshotsCache = v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated ZFS snapshots - count=%d", len(v))</span>
                        case dto.ZFSARCStats:<span class="cov0" title="0">
                                s.cacheMutex.Lock()
                                s.zfsARCStatsCache = &amp;v
                                s.cacheMutex.Unlock()
                                logger.Debug("Cache: Updated ZFS ARC stats - hit_ratio=%.2f%%", v.HitRatioPct)</span>
                        default:<span class="cov0" title="0">
                                logger.Warning("Cache: Received unknown event type: %T", msg)</span>
                        }
                }
        }
}

func (s *Server) broadcastEvents(ctx context.Context) <span class="cov0" title="0">{
        // Subscribe to all event topics for WebSocket broadcasting
        ch := s.ctx.Hub.Sub(
                "system_update",
                "array_status_update",
                "disk_list_update",
                "share_list_update",
                "container_list_update",
                "vm_list_update",
                "ups_status_update",
                "nut_status_update",
                "gpu_metrics_update",
                "network_list_update",
                "hardware_update",
        )

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("WebSocket broadcast stopping due to context cancellation")
                        s.ctx.Hub.Unsub(ch)
                        return</span>
                case msg := &lt;-ch:<span class="cov0" title="0">
                        s.wsHub.Broadcast(msg)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "context"
        "net/http"
        "sync"
        "time"

        "github.com/gorilla/websocket"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

var upgrader = websocket.Upgrader{
        CheckOrigin: func(_ *http.Request) bool <span class="cov0" title="0">{
                return true // Allow all origins
        }</span>,
}

// WSHub manages WebSocket client connections and broadcasts messages to all connected clients.
// It handles client registration, unregistration, and message broadcasting in a thread-safe manner.
type WSHub struct {
        clients    map[*WSClient]bool
        broadcast  chan interface{}
        register   chan *WSClient
        unregister chan *WSClient
        mu         sync.RWMutex
}

// WSClient represents a single WebSocket client connection.
// It maintains the connection to the hub, the WebSocket connection, and a send channel for outgoing messages.
type WSClient struct {
        hub  *WSHub
        conn *websocket.Conn
        send chan dto.WSEvent
}

// NewWSHub creates and initializes a new WebSocket hub.
// The hub is ready to accept client connections and broadcast messages.
func NewWSHub() *WSHub <span class="cov8" title="1">{
        return &amp;WSHub{
                clients:    make(map[*WSClient]bool),
                broadcast:  make(chan interface{}, constants.WSBufferSize),
                register:   make(chan *WSClient),
                unregister: make(chan *WSClient),
        }
}</span>

// Run starts the WebSocket hub's main event loop.
// It handles client registration, unregistration, and message broadcasting until the context is cancelled.
func (h *WSHub) Run(ctx context.Context) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        logger.Info("WebSocket hub stopping due to context cancellation")
                        // Close all client connections
                        h.mu.Lock()
                        for client := range h.clients </span><span class="cov8" title="1">{
                                close(client.send)
                                delete(h.clients, client)
                        }</span>
                        <span class="cov8" title="1">h.mu.Unlock()
                        return</span>

                case client := &lt;-h.register:<span class="cov8" title="1">
                        h.mu.Lock()
                        h.clients[client] = true
                        h.mu.Unlock()
                        logger.Debug("WebSocket client connected")</span>

                case client := &lt;-h.unregister:<span class="cov8" title="1">
                        h.mu.Lock()
                        if _, ok := h.clients[client]; ok </span><span class="cov8" title="1">{
                                delete(h.clients, client)
                                close(client.send)
                                logger.Debug("WebSocket client disconnected")
                        }</span>
                        <span class="cov8" title="1">h.mu.Unlock()</span>

                case message := &lt;-h.broadcast:<span class="cov8" title="1">
                        h.mu.RLock()
                        event := dto.WSEvent{
                                Event:     "update",
                                Timestamp: time.Now(),
                                Data:      message,
                        }
                        for client := range h.clients </span><span class="cov8" title="1">{
                                select </span>{
                                case client.send &lt;- event:<span class="cov8" title="1"></span>
                                default:<span class="cov0" title="0">
                                        close(client.send)
                                        delete(h.clients, client)</span>
                                }
                        }
                        <span class="cov8" title="1">h.mu.RUnlock()</span>
                }
        }
}

// Broadcast sends a message to all connected WebSocket clients.
// The message is wrapped in a WSEvent and sent asynchronously to each client.
func (h *WSHub) Broadcast(message interface{}) <span class="cov8" title="1">{
        h.broadcast &lt;- message
}</span>

func (s *Server) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("WebSocket upgrade error: %v", err)
                return
        }</span>

        <span class="cov0" title="0">client := &amp;WSClient{
                hub:  s.wsHub,
                conn: conn,
                send: make(chan dto.WSEvent, constants.WSBufferSize),
        }

        client.hub.register &lt;- client

        go client.writePump()
        go client.readPump()</span>
}

func (c *WSClient) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Duration(constants.WSPingInterval) * time.Second)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing WebSocket connection in writePump: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case event, ok := &lt;-c.send:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                // Channel closed, send close message
                                if err := c.conn.WriteMessage(websocket.CloseMessage, []byte{}); err != nil </span><span class="cov0" title="0">{
                                        logger.Debug("Error writing close message: %v", err)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">if err := c.conn.WriteJSON(event); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

func (c *WSClient) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.hub.unregister &lt;- c
                if err := c.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing WebSocket connection in readPump: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">if err := c.conn.SetReadDeadline(time.Now().Add(60 * time.Second)); err != nil </span><span class="cov0" title="0">{
                logger.Warning("Error setting initial read deadline: %v", err)
                return
        }</span>
        <span class="cov0" title="0">c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                if err := c.conn.SetReadDeadline(time.Now().Add(60 * time.Second)); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error setting read deadline in pong handler: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, _, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package collectors provides data collection services for Unraid system resources.
package collectors

import (
        "context"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
        "gopkg.in/ini.v1"
)

// ArrayCollector collects Unraid array status information including state, parity status, and disk assignments.
// It publishes array status updates to the event bus at regular intervals.
type ArrayCollector struct {
        ctx *domain.Context
}

// NewArrayCollector creates a new array status collector with the given context.
func NewArrayCollector(ctx *domain.Context) *ArrayCollector <span class="cov8" title="1">{
        return &amp;ArrayCollector{ctx: ctx}
}</span>

// Start begins the array collector's periodic data collection.
// It runs in a goroutine and publishes array status updates at the specified interval until the context is cancelled.
func (c *ArrayCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting array collector (interval: %v)", interval)

        // Run once immediately with panic recovery
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("Array collector PANIC on startup: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">c.Collect()</span>
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Array collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                logger.Error("Array collector PANIC in loop: %v", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.Collect()</span>
                        }()
                }
        }
}

// Collect gathers current array status information and publishes it to the event bus.
// It reads array state from Unraid's mdcmd command and var.ini configuration file.
func (c *ArrayCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting array data...")
        logger.Debug("TRACE: About to call collectArrayStatus()")

        // Collect array status
        arrayStatus, err := c.collectArrayStatus()
        logger.Debug("TRACE: Returned from collectArrayStatus, err=%v", err)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Array: Failed to collect array status: %v", err)
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Array: Successfully collected, publishing event")
        // Publish event
        c.ctx.Hub.Pub(arrayStatus, "array_status_update")
        logger.Debug("Array: Published array_status_update event - state=%s, disks=%d", arrayStatus.State, arrayStatus.NumDisks)</span>
}

func (c *ArrayCollector) collectArrayStatus() (*dto.ArrayStatus, error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("Array: PANIC during collection: %v", r)
                }</span>
        }()

        <span class="cov0" title="0">logger.Debug("Array: Starting collection from %s", constants.VarIni)
        status := &amp;dto.ArrayStatus{
                Timestamp: time.Now(),
        }

        // Parse var.ini for array information
        cfg, err := ini.Load(constants.VarIni)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Array: Failed to load file: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">logger.Debug("Array: File loaded successfully")

        // Get the default section (unnamed section)
        section := cfg.Section("")

        // Array state
        if section.HasKey("mdState") </span><span class="cov0" title="0">{
                status.State = strings.Trim(section.Key("mdState").String(), `"`)
        }</span> else<span class="cov0" title="0"> {
                status.State = "unknown"
        }</span>

        // Number of disks
        <span class="cov0" title="0">if section.HasKey("mdNumDisks") </span><span class="cov0" title="0">{
                numDisks := strings.Trim(section.Key("mdNumDisks").String(), `"`)
                logger.Debug("Array: Found mdNumDisks=%s", numDisks)
                if n, err := strconv.Atoi(numDisks); err == nil </span><span class="cov0" title="0">{
                        status.NumDisks = n
                        logger.Debug("Array: Parsed mdNumDisks=%d", n)
                }</span> else<span class="cov0" title="0"> {
                        logger.Error("Array: Failed to parse mdNumDisks: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Warning("Array: mdNumDisks not found in file")
        }</span>

        // Count parity disks from disks.ini
        <span class="cov0" title="0">status.NumParityDisks = c.countParityDisks()

        // Calculate data disks: total disks minus parity disks
        // mdNumDisks includes all array disks (data + parity), excluding cache/flash
        status.NumDataDisks = status.NumDisks - status.NumParityDisks
        logger.Debug("Array: Calculated NumDataDisks=%d (total=%d - parity=%d)",
                status.NumDataDisks, status.NumDisks, status.NumParityDisks)

        // Parity validity - check if parity sync has completed and has no errors
        // sbSynced contains a timestamp when parity was last synced, or "0" if never synced
        // sbSyncErrs contains the number of errors from the last parity check
        parityValid := false
        if section.HasKey("sbSynced") </span><span class="cov0" title="0">{
                sbSynced := strings.Trim(section.Key("sbSynced").String(), `"`)
                // If sbSynced is a non-zero number (timestamp), parity has been synced
                if sbSynced != "0" &amp;&amp; sbSynced != "" </span><span class="cov0" title="0">{
                        parityValid = true
                }</span>
        }

        // Check for parity errors - if there are any errors, parity is not valid
        <span class="cov0" title="0">if section.HasKey("sbSyncErrs") </span><span class="cov0" title="0">{
                sbSyncErrs := strings.Trim(section.Key("sbSyncErrs").String(), `"`)
                if n, err := strconv.Atoi(sbSyncErrs); err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                        parityValid = false
                }</span>
        }

        // Only mark parity as valid if we have at least one parity disk
        <span class="cov0" title="0">if status.NumParityDisks &gt; 0 </span><span class="cov0" title="0">{
                status.ParityValid = parityValid
        }</span> else<span class="cov0" title="0"> {
                status.ParityValid = false
        }</span>

        // Parity check status - need to check multiple fields to detect state properly
        // Key fields:
        // - mdResyncPos: Current position in parity operation (&gt;0 means operation in progress)
        // - mdResyncDt: Delta time (0 = paused, &gt;0 = running)
        // - mdResyncSize: Total size for calculating progress
        // - sbSyncAction: Type of parity operation (e.g., "check P", "check NOCORRECT")
        <span class="cov0" title="0">var mdResyncPos, mdResyncSize uint64
        var mdResyncDt int64

        if section.HasKey("mdResyncPos") </span><span class="cov0" title="0">{
                posStr := strings.Trim(section.Key("mdResyncPos").String(), `"`)
                if pos, err := strconv.ParseUint(posStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        mdResyncPos = pos
                }</span>
        }

        <span class="cov0" title="0">if section.HasKey("mdResyncSize") </span><span class="cov0" title="0">{
                sizeStr := strings.Trim(section.Key("mdResyncSize").String(), `"`)
                if size, err := strconv.ParseUint(sizeStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        mdResyncSize = size
                }</span>
        }

        <span class="cov0" title="0">if section.HasKey("mdResyncDt") </span><span class="cov0" title="0">{
                dtStr := strings.Trim(section.Key("mdResyncDt").String(), `"`)
                if dt, err := strconv.ParseInt(dtStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        mdResyncDt = dt
                }</span>
        }

        // Determine parity check status based on mdResyncPos and mdResyncDt
        // - mdResyncPos &gt; 0 AND mdResyncDt = 0  PAUSED
        // - mdResyncPos &gt; 0 AND mdResyncDt &gt; 0  RUNNING (check, correct, etc.)
        // - mdResyncPos = 0  IDLE (no active operation)
        <span class="cov0" title="0">if mdResyncPos &gt; 0 </span><span class="cov0" title="0">{
                // There is an active parity operation
                if mdResyncDt == 0 </span><span class="cov0" title="0">{
                        // Operation is paused
                        status.ParityCheckStatus = "paused"
                }</span> else<span class="cov0" title="0"> {
                        // Operation is running - get the action type
                        if section.HasKey("sbSyncAction") </span><span class="cov0" title="0">{
                                action := strings.Trim(section.Key("sbSyncAction").String(), `"`)
                                // Map common action values to user-friendly status
                                switch </span>{
                                case strings.Contains(strings.ToLower(action), "check"):<span class="cov0" title="0">
                                        status.ParityCheckStatus = "running"</span>
                                case strings.Contains(strings.ToLower(action), "clear"):<span class="cov0" title="0">
                                        status.ParityCheckStatus = "clearing"</span>
                                case strings.Contains(strings.ToLower(action), "recon"):<span class="cov0" title="0">
                                        status.ParityCheckStatus = "reconstructing"</span>
                                default:<span class="cov0" title="0">
                                        status.ParityCheckStatus = "running"</span>
                                }
                        } else<span class="cov0" title="0"> {
                                status.ParityCheckStatus = "running"
                        }</span>
                }

                // Calculate progress percentage
                <span class="cov0" title="0">if mdResyncSize &gt; 0 </span><span class="cov0" title="0">{
                        status.ParityCheckProgress = float64(mdResyncPos) / float64(mdResyncSize) * 100.0
                        // Clamp to 0-100 range
                        if status.ParityCheckProgress &gt; 100 </span><span class="cov0" title="0">{
                                status.ParityCheckProgress = 100
                        }</span>
                }

                <span class="cov0" title="0">logger.Debug("Array: Parity operation detected - pos=%d, size=%d, dt=%d, status=%s, progress=%.2f%%",
                        mdResyncPos, mdResyncSize, mdResyncDt, status.ParityCheckStatus, status.ParityCheckProgress)</span>
        } else<span class="cov0" title="0"> {
                // No active parity operation
                status.ParityCheckStatus = ""
                status.ParityCheckProgress = 0
        }</span>

        // Get array size information from /mnt/user filesystem
        // /mnt/user is the shfs (Unraid user share filesystem) that represents the entire array
        <span class="cov0" title="0">c.enrichWithArraySize(status)

        logger.Debug("Array: Parsed status - state=%s, disks=%d, parity=%v, used=%.1f%%",
                status.State, status.NumDisks, status.ParityValid, status.UsedPercent)
        return status, nil</span>
}

// enrichWithArraySize gets total array size and usage from /mnt/user
func (c *ArrayCollector) enrichWithArraySize(status *dto.ArrayStatus) <span class="cov0" title="0">{
        // Use syscall.Statfs to get filesystem statistics for /mnt/user
        var stat syscall.Statfs_t
        if err := syscall.Statfs("/mnt/user", &amp;stat); err != nil </span><span class="cov0" title="0">{
                logger.Debug("Array: Failed to get /mnt/user stats: %v", err)
                return
        }</span>

        // Calculate sizes in bytes (safe conversion - Bsize is always positive)
        //nolint:gosec // G115: Bsize is always positive on Linux systems
        <span class="cov0" title="0">bsize := uint64(stat.Bsize)
        totalBytes := stat.Blocks * bsize
        freeBytes := stat.Bfree * bsize
        usedBytes := totalBytes - freeBytes

        status.TotalBytes = totalBytes
        status.FreeBytes = freeBytes

        // Calculate usage percentage
        if totalBytes &gt; 0 </span><span class="cov0" title="0">{
                status.UsedPercent = float64(usedBytes) / float64(totalBytes) * 100
        }</span>

        <span class="cov0" title="0">logger.Debug("Array: Size - total=%d bytes (%.2f TB), used=%.1f%%",
                totalBytes, float64(totalBytes)/(1024*1024*1024*1024), status.UsedPercent)</span>
}

// countParityDisks counts the number of parity disks from disks.ini
func (c *ArrayCollector) countParityDisks() int <span class="cov0" title="0">{
        // Parse disks.ini to count active parity disks
        cfg, err := ini.Load(constants.DisksIni)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Array: Failed to load disks.ini: %v", err)
                return 0
        }</span>

        <span class="cov0" title="0">parityCount := 0
        // Iterate through all sections in disks.ini
        for _, section := range cfg.Sections() </span><span class="cov0" title="0">{
                // Check if this section has type="Parity" and is active
                if section.HasKey("type") &amp;&amp; section.HasKey("status") </span><span class="cov0" title="0">{
                        diskType := strings.Trim(section.Key("type").String(), `"`)
                        diskStatus := strings.Trim(section.Key("status").String(), `"`)

                        // Only count parity disks that are active (not disabled)
                        // DISK_NP_DSBL = Not Present/Disabled, DISK_NP = Not Present, DISK_DSBL = Disabled
                        if diskType == "Parity" &amp;&amp; diskStatus != "DISK_NP_DSBL" &amp;&amp; diskStatus != "DISK_NP" &amp;&amp; diskStatus != "DISK_DSBL" </span><span class="cov0" title="0">{
                                parityCount++
                                logger.Debug("Array: Found active parity disk in section [%s] with status=%s", section.Name(), diskStatus)
                        }</span> else<span class="cov0" title="0"> if diskType == "Parity" </span><span class="cov0" title="0">{
                                logger.Debug("Array: Skipping disabled/missing parity disk in section [%s] with status=%s", section.Name(), diskStatus)
                        }</span>
                }
        }

        <span class="cov0" title="0">logger.Debug("Array: Counted %d active parity disk(s) from disks.ini", parityCount)
        return parityCount</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package collectors

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// ConfigCollector collects configuration data
type ConfigCollector struct{}

// NewConfigCollector creates a new config collector
func NewConfigCollector() *ConfigCollector <span class="cov8" title="1">{
        return &amp;ConfigCollector{}
}</span>

// GetShareConfig reads share configuration from /boot/config/shares/{name}.cfg
func (c *ConfigCollector) GetShareConfig(shareName string) (*dto.ShareConfig, error) <span class="cov8" title="1">{
        // Validate share name to prevent path traversal
        if err := validateShareName(shareName); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">configPath := fmt.Sprintf("/boot/config/shares/%s.cfg", shareName)
        logger.Debug("Config: Reading share config from %s", configPath)

        // #nosec G304 - Path is validated by validateShareName() to prevent path traversal
        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("share config not found: %s", shareName)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to open share config: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing share config file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">config := &amp;dto.ShareConfig{
                Name:      shareName,
                Timestamp: time.Now(),
        }

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                switch key </span>{
                case "shareComment":<span class="cov0" title="0">
                        config.Comment = value</span>
                case "shareAllocator":<span class="cov0" title="0">
                        config.Allocator = value</span>
                case "shareFloor":<span class="cov0" title="0">
                        config.Floor = value</span>
                case "shareSplitLevel":<span class="cov0" title="0">
                        config.SplitLevel = value</span>
                case "shareInclude":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                config.IncludeDisks = strings.Split(value, ",")
                        }</span>
                case "shareExclude":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                config.ExcludeDisks = strings.Split(value, ",")
                        }</span>
                case "shareUseCache":<span class="cov0" title="0">
                        config.UseCache = value</span>
                case "shareExport":<span class="cov0" title="0">
                        config.Export = value</span>
                case "shareSecurity":<span class="cov0" title="0">
                        config.Security = value</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading share config: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// GetNetworkConfig reads network configuration from /boot/config/network.cfg
func (c *ConfigCollector) GetNetworkConfig(interfaceName string) (*dto.NetworkConfig, error) <span class="cov0" title="0">{
        configPath := "/boot/config/network.cfg"
        logger.Debug("Config: Reading network config from %s", configPath)

        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("network config not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to open network config: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing network config file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">config := &amp;dto.NetworkConfig{
                Interface: interfaceName,
                Timestamp: time.Now(),
        }

        scanner := bufio.NewScanner(file)
        inSection := false
        currentInterface := ""

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check for section header
                <span class="cov0" title="0">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov0" title="0">{
                        currentInterface = strings.Trim(line, "[]")
                        inSection = (currentInterface == interfaceName)
                        continue</span>
                }

                <span class="cov0" title="0">if !inSection </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                switch key </span>{
                case "TYPE":<span class="cov0" title="0">
                        config.Type = value</span>
                case "IPADDR":<span class="cov0" title="0">
                        config.IPAddress = value</span>
                case "NETMASK":<span class="cov0" title="0">
                        config.Netmask = value</span>
                case "GATEWAY":<span class="cov0" title="0">
                        config.Gateway = value</span>
                case "BONDING_MODE":<span class="cov0" title="0">
                        config.BondingMode = value</span>
                case "BONDING_SLAVES":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                config.BondSlaves = strings.Split(value, " ")
                        }</span>
                case "BRIDGE_MEMBERS":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                config.BridgeMembers = strings.Split(value, " ")
                        }</span>
                case "VLAN_ID":<span class="cov0" title="0">
                        if vlanID, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                config.VLANID = vlanID
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading network config: %w", err)
        }</span>

        <span class="cov0" title="0">if config.Type == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("interface not found: %s", interfaceName)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// GetSystemSettings reads system settings from /boot/config/ident.cfg
func (c *ConfigCollector) GetSystemSettings() (*dto.SystemSettings, error) <span class="cov0" title="0">{
        configPath := "/boot/config/ident.cfg"
        logger.Debug("Config: Reading system settings from %s", configPath)

        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("system config not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to open system config: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing system config file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">settings := &amp;dto.SystemSettings{
                Timestamp: time.Now(),
        }

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                switch key </span>{
                case "NAME":<span class="cov0" title="0">
                        settings.ServerName = value</span>
                case "COMMENT":<span class="cov0" title="0">
                        settings.Description = value</span>
                case "MODEL":<span class="cov0" title="0">
                        settings.Model = value</span>
                case "TIMEZONE":<span class="cov0" title="0">
                        settings.Timezone = value</span>
                case "DATE_FORMAT":<span class="cov0" title="0">
                        settings.DateFormat = value</span>
                case "TIME_FORMAT":<span class="cov0" title="0">
                        settings.TimeFormat = value</span>
                case "SECURITY":<span class="cov0" title="0">
                        settings.SecurityMode = value</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading system config: %w", err)
        }</span>

        <span class="cov0" title="0">return settings, nil</span>
}

// GetDockerSettings reads Docker settings from /boot/config/docker.cfg
func (c *ConfigCollector) GetDockerSettings() (*dto.DockerSettings, error) <span class="cov0" title="0">{
        configPath := "/boot/config/docker.cfg"
        logger.Debug("Config: Reading Docker settings from %s", configPath)

        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return &amp;dto.DockerSettings{
                                Enabled:   false,
                                Timestamp: time.Now(),
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to open Docker config: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing Docker config file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">settings := &amp;dto.DockerSettings{
                Timestamp: time.Now(),
        }

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                switch key </span>{
                case "DOCKER_ENABLED":<span class="cov0" title="0">
                        settings.Enabled = (value == "yes" || value == "true" || value == "1")</span>
                case "DOCKER_IMAGE_FILE":<span class="cov0" title="0">
                        settings.ImagePath = value</span>
                case "DOCKER_DEFAULT_NETWORK":<span class="cov0" title="0">
                        settings.DefaultNetwork = value</span>
                case "DOCKER_CUSTOM_NETWORKS":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                settings.CustomNetworks = strings.Split(value, ",")
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading Docker config: %w", err)
        }</span>

        <span class="cov0" title="0">return settings, nil</span>
}

// GetVMSettings reads VM settings from /boot/config/domain.cfg
func (c *ConfigCollector) GetVMSettings() (*dto.VMSettings, error) <span class="cov0" title="0">{
        configPath := "/boot/config/domain.cfg"
        logger.Debug("Config: Reading VM settings from %s", configPath)

        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return &amp;dto.VMSettings{
                                Enabled:   false,
                                Timestamp: time.Now(),
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to open VM config: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing VM config file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">settings := &amp;dto.VMSettings{
                DefaultSettings: make(map[string]string),
                Timestamp:       time.Now(),
        }

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                switch key </span>{
                case "SERVICE":<span class="cov0" title="0">
                        settings.Enabled = (value == "enable" || value == "enabled")</span>
                case "PCI_DEVICES":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                settings.PCIDevices = strings.Split(value, ",")
                        }</span>
                case "USB_DEVICES":<span class="cov0" title="0">
                        if value != "" </span><span class="cov0" title="0">{
                                settings.USBDevices = strings.Split(value, ",")
                        }</span>
                default:<span class="cov0" title="0">
                        // Store other settings in default settings map
                        settings.DefaultSettings[key] = value</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading VM config: %w", err)
        }</span>

        <span class="cov0" title="0">return settings, nil</span>
}

// UpdateShareConfig writes share configuration to /boot/config/shares/{name}.cfg
func (c *ConfigCollector) UpdateShareConfig(config *dto.ShareConfig) error <span class="cov8" title="1">{
        // Validate share name to prevent path traversal
        if err := validateShareName(config.Name); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">configPath := fmt.Sprintf("/boot/config/shares/%s.cfg", config.Name)
        logger.Info("Config: Writing share config to %s", configPath)

        // Create backup
        backupPath := configPath + ".bak"
        if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                if err := os.Rename(configPath, backupPath); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Config: Failed to create backup: %v", err)
                }</span>
        }

        // #nosec G304 - Path is validated by validateShareName() to prevent path traversal
        <span class="cov0" title="0">file, err := os.Create(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create share config: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing share config file: %v", err)
                }</span>
        }()

        // Write configuration
        <span class="cov0" title="0">if config.Comment != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareComment=\"%s\"\n", config.Comment); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareComment: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if config.Allocator != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareAllocator=\"%s\"\n", config.Allocator); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareAllocator: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if config.Floor != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareFloor=\"%s\"\n", config.Floor); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareFloor: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if config.SplitLevel != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareSplitLevel=\"%s\"\n", config.SplitLevel); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareSplitLevel: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if len(config.IncludeDisks) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareInclude=\"%s\"\n", strings.Join(config.IncludeDisks, ",")); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareInclude: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if len(config.ExcludeDisks) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareExclude=\"%s\"\n", strings.Join(config.ExcludeDisks, ",")); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareExclude: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if config.UseCache != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareUseCache=\"%s\"\n", config.UseCache); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareUseCache: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if config.Export != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareExport=\"%s\"\n", config.Export); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareExport: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if config.Security != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "shareSecurity=\"%s\"\n", config.Security); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write shareSecurity: %w", err)
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Config: Share config written successfully")
        return nil</span>
}

// UpdateSystemSettings writes system settings to /boot/config/ident.cfg
func (c *ConfigCollector) UpdateSystemSettings(settings *dto.SystemSettings) error <span class="cov0" title="0">{
        configPath := "/boot/config/ident.cfg"
        logger.Info("Config: Writing system settings to %s", configPath)

        // Create backup
        backupPath := configPath + ".bak"
        if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                if err := os.Rename(configPath, backupPath); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Config: Failed to create backup: %v", err)
                }</span>
        }

        <span class="cov0" title="0">file, err := os.Create(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create system config: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing system config file: %v", err)
                }</span>
        }()

        // Write configuration
        <span class="cov0" title="0">if settings.ServerName != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "NAME=\"%s\"\n", settings.ServerName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write NAME: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if settings.Description != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "COMMENT=\"%s\"\n", settings.Description); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write COMMENT: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if settings.Model != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "MODEL=\"%s\"\n", settings.Model); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write MODEL: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if settings.Timezone != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "TIMEZONE=\"%s\"\n", settings.Timezone); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write TIMEZONE: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if settings.DateFormat != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "DATE_FORMAT=\"%s\"\n", settings.DateFormat); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write DATE_FORMAT: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if settings.TimeFormat != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "TIME_FORMAT=\"%s\"\n", settings.TimeFormat); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write TIME_FORMAT: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if settings.SecurityMode != "" </span><span class="cov0" title="0">{
                if _, err := fmt.Fprintf(file, "SECURITY=\"%s\"\n", settings.SecurityMode); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write SECURITY: %w", err)
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Config: System settings written successfully")
        return nil</span>
}

// GetDiskSettings reads disk settings from /boot/config/disk.cfg
func (c *ConfigCollector) GetDiskSettings() (*dto.DiskSettings, error) <span class="cov0" title="0">{
        configPath := "/boot/config/disk.cfg"
        logger.Debug("Config: Reading disk settings from %s", configPath)

        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("disk config not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to open disk config: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing disk config file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">settings := &amp;dto.DiskSettings{
                Timestamp: time.Now(),
        }

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                switch key </span>{
                case "spindownDelay":<span class="cov0" title="0">
                        if delay, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                settings.SpindownDelay = delay
                        }</span>
                case "startArray":<span class="cov0" title="0">
                        settings.StartArray = (value == "yes" || value == "true" || value == "1")</span>
                case "spinupGroups":<span class="cov0" title="0">
                        settings.SpinupGroups = (value == "yes" || value == "true" || value == "1")</span>
                case "shutdownTimeout":<span class="cov0" title="0">
                        if timeout, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                settings.ShutdownTimeout = timeout
                        }</span>
                case "defaultFsType":<span class="cov0" title="0">
                        settings.DefaultFsType = value</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading disk config: %w", err)
        }</span>

        <span class="cov0" title="0">return settings, nil</span>
}

// validateShareName validates a share name to prevent path traversal attacks
// Share names should contain only safe characters and no path separators
func validateShareName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("share name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov8" title="1">{
                return fmt.Errorf("share name too long: maximum 255 characters, got %d", len(name))
        }</span>

        // Check for parent directory references first (most specific attack)
        <span class="cov8" title="1">if strings.Contains(name, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid share name: parent directory references not allowed")
        }</span>

        // Check for absolute paths
        <span class="cov8" title="1">if strings.HasPrefix(name, "/") || strings.HasPrefix(name, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid share name: absolute paths not allowed")
        }</span>

        // Check for path separators (both Unix and Windows)
        <span class="cov8" title="1">if strings.Contains(name, "/") || strings.Contains(name, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid share name: path separators not allowed")
        }</span>

        // Additional security: ensure the resolved path stays within the shares directory
        <span class="cov8" title="1">const sharesDir = "/boot/config/shares"
        cleanPath := filepath.Clean(filepath.Join(sharesDir, name+".cfg"))
        if !strings.HasPrefix(cleanPath, sharesDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid share name: path escapes shares directory")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package collectors

import (
        "bufio"
        "context"
        "os"
        "strconv"
        "strings"
        "syscall"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// DiskCollector collects detailed information about all disks in the Unraid system.
// It gathers disk metrics, SMART data, temperature, and usage statistics for array and cache disks.
type DiskCollector struct {
        ctx *domain.Context
}

// NewDiskCollector creates a new disk information collector with the given context.
func NewDiskCollector(ctx *domain.Context) *DiskCollector <span class="cov8" title="1">{
        return &amp;DiskCollector{ctx: ctx}
}</span>

// Start begins the disk collector's periodic data collection.
// It runs in a goroutine and publishes disk information updates at the specified interval until the context is cancelled.
func (c *DiskCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting disk collector (interval: %v)", interval)

        // Run once immediately with panic recovery
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("Disk collector PANIC on startup: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">c.Collect()</span>
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Disk collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                logger.Error("Disk collector PANIC in loop: %v", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.Collect()</span>
                        }()
                }
        }
}

// Collect gathers detailed disk information and publishes it to the event bus.
// It collects data from multiple sources including lsblk, smartctl, and Unraid configuration files.
func (c *DiskCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting disk data...")

        // Collect disk information
        disks, err := c.collectDisks()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Disk: Failed to collect disk data: %v", err)
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Disk: Successfully collected %d disks, publishing event", len(disks))
        // Publish event
        c.ctx.Hub.Pub(disks, "disk_list_update")
        logger.Debug("Disk: Published disk_list_update event with %d disks", len(disks))</span>
}

func (c *DiskCollector) collectDisks() ([]dto.DiskInfo, error) <span class="cov0" title="0">{
        logger.Debug("Disk: Starting collection from %s", constants.DisksIni)

        // Parse disks.ini
        disks, err := c.parseDisksINI()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Enhance each disk with additional stats
        <span class="cov0" title="0">c.enrichDisks(disks)

        logger.Debug("Disk: Parsed %d disks successfully", len(disks))

        // Collect Docker vDisk information
        if dockerVDisk := c.collectDockerVDisk(); dockerVDisk != nil </span><span class="cov0" title="0">{
                disks = append(disks, *dockerVDisk)
                logger.Debug("Disk: Added Docker vDisk to collection")
        }</span>

        // Collect Log filesystem information
        <span class="cov0" title="0">if logFS := c.collectLogFilesystem(); logFS != nil </span><span class="cov0" title="0">{
                disks = append(disks, *logFS)
                logger.Debug("Disk: Added Log filesystem to collection")
        }</span>

        <span class="cov0" title="0">return disks, nil</span>
}

// parseDisksINI parses the disks.ini file and returns a slice of DiskInfo
func (c *DiskCollector) parseDisksINI() ([]dto.DiskInfo, error) <span class="cov0" title="0">{
        file, err := os.Open(constants.DisksIni)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Disk: Failed to open file: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing disk file: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">logger.Debug("Disk: File opened successfully")

        var disks []dto.DiskInfo
        scanner := bufio.NewScanner(file)
        var currentDisk *dto.DiskInfo

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                // Check for section header: ["diskname"]
                if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov0" title="0">{
                        // Save previous disk if exists
                        if currentDisk != nil </span><span class="cov0" title="0">{
                                disks = append(disks, *currentDisk)
                        }</span>

                        // Start new disk
                        <span class="cov0" title="0">currentDisk = &amp;dto.DiskInfo{
                                Timestamp: time.Now(),
                        }
                        continue</span>
                }

                // Parse key=value pairs
                <span class="cov0" title="0">if currentDisk != nil &amp;&amp; strings.Contains(line, "=") </span><span class="cov0" title="0">{
                        c.parseDiskKeyValue(currentDisk, line)
                }</span>
        }

        // Save last disk
        <span class="cov0" title="0">if currentDisk != nil </span><span class="cov0" title="0">{
                disks = append(disks, *currentDisk)
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Disk: Scanner error: %v", err)
                return disks, err
        }</span>

        <span class="cov0" title="0">return disks, nil</span>
}

// parseDiskKeyValue parses a single key=value line from disks.ini
func (c *DiskCollector) parseDiskKeyValue(disk *dto.DiskInfo, line string) <span class="cov8" title="1">{
        parts := strings.SplitN(line, "=", 2)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
        value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

        switch key </span>{
        case "name":<span class="cov8" title="1">
                disk.Name = value</span>
        case "device":<span class="cov8" title="1">
                disk.Device = value</span>
        case "id":<span class="cov8" title="1">
                disk.ID = value</span>
        case "status":<span class="cov8" title="1">
                disk.Status = value</span>
        case "size":<span class="cov8" title="1">
                if size, err := strconv.ParseUint(value, 10, 64); err == nil </span><span class="cov8" title="1">{
                        disk.Size = size * 512 // Convert sectors to bytes
                }</span>
        case "temp":<span class="cov8" title="1">
                // Temperature might be "*" if spun down, or empty, or a number
                // Unraid uses "*" to indicate disk is spun down (no temperature available)
                if value == "*" || value == "" </span><span class="cov8" title="1">{
                        // Temperature unavailable - disk is likely spun down
                        // Keep Temperature at 0 (default) and we'll set SpinState appropriately
                        logger.Debug("Disk: Device %s temperature unavailable (value='%s'), likely spun down", disk.Device, value)
                }</span> else<span class="cov8" title="1"> {
                        if temp, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov8" title="1">{
                                disk.Temperature = temp
                        }</span>
                }
        case "numErrors":<span class="cov8" title="1">
                if errors, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        disk.SMARTErrors = errors
                }</span>
        case "spindownDelay":<span class="cov8" title="1">
                if delay, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        disk.SpindownDelay = delay
                }</span>
        case "format":<span class="cov8" title="1">
                disk.FileSystem = value</span>
        }
}

// enrichDisks enhances each disk with additional statistics
func (c *DiskCollector) enrichDisks(disks []dto.DiskInfo) <span class="cov0" title="0">{
        for i := range disks </span><span class="cov0" title="0">{
                // Get I/O statistics
                c.enrichWithIOStats(&amp;disks[i])

                // Get SMART attributes (if device is available)
                if disks[i].Device != "" </span><span class="cov0" title="0">{
                        c.enrichWithSMARTData(&amp;disks[i])
                }</span>

                // Get mount information
                <span class="cov0" title="0">c.enrichWithMountInfo(&amp;disks[i])

                // Get disk role
                c.enrichWithRole(&amp;disks[i])

                // Get spin state
                if disks[i].Device != "" </span><span class="cov0" title="0">{
                        c.enrichWithSpinState(&amp;disks[i])
                }</span>
        }
}

// enrichWithIOStats adds I/O statistics from /sys/block
func (c *DiskCollector) enrichWithIOStats(disk *dto.DiskInfo) <span class="cov0" title="0">{
        if disk.Device == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Read from /sys/block/{device}/stat
        <span class="cov0" title="0">statPath := "/sys/block/" + disk.Device + "/stat"
        //nolint:gosec // G304: Path is constructed from /sys/block system directory, device name from trusted source
        data, err := os.ReadFile(statPath)
        if err != nil </span><span class="cov0" title="0">{
                return // Device might be spun down or not available
        }</span>

        <span class="cov0" title="0">fields := strings.Fields(string(data))
        if len(fields) &lt; 11 </span><span class="cov0" title="0">{
                return
        }</span>

        // Parse fields (see Documentation/block/stat.txt in Linux kernel)
        // read I/Os, read merges, read sectors, read ticks,
        // write I/Os, write merges, write sectors, write ticks,
        // in_flight, io_ticks, time_in_queue
        <span class="cov0" title="0">if readOps, err := strconv.ParseUint(fields[0], 10, 64); err == nil </span><span class="cov0" title="0">{
                disk.ReadOps = readOps
        }</span>
        <span class="cov0" title="0">if readSectors, err := strconv.ParseUint(fields[2], 10, 64); err == nil </span><span class="cov0" title="0">{
                disk.ReadBytes = readSectors * 512 // Sectors to bytes
        }</span>
        <span class="cov0" title="0">if writeOps, err := strconv.ParseUint(fields[4], 10, 64); err == nil </span><span class="cov0" title="0">{
                disk.WriteOps = writeOps
        }</span>
        <span class="cov0" title="0">if writeSectors, err := strconv.ParseUint(fields[6], 10, 64); err == nil </span><span class="cov0" title="0">{
                disk.WriteBytes = writeSectors * 512 // Sectors to bytes
        }</span>
        <span class="cov0" title="0">if ioTicks, err := strconv.ParseUint(fields[9], 10, 64); err == nil </span><span class="cov0" title="0">{
                // io_ticks is in milliseconds, calculate utilization
                // This is a cumulative value, would need previous sample for rate
                disk.IOUtilization = float64(ioTicks) / 10.0 // Rough estimate
        }</span>
}

// isUSBDevice checks if a device is a USB device by examining its sysfs path
func (c *DiskCollector) isUSBDevice(device string) bool <span class="cov0" title="0">{
        // Read the device's sysfs path to determine if it's USB
        sysfsPath := "/sys/block/" + device + "/device"

        // Read the symlink and resolve it to the full path
        devicePath, err := os.Readlink(sysfsPath)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't read the symlink, assume it's not USB
                return false
        }</span>

        // Resolve the relative path to an absolute path
        // The symlink is relative (e.g., ../../../6:0:0:0), so we need to resolve it
        <span class="cov0" title="0">fullPath, err := lib.ExecCommand("readlink", "-f", sysfsPath)
        if err != nil || len(fullPath) == 0 </span><span class="cov0" title="0">{
                // If we can't resolve the path, fall back to checking the relative path
                fullPath = []string{devicePath}
        }</span>

        // USB devices have "usb" in their full device path
        // Example: /sys/devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/host6/target6:0:0/6:0:0:0
        <span class="cov0" title="0">fullPathStr := strings.Join(fullPath, "")
        isUSB := strings.Contains(fullPathStr, "/usb")

        if isUSB </span><span class="cov0" title="0">{
                logger.Debug("Disk: Device %s detected as USB device (path: %s)", device, fullPathStr)
        }</span>

        <span class="cov0" title="0">return isUSB</span>
}

// isBootDrive checks if a device is the Unraid boot drive by checking mount points
func (c *DiskCollector) isBootDrive(device string) bool <span class="cov0" title="0">{
        // Read /proc/mounts to check if this device is mounted at /boot
        file, err := os.Open("/proc/mounts")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing /proc/mounts: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                fields := strings.Fields(line)
                if len(fields) &gt;= 2 </span><span class="cov0" title="0">{
                        // Check if this device is mounted at /boot
                        // Example: /dev/sda1 /boot vfat ...
                        if strings.Contains(fields[0], device) &amp;&amp; fields[1] == "/boot" </span><span class="cov0" title="0">{
                                logger.Debug("Disk: Device %s detected as boot drive (mounted at /boot)", device)
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// isNVMeDevice checks if a device is an NVMe device
func (c *DiskCollector) isNVMeDevice(device string) bool <span class="cov8" title="1">{
        // NVMe devices have "nvme" in their device name
        // Example: nvme0n1, nvme1n1, etc.
        isNVMe := strings.Contains(device, "nvme")

        if isNVMe </span><span class="cov8" title="1">{
                logger.Debug("Disk: Device %s detected as NVMe device", device)
        }</span>

        <span class="cov8" title="1">return isNVMe</span>
}

// enrichWithSMARTData adds SMART attributes using smartctl
func (c *DiskCollector) enrichWithSMARTData(disk *dto.DiskInfo) <span class="cov0" title="0">{
        devicePath := "/dev/" + disk.Device

        // Check if device exists
        if _, err := os.Stat(devicePath); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Default to UNKNOWN if we can't read SMART data
        <span class="cov0" title="0">disk.SMARTStatus = "UNKNOWN"

        // Check if this is a USB flash drive (like the Unraid boot drive)
        // USB flash drives typically don't support SMART monitoring
        if c.isUSBDevice(disk.Device) </span><span class="cov0" title="0">{
                if c.isBootDrive(disk.Device) </span><span class="cov0" title="0">{
                        logger.Debug("Disk: Skipping SMART check for %s (USB boot drive)", disk.Device)
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug("Disk: Skipping SMART check for %s (USB flash drive)", disk.Device)
                }</span>
                // Keep status as UNKNOWN for USB flash drives
                <span class="cov0" title="0">return</span>
        }

        // Detect device type for optimized SMART collection
        <span class="cov0" title="0">isNVMe := c.isNVMeDevice(disk.Device)

        var lines []string
        var err error

        if isNVMe </span><span class="cov0" title="0">{
                // NVMe drives don't support standby mode, so we skip the -n standby flag
                // Use smartctl -H directly for NVMe drives
                logger.Debug("Disk: Collecting SMART data for NVMe device %s (no standby check)", disk.Device)
                lines, err = lib.ExecCommand("smartctl", "-H", devicePath)
        }</span> else<span class="cov0" title="0"> {
                // SATA/SAS drives support standby mode
                // Run smartctl with -n standby to avoid waking up spun-down disks
                // The -n standby flag tells smartctl to skip the check if the disk is in standby mode
                // This preserves Unraid's disk spin-down functionality
                // Exit codes:
                //   0 = Success, disk is active, SMART data retrieved
                //   2 = Disk is in standby/sleep mode, check skipped (disk NOT woken up)
                //   Other = Error accessing disk
                logger.Debug("Disk: Collecting SMART data for SATA/SAS device %s (with standby check)", disk.Device)
                lines, err = lib.ExecCommand("smartctl", "-n", "standby", "-H", devicePath)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Check if this is a "disk in standby" error (exit code 2)
                // In this case, we preserve the disk's spun-down state and skip SMART check
                // The SMART status will remain as the last known value or UNKNOWN
                logger.Debug("Disk: Skipping SMART check for %s (disk may be in standby mode): %v", disk.Device, err)
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Disk: Successfully retrieved SMART health for %s", disk.Device)
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)

                // Parse SMART health status (SATA/SAS drives)
                // Example: "SMART overall-health self-assessment test result: PASSED"
                if strings.Contains(line, "SMART overall-health self-assessment test result:") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, ":", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                status := strings.TrimSpace(parts[1])
                                disk.SMARTStatus = strings.ToUpper(status)
                                logger.Debug("Disk: Parsed SATA/SAS SMART status for %s: %s", disk.Device, disk.SMARTStatus)
                        }</span>
                }

                // Parse SMART health status (NVMe drives)
                // Example: "SMART Health Status: OK"
                <span class="cov0" title="0">if strings.Contains(line, "SMART Health Status:") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, ":", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                status := strings.TrimSpace(parts[1])
                                // Normalize NVMe "OK" to "PASSED" for consistency
                                if strings.ToUpper(status) == "OK" </span><span class="cov0" title="0">{
                                        disk.SMARTStatus = "PASSED"
                                }</span> else<span class="cov0" title="0"> {
                                        disk.SMARTStatus = strings.ToUpper(status)
                                }</span>
                                <span class="cov0" title="0">logger.Debug("Disk: Parsed NVMe SMART status for %s: %s (original: %s)", disk.Device, disk.SMARTStatus, status)</span>
                        }
                }
        }
}

// enrichWithMountInfo adds mount point and usage information
func (c *DiskCollector) enrichWithMountInfo(disk *dto.DiskInfo) <span class="cov0" title="0">{
        if disk.Name == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Read /proc/mounts to find mount point
        <span class="cov0" title="0">data, err := os.ReadFile("/proc/mounts")
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // For Unraid array disks, the mount point is /mnt/diskN where N is the disk number
        // The device in /proc/mounts is /dev/mdNp1 (e.g., /dev/md1p1 for disk1)
        // For cache/flash, it's the actual device (e.g., /dev/nvme0n1p1, /dev/sda1)

        <span class="cov0" title="0">var mountPoint string
        lines := strings.Split(string(data), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                fields := strings.Fields(line)
                if len(fields) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if mount point matches /mnt/{diskname}
                <span class="cov0" title="0">expectedMountPoint := "/mnt/" + disk.Name
                if fields[1] == expectedMountPoint </span><span class="cov0" title="0">{
                        mountPoint = fields[1]
                        break</span>
                }

                // Also check for direct device match (for cache, flash, etc.)
                <span class="cov0" title="0">if disk.Device != "" </span><span class="cov0" title="0">{
                        devicePath := "/dev/" + disk.Device
                        if fields[0] == devicePath || strings.HasPrefix(fields[0], devicePath) </span><span class="cov0" title="0">{
                                mountPoint = fields[1]
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if mountPoint == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">disk.MountPoint = mountPoint

        // Get filesystem statistics using statfs
        var stat syscall.Statfs_t
        if err := syscall.Statfs(disk.MountPoint, &amp;stat); err == nil </span><span class="cov0" title="0">{
                // Calculate sizes in bytes (safe conversion - Bsize is always positive)
                //nolint:gosec // G115: Bsize is always positive on Linux systems
                bsize := uint64(stat.Bsize)
                totalBytes := stat.Blocks * bsize
                freeBytes := stat.Bfree * bsize
                usedBytes := totalBytes - freeBytes

                disk.Used = usedBytes
                disk.Free = freeBytes

                // Calculate usage percentage
                if totalBytes &gt; 0 </span><span class="cov0" title="0">{
                        disk.UsagePercent = float64(usedBytes) / float64(totalBytes) * 100
                }</span>
        }
}

// enrichWithRole determines the disk role (parity, parity2, data, cache, pool)
func (c *DiskCollector) enrichWithRole(disk *dto.DiskInfo) <span class="cov0" title="0">{
        // Determine role based on disk name/ID
        name := strings.ToLower(disk.Name)
        id := strings.ToLower(disk.ID)

        switch </span>{
        case strings.Contains(name, "parity2") || strings.Contains(id, "parity2"):<span class="cov0" title="0">
                disk.Role = "parity2"</span>
        case strings.Contains(name, "parity") || strings.Contains(id, "parity"):<span class="cov0" title="0">
                disk.Role = "parity"</span>
        case strings.Contains(name, "cache") || strings.Contains(id, "cache"):<span class="cov0" title="0">
                disk.Role = "cache"</span>
        case strings.Contains(name, "pool") || strings.Contains(id, "pool"):<span class="cov0" title="0">
                disk.Role = "pool"</span>
        case strings.Contains(name, "disk") || strings.Contains(id, "disk"):<span class="cov0" title="0">
                disk.Role = "data"</span>
        default:<span class="cov0" title="0">
                disk.Role = "unknown"</span>
        }
}

// enrichWithSpinState checks the current spin state of the disk
func (c *DiskCollector) enrichWithSpinState(disk *dto.DiskInfo) <span class="cov0" title="0">{
        devicePath := "/dev/" + disk.Device

        // Check if device exists
        if _, err := os.Stat(devicePath); err != nil </span><span class="cov0" title="0">{
                disk.SpinState = "unknown"
                return
        }</span>

        // Determine spin state from temperature reading
        // In Unraid's disks.ini, temp="*" indicates disk is spun down
        // If temperature is 0, this usually means the disk was spun down when parsed
        // A temperature &gt; 0 indicates the disk is active/spinning
        <span class="cov0" title="0">if disk.Temperature &gt; 0 </span><span class="cov0" title="0">{
                // Disk has a valid temperature reading - it must be active
                disk.SpinState = "active"
        }</span> else<span class="cov0" title="0"> {
                // Temperature is 0 or unavailable - disk is likely in standby
                // This could be because:
                // 1. The disk is spun down (temp="*" in disks.ini)
                // 2. Temperature couldn't be read (SMART not available)
                disk.SpinState = "standby"
        }</span>

        <span class="cov0" title="0">logger.Debug("Disk: Device %s spin state determined as '%s' (temp=%.1f)",
                disk.Device, disk.SpinState, disk.Temperature)</span>
}

// collectDockerVDisk collects Docker vDisk usage information
func (c *DiskCollector) collectDockerVDisk() *dto.DiskInfo <span class="cov0" title="0">{
        // Check if Docker mount point exists
        dockerMountPoint := "/var/lib/docker"
        if _, err := os.Stat(dockerMountPoint); err != nil </span><span class="cov0" title="0">{
                logger.Debug("Docker mount point not found: %v", err)
                return nil
        }</span>

        // Get filesystem statistics using statfs
        <span class="cov0" title="0">var stat syscall.Statfs_t
        if err := syscall.Statfs(dockerMountPoint, &amp;stat); err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to get Docker vDisk stats: %v", err)
                return nil
        }</span>

        // Calculate sizes in bytes (safe conversion - Bsize is always positive)
        //nolint:gosec // G115: Bsize is always positive on Linux systems
        <span class="cov0" title="0">bsize := uint64(stat.Bsize)
        totalBytes := stat.Blocks * bsize
        freeBytes := stat.Bfree * bsize
        usedBytes := totalBytes - freeBytes

        // Calculate usage percentage
        var usagePercent float64
        if totalBytes &gt; 0 </span><span class="cov0" title="0">{
                usagePercent = float64(usedBytes) / float64(totalBytes) * 100
        }</span>

        // Try to find the actual vDisk file path
        <span class="cov0" title="0">vdiskPath := c.findDockerVDiskPath()

        // Determine filesystem type
        filesystem := c.getFilesystemType(dockerMountPoint)

        dockerVDisk := &amp;dto.DiskInfo{
                ID:           "docker_vdisk",
                Name:         "Docker vDisk",
                Role:         "docker_vdisk",
                Size:         totalBytes,
                Used:         usedBytes,
                Free:         freeBytes,
                UsagePercent: usagePercent,
                MountPoint:   dockerMountPoint,
                FileSystem:   filesystem,
                Status:       "DISK_OK",
                Timestamp:    time.Now(),
        }

        // Add vDisk path if found
        if vdiskPath != "" </span><span class="cov0" title="0">{
                dockerVDisk.Device = vdiskPath
        }</span>

        <span class="cov0" title="0">return dockerVDisk</span>
}

// findDockerVDiskPath attempts to locate the Docker vDisk file
func (c *DiskCollector) findDockerVDiskPath() string <span class="cov0" title="0">{
        // Common Docker vDisk locations on Unraid
        possiblePaths := []string{
                "/mnt/user/system/docker/docker.vdisk",
                "/mnt/cache/system/docker/docker.vdisk",
                "/var/lib/docker.img",
        }

        for _, path := range possiblePaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// getFilesystemType determines the filesystem type for a mount point
func (c *DiskCollector) getFilesystemType(mountPoint string) string <span class="cov0" title="0">{
        // Read /proc/mounts to find filesystem type
        data, err := os.ReadFile("/proc/mounts")
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(data), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                fields := strings.Fields(line)
                if len(fields) &gt;= 3 </span><span class="cov0" title="0">{
                        // fields[1] is mount point, fields[2] is filesystem type
                        if fields[1] == mountPoint </span><span class="cov0" title="0">{
                                return fields[2]
                        }</span>
                }
        }

        <span class="cov0" title="0">return "unknown"</span>
}

// collectLogFilesystem collects Log filesystem usage information
func (c *DiskCollector) collectLogFilesystem() *dto.DiskInfo <span class="cov0" title="0">{
        // Check if log mount point exists
        logMountPoint := "/var/log"
        if _, err := os.Stat(logMountPoint); err != nil </span><span class="cov0" title="0">{
                logger.Debug("Log mount point not found: %v", err)
                return nil
        }</span>

        // Get filesystem statistics using statfs
        <span class="cov0" title="0">var stat syscall.Statfs_t
        if err := syscall.Statfs(logMountPoint, &amp;stat); err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to get Log filesystem stats: %v", err)
                return nil
        }</span>

        // Calculate sizes in bytes (safe conversion - Bsize is always positive)
        //nolint:gosec // G115: Bsize is always positive on Linux systems
        <span class="cov0" title="0">bsize := uint64(stat.Bsize)
        totalBytes := stat.Blocks * bsize
        freeBytes := stat.Bfree * bsize
        usedBytes := totalBytes - freeBytes

        // Calculate usage percentage
        var usagePercent float64
        if totalBytes &gt; 0 </span><span class="cov0" title="0">{
                usagePercent = float64(usedBytes) / float64(totalBytes) * 100
        }</span>

        // Determine filesystem type
        <span class="cov0" title="0">filesystem := c.getFilesystemType(logMountPoint)

        // Determine device name from /proc/mounts
        deviceName := c.getDeviceForMountPoint(logMountPoint)

        logFS := &amp;dto.DiskInfo{
                ID:           "log_filesystem",
                Name:         "Log",
                Role:         "log",
                Device:       deviceName,
                Size:         totalBytes,
                Used:         usedBytes,
                Free:         freeBytes,
                UsagePercent: usagePercent,
                MountPoint:   logMountPoint,
                FileSystem:   filesystem,
                Status:       "DISK_OK",
                Timestamp:    time.Now(),
        }

        return logFS</span>
}

// getDeviceForMountPoint finds the device name for a given mount point
func (c *DiskCollector) getDeviceForMountPoint(mountPoint string) string <span class="cov0" title="0">{
        // Read /proc/mounts to find device
        data, err := os.ReadFile("/proc/mounts")
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(data), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                fields := strings.Fields(line)
                if len(fields) &gt;= 2 </span><span class="cov0" title="0">{
                        // fields[0] is device, fields[1] is mount point
                        if fields[1] == mountPoint </span><span class="cov0" title="0">{
                                return fields[0]
                        }</span>
                }
        }

        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package collectors

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// DockerCollector collects information about Docker containers running on the Unraid system.
// It gathers container status, resource usage, network information, and configuration details.
type DockerCollector struct {
        ctx *domain.Context
}

// NewDockerCollector creates a new Docker container collector with the given context.
func NewDockerCollector(ctx *domain.Context) *DockerCollector <span class="cov8" title="1">{
        return &amp;DockerCollector{ctx: ctx}
}</span>

// Start begins the Docker collector's periodic data collection.
// It runs in a goroutine and publishes container information updates at the specified interval until the context is cancelled.
func (c *DockerCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting docker collector (interval: %v)", interval)
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Docker collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.Collect()</span>
                }
        }
}

// Collect gathers Docker container information and publishes it to the event bus.
// It uses the Docker CLI to inspect all containers and extract detailed information.
func (c *DockerCollector) Collect() <span class="cov0" title="0">{

        logger.Debug("Collecting docker data...")

        // Check if docker is available
        if !lib.CommandExists("docker") </span><span class="cov0" title="0">{
                logger.Warning("Docker command not found, skipping collection")
                return
        }</span>

        // Collect container information
        <span class="cov0" title="0">containers, err := c.collectContainers()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to collect containers: %v", err)
                return
        }</span>

        // Publish event
        <span class="cov0" title="0">c.ctx.Hub.Pub(containers, "container_list_update")
        logger.Debug("Published container_list_update event with %d containers", len(containers))</span>
}

func (c *DockerCollector) collectContainers() ([]*dto.ContainerInfo, error) <span class="cov0" title="0">{
        // Get container list with JSON format
        output, err := lib.ExecCommandOutput("docker", "ps", "-a", "--format", "{{json .}}")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list containers: %w", err)
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(output) == "" </span><span class="cov0" title="0">{
                return []*dto.ContainerInfo{}, nil
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(output), "\n")
        containers := make([]*dto.ContainerInfo, 0, len(lines))

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var psOutput struct {
                        ID     string `json:"ID"`
                        Image  string `json:"Image"`
                        Names  string `json:"Names"`
                        State  string `json:"State"`
                        Status string `json:"Status"`
                        Ports  string `json:"Ports"`
                }

                if err := json.Unmarshal([]byte(line), &amp;psOutput); err != nil </span><span class="cov0" title="0">{
                        logger.Warning("Failed to parse container JSON", "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">container := &amp;dto.ContainerInfo{
                        ID:        psOutput.ID,
                        Name:      strings.TrimPrefix(psOutput.Names, "/"),
                        Image:     psOutput.Image,
                        State:     strings.ToLower(psOutput.State),
                        Status:    psOutput.Status,
                        Ports:     c.parsePorts(psOutput.Ports),
                        Timestamp: time.Now(),
                }

                // Get enhanced container details using docker inspect
                if details, err := c.getContainerDetails(container.ID); err == nil </span><span class="cov0" title="0">{
                        container.Version = details.Version
                        container.NetworkMode = details.NetworkMode
                        container.IPAddress = details.IPAddress
                        container.PortMappings = details.PortMappings
                        container.VolumeMappings = details.VolumeMappings
                        container.RestartPolicy = details.RestartPolicy
                        container.Uptime = details.Uptime
                }</span>

                <span class="cov0" title="0">containers = append(containers, container)</span>
        }

        // Get stats for all running containers in a single command (power optimization)
        // This reduces process spawns from N (one per container) to 1
        <span class="cov0" title="0">runningIDs := make([]string, 0)
        containerMap := make(map[string]*dto.ContainerInfo)
        for _, container := range containers </span><span class="cov0" title="0">{
                if container.State == "running" </span><span class="cov0" title="0">{
                        runningIDs = append(runningIDs, container.ID)
                        containerMap[container.ID] = container
                }</span>
        }

        <span class="cov0" title="0">if len(runningIDs) &gt; 0 </span><span class="cov0" title="0">{
                allStats, err := c.getAllContainerStats(runningIDs)
                if err == nil </span><span class="cov0" title="0">{
                        for id, stats := range allStats </span><span class="cov0" title="0">{
                                if container, ok := containerMap[id]; ok </span><span class="cov0" title="0">{
                                        container.CPUPercent = stats.CPUPercent
                                        container.MemoryUsage = stats.MemoryUsage
                                        container.MemoryLimit = stats.MemoryLimit
                                        container.NetworkRX = stats.NetworkRX
                                        container.NetworkTX = stats.NetworkTX
                                        container.MemoryDisplay = c.formatMemoryDisplay(stats.MemoryUsage, stats.MemoryLimit)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return containers, nil</span>
}

type containerStats struct {
        CPUPercent  float64
        MemoryUsage uint64
        MemoryLimit uint64
        NetworkRX   uint64
        NetworkTX   uint64
}

// getAllContainerStats gets stats for all running containers in a single docker stats call
// This is much more power-efficient than calling docker stats per container
func (c *DockerCollector) getAllContainerStats(containerIDs []string) (map[string]*containerStats, error) <span class="cov0" title="0">{
        // Get stats for all containers in one command
        args := append([]string{"stats", "--no-stream", "--format", "{{json .}}"}, containerIDs...)
        output, err := lib.ExecCommandOutput("docker", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make(map[string]*containerStats)
        lines := strings.Split(strings.TrimSpace(output), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var statsOutput struct {
                        Container string `json:"Container"`
                        ID        string `json:"ID"`
                        CPUPerc   string `json:"CPUPerc"`
                        MemUsage  string `json:"MemUsage"`
                        MemPerc   string `json:"MemPerc"`
                        NetIO     string `json:"NetIO"`
                }

                if err := json.Unmarshal([]byte(line), &amp;statsOutput); err != nil </span><span class="cov0" title="0">{
                        logger.Warning("Failed to parse container stats JSON: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">stats := &amp;containerStats{}

                // Parse CPU percentage (e.g., "0.50%")
                if cpuStr := strings.TrimSuffix(statsOutput.CPUPerc, "%"); cpuStr != "" </span><span class="cov0" title="0">{
                        if cpu, err := strconv.ParseFloat(cpuStr, 64); err == nil </span><span class="cov0" title="0">{
                                stats.CPUPercent = cpu
                        }</span>
                }

                // Parse memory usage (e.g., "1.5GiB / 8GiB")
                <span class="cov0" title="0">if parts := strings.Split(statsOutput.MemUsage, " / "); len(parts) == 2 </span><span class="cov0" title="0">{
                        stats.MemoryUsage = c.parseSize(parts[0])
                        stats.MemoryLimit = c.parseSize(parts[1])
                }</span>

                // Parse network I/O (e.g., "1.2MB / 3.4MB")
                <span class="cov0" title="0">if parts := strings.Split(statsOutput.NetIO, " / "); len(parts) == 2 </span><span class="cov0" title="0">{
                        stats.NetworkRX = c.parseSize(parts[0])
                        stats.NetworkTX = c.parseSize(parts[1])
                }</span>

                // Use container ID to match back
                <span class="cov0" title="0">result[statsOutput.ID] = stats</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (c *DockerCollector) parseSize(sizeStr string) uint64 <span class="cov8" title="1">{
        sizeStr = strings.TrimSpace(sizeStr)
        if sizeStr == "" || sizeStr == "0B" </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Extract number and unit
        <span class="cov8" title="1">var value float64
        var unit string

        // Try to parse with unit
        if n, err := fmt.Sscanf(sizeStr, "%f%s", &amp;value, &amp;unit); n &gt;= 1 &amp;&amp; err == nil </span><span class="cov8" title="1">{
                unit = strings.ToUpper(unit)
                multiplier := uint64(1)

                switch </span>{
                case strings.HasPrefix(unit, "K"):<span class="cov8" title="1">
                        multiplier = 1024</span>
                case strings.HasPrefix(unit, "M"):<span class="cov8" title="1">
                        multiplier = 1024 * 1024</span>
                case strings.HasPrefix(unit, "G"):<span class="cov8" title="1">
                        multiplier = 1024 * 1024 * 1024</span>
                case strings.HasPrefix(unit, "T"):<span class="cov8" title="1">
                        multiplier = 1024 * 1024 * 1024 * 1024</span>
                }

                <span class="cov8" title="1">return uint64(value * float64(multiplier))</span>
        }

        <span class="cov8" title="1">return 0</span>
}

func (c *DockerCollector) parsePorts(portsStr string) []dto.PortMapping <span class="cov8" title="1">{
        if portsStr == "" </span><span class="cov8" title="1">{
                return []dto.PortMapping{}
        }</span>

        <span class="cov8" title="1">ports := []dto.PortMapping{}
        parts := strings.Split(portsStr, ", ")

        for _, part := range parts </span><span class="cov8" title="1">{
                // Format examples:
                // "0.0.0.0:8080-&gt;80/tcp"
                // "80/tcp"
                if strings.Contains(part, "-&gt;") </span><span class="cov8" title="1">{
                        // Has port mapping
                        mappingParts := strings.Split(part, "-&gt;")
                        if len(mappingParts) == 2 </span><span class="cov8" title="1">{
                                // Extract public port
                                publicPart := mappingParts[0]
                                if colonIdx := strings.LastIndex(publicPart, ":"); colonIdx &gt;= 0 </span><span class="cov8" title="1">{
                                        publicPort, _ := strconv.Atoi(publicPart[colonIdx+1:])

                                        // Extract private port and type
                                        privatePart := mappingParts[1]
                                        if slashIdx := strings.Index(privatePart, "/"); slashIdx &gt;= 0 </span><span class="cov8" title="1">{
                                                privatePort, _ := strconv.Atoi(privatePart[:slashIdx])
                                                portType := privatePart[slashIdx+1:]

                                                ports = append(ports, dto.PortMapping{
                                                        PrivatePort: privatePort,
                                                        PublicPort:  publicPort,
                                                        Type:        portType,
                                                })
                                        }</span>
                                }
                        }
                } else<span class="cov8" title="1"> if strings.Contains(part, "/") </span><span class="cov8" title="1">{
                        // Just exposed port, no mapping
                        if slashIdx := strings.Index(part, "/"); slashIdx &gt;= 0 </span><span class="cov8" title="1">{
                                port, _ := strconv.Atoi(part[:slashIdx])
                                portType := part[slashIdx+1:]

                                ports = append(ports, dto.PortMapping{
                                        PrivatePort: port,
                                        PublicPort:  0,
                                        Type:        portType,
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">return ports</span>
}

type containerDetails struct {
        Version        string
        NetworkMode    string
        IPAddress      string
        PortMappings   []string
        VolumeMappings []dto.VolumeMapping
        RestartPolicy  string
        Uptime         string
}

// getContainerDetails retrieves detailed container information using docker inspect
func (c *DockerCollector) getContainerDetails(containerID string) (*containerDetails, error) <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("docker", "inspect", containerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var inspectOutput []struct {
                Config struct {
                        Image string `json:"Image"`
                } `json:"Config"`
                NetworkSettings struct {
                        Networks map[string]struct {
                                IPAddress string `json:"IPAddress"`
                        } `json:"Networks"`
                } `json:"NetworkSettings"`
                HostConfig struct {
                        NetworkMode   string `json:"NetworkMode"`
                        RestartPolicy struct {
                                Name string `json:"Name"`
                        } `json:"RestartPolicy"`
                        PortBindings map[string][]struct {
                                HostIP   string `json:"HostIp"`
                                HostPort string `json:"HostPort"`
                        } `json:"PortBindings"`
                        Binds []string `json:"Binds"`
                } `json:"HostConfig"`
                State struct {
                        StartedAt string `json:"StartedAt"`
                } `json:"State"`
        }

        if err := json.Unmarshal([]byte(output), &amp;inspectOutput); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(inspectOutput) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no inspect data returned")
        }</span>

        <span class="cov0" title="0">inspect := inspectOutput[0]
        details := &amp;containerDetails{}

        // Extract version from image tag
        imageParts := strings.Split(inspect.Config.Image, ":")
        if len(imageParts) &gt; 1 </span><span class="cov0" title="0">{
                details.Version = imageParts[1]
        }</span> else<span class="cov0" title="0"> {
                details.Version = "latest"
        }</span>

        // Network mode
        <span class="cov0" title="0">details.NetworkMode = inspect.HostConfig.NetworkMode

        // IP Address (get first available)
        for _, network := range inspect.NetworkSettings.Networks </span><span class="cov0" title="0">{
                if network.IPAddress != "" </span><span class="cov0" title="0">{
                        details.IPAddress = network.IPAddress
                        break</span>
                }
        }

        // Port mappings
        <span class="cov0" title="0">portMappings := []string{}
        for containerPort, bindings := range inspect.HostConfig.PortBindings </span><span class="cov0" title="0">{
                for _, binding := range bindings </span><span class="cov0" title="0">{
                        if binding.HostPort != "" </span><span class="cov0" title="0">{
                                portMappings = append(portMappings, fmt.Sprintf("%s:%s", binding.HostPort, containerPort))
                        }</span>
                }
        }
        <span class="cov0" title="0">details.PortMappings = portMappings

        // Volume mappings
        volumeMappings := []dto.VolumeMapping{}
        for _, bind := range inspect.HostConfig.Binds </span><span class="cov0" title="0">{
                parts := strings.Split(bind, ":")
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        mode := "rw"
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                mode = parts[2]
                        }</span>
                        <span class="cov0" title="0">volumeMappings = append(volumeMappings, dto.VolumeMapping{
                                HostPath:      parts[0],
                                ContainerPath: parts[1],
                                Mode:          mode,
                        })</span>
                }
        }
        <span class="cov0" title="0">details.VolumeMappings = volumeMappings

        // Restart policy
        details.RestartPolicy = inspect.HostConfig.RestartPolicy.Name
        if details.RestartPolicy == "" </span><span class="cov0" title="0">{
                details.RestartPolicy = "no"
        }</span>

        // Calculate uptime
        <span class="cov0" title="0">if inspect.State.StartedAt != "" </span><span class="cov0" title="0">{
                startTime, err := time.Parse(time.RFC3339Nano, inspect.State.StartedAt)
                if err == nil </span><span class="cov0" title="0">{
                        uptime := time.Since(startTime)
                        details.Uptime = c.formatUptime(uptime)
                }</span>
        }

        <span class="cov0" title="0">return details, nil</span>
}

// formatUptime formats a duration into a human-readable uptime string
func (c *DockerCollector) formatUptime(d time.Duration) string <span class="cov8" title="1">{
        days := int(d.Hours() / 24)
        hours := int(d.Hours()) % 24
        minutes := int(d.Minutes()) % 60

        if days &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dd %dh %dm", days, hours, minutes)
        }</span>
        <span class="cov8" title="1">if hours &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dh %dm", hours, minutes)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%dm", minutes)</span>
}

// formatMemoryDisplay formats memory usage as "used / limit"
func (c *DockerCollector) formatMemoryDisplay(used, limit uint64) string <span class="cov8" title="1">{
        if limit == 0 </span><span class="cov8" title="1">{
                return "0 / 0"
        }</span>

        <span class="cov8" title="1">usedMB := float64(used) / (1024 * 1024)
        limitMB := float64(limit) / (1024 * 1024)

        if limitMB &gt;= 1024 </span><span class="cov8" title="1">{
                usedGB := usedMB / 1024
                limitGB := limitMB / 1024
                return fmt.Sprintf("%.2f GB / %.2f GB", usedGB, limitGB)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%.2f MB / %.2f MB", usedMB, limitMB)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package collectors

import (
        "context"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// GPUCollector collects GPU metrics from NVIDIA, AMD, and Intel GPUs.
// It gathers temperature, utilization, memory usage, and power consumption data.
type GPUCollector struct {
        ctx *domain.Context
}

// NewGPUCollector creates a new GPU metrics collector with the given context.
func NewGPUCollector(ctx *domain.Context) *GPUCollector <span class="cov8" title="1">{
        return &amp;GPUCollector{ctx: ctx}
}</span>

// Start begins the GPU collector's periodic data collection.
// It runs in a goroutine and publishes GPU metrics updates at the specified interval until the context is cancelled.
func (c *GPUCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting gpu collector (interval: %v)", interval)
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("GPU collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.Collect()</span>
                }
        }
}

// Collect gathers GPU metrics from all available GPUs and publishes them to the event bus.
// It detects and collects data from NVIDIA, AMD, and Intel GPUs using vendor-specific tools.
func (c *GPUCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting gpu data...")

        // Collect GPU metrics from all available GPU types
        gpuMetrics := make([]*dto.GPUMetrics, 0)

        // Try Intel iGPU
        logger.Debug("Attempting Intel GPU collection...")
        intelGPUs, err := c.collectIntelGPU()
        logger.Debug("Intel GPU collection returned: gpus=%d, err=%v", len(intelGPUs), err)
        if err == nil &amp;&amp; len(intelGPUs) &gt; 0 </span><span class="cov0" title="0">{
                gpuMetrics = append(gpuMetrics, intelGPUs...)
                logger.Debug("Collected %d Intel GPU(s)", len(intelGPUs))
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Intel GPU collection failed: %v", err)
        }</span>

        // Try NVIDIA GPU
        <span class="cov0" title="0">if lib.CommandExists("nvidia-smi") </span><span class="cov0" title="0">{
                if nvidiaGPUs, err := c.collectNvidiaGPU(); err == nil &amp;&amp; len(nvidiaGPUs) &gt; 0 </span><span class="cov0" title="0">{
                        gpuMetrics = append(gpuMetrics, nvidiaGPUs...)
                        logger.Debug("Collected %d NVIDIA GPU(s)", len(nvidiaGPUs))
                }</span>
        }

        // Try AMD GPU (radeontop or rocm-smi)
        <span class="cov0" title="0">if lib.CommandExists("radeontop") || lib.CommandExists("rocm-smi") </span><span class="cov0" title="0">{
                if amdGPUs, err := c.collectAMDGPU(); err == nil &amp;&amp; len(amdGPUs) &gt; 0 </span><span class="cov0" title="0">{
                        gpuMetrics = append(gpuMetrics, amdGPUs...)
                        logger.Debug("Collected %d AMD GPU(s)", len(amdGPUs))
                }</span>
        }

        <span class="cov0" title="0">if len(gpuMetrics) == 0 </span><span class="cov0" title="0">{
                logger.Debug("No GPUs detected or no monitoring tools available")
                return
        }</span>

        // Publish event
        <span class="cov0" title="0">c.ctx.Hub.Pub(gpuMetrics, "gpu_metrics_update")
        logger.Debug("Published gpu_metrics_update event for %d total GPU(s)", len(gpuMetrics))</span>
}

// Intel GPU collection using intel_gpu_top
func (c *GPUCollector) collectIntelGPU() ([]*dto.GPUMetrics, error) <span class="cov0" title="0">{
        logger.Debug("Intel GPU: Starting Intel GPU detection")

        // First check if Intel GPU exists using lspci
        output, err := lib.ExecCommandOutput("lspci", "-Dmm")
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Intel GPU: lspci query failed: %v", err)
                return nil, fmt.Errorf("lspci query failed: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Debug("Intel GPU: Got lspci output, searching for Intel VGA")

        // Collect ALL Intel GPUs (not just the first one)
        type intelGPUInfo struct {
                PCIID string
                Model string
        }
        intelGPUs := make([]intelGPUInfo, 0)

        for _, line := range strings.Split(output, "\n") </span><span class="cov0" title="0">{
                if (strings.Contains(line, "VGA") || strings.Contains(line, "Display")) &amp;&amp; strings.Contains(line, "Intel Corporation") </span><span class="cov0" title="0">{
                        logger.Debug("Intel GPU: Found Intel GPU line: %s", line)
                        // Parse PCI ID and model name using a more robust approach
                        // Format: "0000:00:02.0" "VGA compatible controller" "Intel Corporation" "CoffeeLake-S GT2 [UHD Graphics 630]" -p00 "ASRock Incorporation" "Device 3e92"

                        var pciID, model string

                        // Extract PCI ID (everything before first quote)
                        firstQuote := strings.Index(line, "\"")
                        if firstQuote &gt; 0 </span><span class="cov0" title="0">{
                                pciID = strings.TrimSpace(line[:firstQuote])
                        }</span>

                        // Extract all quoted strings using regex
                        // Format: "VGA compatible controller" "Intel Corporation" "CoffeeLake-S GT2 [UHD Graphics 630]" -p00 "ASRock Incorporation" "Device 3e92"
                        // Indices: [0]=class, [1]=vendor, [2]=device_name, [3]=subsys_vendor, [4]=subsys_device
                        <span class="cov0" title="0">re := regexp.MustCompile(`"([^"]*)"`)
                        matches := re.FindAllStringSubmatch(line, -1)

                        // The 3rd quoted string (index 2) is the device name
                        if len(matches) &gt;= 3 </span><span class="cov0" title="0">{
                                fullModel := matches[2][1] // matches[2][0] is the full match with quotes, [1] is the captured group
                                logger.Debug("Intel GPU: Full model string: %s", fullModel)

                                // Extract just the marketing name from brackets if present
                                if strings.Contains(fullModel, "[") </span><span class="cov0" title="0">{
                                        start := strings.Index(fullModel, "[")
                                        end := strings.Index(fullModel, "]")
                                        if start != -1 &amp;&amp; end != -1 &amp;&amp; end &gt; start </span><span class="cov0" title="0">{
                                                model = strings.TrimSpace(fullModel[start+1 : end])
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // No brackets, use the full model name
                                        model = fullModel
                                }</span>
                                <span class="cov0" title="0">logger.Debug("Intel GPU: Parsed - ID: %s, Model: %s", pciID, model)</span>
                        } else<span class="cov0" title="0"> {
                                logger.Debug("Intel GPU: Failed to parse model name from line (found %d quoted strings, need at least 3)", len(matches))
                        }</span>

                        <span class="cov0" title="0">if pciID != "" &amp;&amp; model != "" </span><span class="cov0" title="0">{
                                intelGPUs = append(intelGPUs, intelGPUInfo{PCIID: pciID, Model: model})
                        }</span>
                        // REMOVED: break statement - continue searching for more Intel GPUs
                }
        }

        <span class="cov0" title="0">if len(intelGPUs) == 0 </span><span class="cov0" title="0">{
                logger.Debug("Intel GPU: No Intel GPU found in lspci output")
                return nil, fmt.Errorf("no Intel GPU found")
        }</span>

        <span class="cov0" title="0">logger.Debug("Intel GPU: Found %d Intel GPU(s)", len(intelGPUs))

        // Check if intel_gpu_top is available
        if !lib.CommandExists("intel_gpu_top") </span><span class="cov0" title="0">{
                logger.Debug("Intel GPU: intel_gpu_top command not found")
                return nil, fmt.Errorf("intel_gpu_top not found")
        }</span>

        <span class="cov0" title="0">logger.Debug("Intel GPU: intel_gpu_top found, collecting metrics for each GPU")

        // Collect metrics for each Intel GPU
        gpuMetrics := make([]*dto.GPUMetrics, 0, len(intelGPUs))
        for idx, intelGPU := range intelGPUs </span><span class="cov0" title="0">{
                gpu := c.collectSingleIntelGPU(intelGPU.PCIID, intelGPU.Model, idx)
                if gpu != nil </span><span class="cov0" title="0">{
                        gpuMetrics = append(gpuMetrics, gpu)
                }</span>
        }

        <span class="cov0" title="0">if len(gpuMetrics) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to collect metrics for any Intel GPU")
        }</span>

        <span class="cov0" title="0">return gpuMetrics, nil</span>
}

// collectSingleIntelGPU collects metrics for a single Intel GPU
func (c *GPUCollector) collectSingleIntelGPU(pciID, model string, index int) *dto.GPUMetrics <span class="cov0" title="0">{
        logger.Debug("Intel GPU: Collecting metrics for GPU %d (%s)", index, pciID)

        // Run intel_gpu_top in JSON mode with 1 sample for power efficiency
        // Reduced timeout from 5s to 2s and samples from 2 to 1 to minimize CPU usage (Issue #8)
        // Note: intel_gpu_top auto-detects Intel GPU, doesn't support -d flag for specific device
        cmdOutput, err := lib.ExecCommandOutput("timeout", "2", "intel_gpu_top", "-J", "-s", "500", "-n", "1")
        switch </span>{
        case err != nil &amp;&amp; len(cmdOutput) == 0:<span class="cov0" title="0">
                logger.Debug("Intel GPU: intel_gpu_top query failed with no output: %v", err)
                return nil</span>
        case err != nil:<span class="cov0" title="0">
                logger.Debug("Intel GPU: intel_gpu_top timed out (expected), got %d bytes output", len(cmdOutput))</span>
        default:<span class="cov0" title="0">
                logger.Debug("Intel GPU: Got output from intel_gpu_top (%d bytes)", len(cmdOutput))</span>
        }

        // Parse JSON output - intel_gpu_top returns malformed JSON array with -n 2
        <span class="cov0" title="0">stdout := strings.TrimSpace(cmdOutput)
        stdout = strings.ReplaceAll(stdout, "\n", "")
        stdout = strings.ReplaceAll(stdout, "\t", "")

        // Find the first { and match its closing }
        startIdx := strings.Index(stdout, "{")
        if startIdx == -1 </span><span class="cov0" title="0">{
                logger.Debug("Intel GPU: No JSON object found in output")
                return nil
        }</span>

        // Simple brace matching to find the complete first JSON object
        <span class="cov0" title="0">braceCount := 0
        endIdx := -1
        for i := startIdx; i &lt; len(stdout); i++ </span><span class="cov0" title="0">{
                if stdout[i] == '{' </span><span class="cov0" title="0">{
                        braceCount++
                }</span> else<span class="cov0" title="0"> if stdout[i] == '}' </span><span class="cov0" title="0">{
                        braceCount--
                        if braceCount == 0 </span><span class="cov0" title="0">{
                                endIdx = i + 1
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if endIdx == -1 </span><span class="cov0" title="0">{
                logger.Debug("Intel GPU: Incomplete JSON object in output")
                return nil
        }</span>

        <span class="cov0" title="0">sampleJSON := stdout[startIdx:endIdx]
        logger.Debug("Intel GPU: Extracted JSON object of %d chars", len(sampleJSON))

        // Parse the sample
        var intelData map[string]interface{}
        if err := json.Unmarshal([]byte(sampleJSON), &amp;intelData); err != nil </span><span class="cov0" title="0">{
                logger.Debug("Intel GPU: Failed to parse sample: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">logger.Debug("Intel GPU: Successfully parsed sample for GPU %d", index)

        gpu := &amp;dto.GPUMetrics{
                Available: true,
                Index:     index,
                PCIID:     pciID,
                Vendor:    "intel",
                Name:      "Intel " + model,
                Timestamp: time.Now(),
        }

        // Extract driver version from modinfo
        if driverVersion, err := c.getIntelDriverVersion(); err == nil </span><span class="cov0" title="0">{
                gpu.DriverVersion = driverVersion
        }</span>

        // Extract utilization from engines
        <span class="cov0" title="0">if engines, ok := intelData["engines"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Sum up all engine utilizations for overall GPU usage
                totalUtil := 0.0
                engineCount := 0
                for engineName, engineData := range engines </span><span class="cov0" title="0">{
                        if engineMap, ok := engineData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if busy, ok := engineMap["busy"].(float64); ok </span><span class="cov0" title="0">{
                                        totalUtil += busy
                                        engineCount++
                                        logger.Debug("Intel GPU engine %s: %.2f%%", engineName, busy)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if engineCount &gt; 0 </span><span class="cov0" title="0">{
                        gpu.UtilizationGPU = totalUtil / float64(engineCount)
                }</span>
        }

        // Extract power consumption (GPU power, not package power)
        <span class="cov0" title="0">if power, ok := intelData["power"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if gpuPower, ok := power["GPU"].(float64); ok </span><span class="cov0" title="0">{
                        gpu.PowerDraw = gpuPower
                        logger.Debug("Intel GPU power: %.3f W", gpuPower)
                }</span>
        }

        // Extract memory info (Note: Intel iGPU shares system RAM, intel_gpu_top doesn't report memory usage)
        // The "memory" field is not present in intel_gpu_top JSON output for integrated GPUs
        <span class="cov0" title="0">if memory, ok := intelData["memory"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if total, ok := memory["total"].(float64); ok </span><span class="cov0" title="0">{
                        gpu.MemoryTotal = uint64(total)
                }</span>
                <span class="cov0" title="0">if shared, ok := memory["shared"].(float64); ok </span><span class="cov0" title="0">{
                        gpu.MemoryUsed = uint64(shared)
                }</span>
                <span class="cov0" title="0">if gpu.MemoryTotal &gt; 0 </span><span class="cov0" title="0">{
                        gpu.UtilizationMemory = float64(gpu.MemoryUsed) / float64(gpu.MemoryTotal) * 100
                }</span>
        }

        // Intel iGPU typically doesn't report temperature via intel_gpu_top or sysfs hwmon
        // Most Intel integrated GPUs don't expose temperature sensors
        <span class="cov0" title="0">if temp, err := c.getIntelGPUTemp(); err == nil </span><span class="cov0" title="0">{
                gpu.Temperature = temp
        }</span>

        // For Intel iGPUs, add CPU temperature as they share the die with the CPU
        // This provides useful thermal information since iGPUs don't have dedicated temp sensors
        <span class="cov0" title="0">if cpuTemp, err := c.getCPUTemp(); err == nil </span><span class="cov0" title="0">{
                gpu.CPUTemperature = cpuTemp
                logger.Debug("Intel GPU: CPU temperature: %.1fC", cpuTemp)
        }</span>

        <span class="cov0" title="0">return gpu</span>
}

// Get Intel GPU temperature from sysfs
func (c *GPUCollector) getIntelGPUTemp() (float64, error) <span class="cov0" title="0">{
        // Intel iGPU temp is usually in hwmon under i915
        output, err := lib.ExecCommandOutput("bash", "-c", "cat /sys/class/drm/card*/device/hwmon/hwmon*/temp1_input 2&gt;/dev/null | head -1")
        if err != nil || output == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read Intel GPU temperature")
        }</span>

        <span class="cov0" title="0">tempMilliC, err := strconv.ParseFloat(strings.TrimSpace(output), 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Convert from millidegrees to degrees
        <span class="cov0" title="0">return tempMilliC / 1000.0, nil</span>
}

// Get CPU temperature from coretemp hwmon
// This is useful for Intel iGPUs since they share the die with the CPU
func (c *GPUCollector) getCPUTemp() (float64, error) <span class="cov0" title="0">{
        // Try to find coretemp hwmon device
        // Look for hwmon device with name "coretemp"
        output, err := lib.ExecCommandOutput("bash", "-c", "for d in /sys/class/hwmon/hwmon*; do if [ -f $d/name ] &amp;&amp; grep -q coretemp $d/name 2&gt;/dev/null; then cat $d/temp1_input 2&gt;/dev/null &amp;&amp; exit 0; fi; done")
        if err != nil || output == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read CPU temperature from coretemp")
        }</span>

        <span class="cov0" title="0">tempMilliC, err := strconv.ParseFloat(strings.TrimSpace(output), 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Convert from millidegrees to degrees
        // temp1 is typically the package temperature (overall CPU temp)
        <span class="cov0" title="0">return tempMilliC / 1000.0, nil</span>
}

// Get Intel GPU driver version from modinfo
func (c *GPUCollector) getIntelDriverVersion() (string, error) <span class="cov0" title="0">{
        // Get vermagic from modinfo i915 (contains kernel version)
        output, err := lib.ExecCommandOutput("modinfo", "i915")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("modinfo i915 failed: %w", err)
        }</span>

        // Parse vermagic line: "vermagic:       6.12.24-Unraid SMP preempt mod_unload"
        <span class="cov0" title="0">lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(line, "vermagic:") </span><span class="cov0" title="0">{
                        // Extract kernel version from vermagic
                        parts := strings.Fields(line)
                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                // Return kernel version (e.g., "6.12.24-Unraid")
                                return parts[1], nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed to parse driver version from modinfo")</span>
}

// NVIDIA GPU collection using nvidia-smi
func (c *GPUCollector) collectNvidiaGPU() ([]*dto.GPUMetrics, error) <span class="cov0" title="0">{
        // Query nvidia-smi with CSV output for easy parsing
        // Added: pci.bus_id, uuid, fan.speed
        output, err := lib.ExecCommandOutput(
                "nvidia-smi",
                "--query-gpu=index,pci.bus_id,uuid,name,temperature.gpu,utilization.gpu,memory.used,memory.total,power.draw,fan.speed",
                "--format=csv,noheader,nounits",
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nvidia-smi query failed: %w", err)
        }</span>

        // Parse CSV output
        <span class="cov0" title="0">reader := csv.NewReader(strings.NewReader(output))
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse CSV output: %w", err)
        }</span>

        <span class="cov0" title="0">gpus := make([]*dto.GPUMetrics, 0, len(records))

        for _, record := range records </span><span class="cov0" title="0">{
                if len(record) &lt; 10 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">gpu := &amp;dto.GPUMetrics{
                        Available: true,
                        Vendor:    "nvidia",
                        Timestamp: time.Now(),
                }

                // Index
                if idx, err := strconv.Atoi(strings.TrimSpace(record[0])); err == nil </span><span class="cov0" title="0">{
                        gpu.Index = idx
                }</span>

                // PCI Bus ID
                <span class="cov0" title="0">gpu.PCIID = strings.TrimSpace(record[1])

                // UUID
                gpu.UUID = strings.TrimSpace(record[2])

                // Name
                gpu.Name = strings.TrimSpace(record[3])

                // Temperature (C)
                if temp, err := strconv.ParseFloat(strings.TrimSpace(record[4]), 64); err == nil </span><span class="cov0" title="0">{
                        gpu.Temperature = temp
                }</span>

                // Utilization (%)
                <span class="cov0" title="0">if util, err := strconv.ParseFloat(strings.TrimSpace(record[5]), 64); err == nil </span><span class="cov0" title="0">{
                        gpu.UtilizationGPU = util
                }</span>

                // Memory Used (MiB)
                <span class="cov0" title="0">if memUsed, err := strconv.ParseFloat(strings.TrimSpace(record[6]), 64); err == nil </span><span class="cov0" title="0">{
                        gpu.MemoryUsed = uint64(memUsed * 1024 * 1024) // Convert MiB to bytes
                }</span>

                // Memory Total (MiB)
                <span class="cov0" title="0">if memTotal, err := strconv.ParseFloat(strings.TrimSpace(record[7]), 64); err == nil </span><span class="cov0" title="0">{
                        gpu.MemoryTotal = uint64(memTotal * 1024 * 1024) // Convert MiB to bytes
                        if gpu.MemoryTotal &gt; 0 </span><span class="cov0" title="0">{
                                gpu.UtilizationMemory = float64(gpu.MemoryUsed) / float64(gpu.MemoryTotal) * 100
                        }</span>
                }

                // Power Draw (W)
                <span class="cov0" title="0">if power, err := strconv.ParseFloat(strings.TrimSpace(record[8]), 64); err == nil </span><span class="cov0" title="0">{
                        gpu.PowerDraw = power
                }</span>

                // Fan Speed (%)
                <span class="cov0" title="0">if fanSpeed, err := strconv.ParseFloat(strings.TrimSpace(record[9]), 64); err == nil </span><span class="cov0" title="0">{
                        gpu.FanSpeed = fanSpeed
                }</span>

                // Get driver version (same for all GPUs, only query once)
                <span class="cov0" title="0">if len(gpus) == 0 </span><span class="cov0" title="0">{
                        if driverVersion, err := c.getNvidiaDriverVersion(); err == nil </span><span class="cov0" title="0">{
                                gpu.DriverVersion = driverVersion
                        }</span>
                } else<span class="cov0" title="0"> {
                        gpu.DriverVersion = gpus[0].DriverVersion
                }</span>

                <span class="cov0" title="0">gpus = append(gpus, gpu)</span>
        }

        <span class="cov0" title="0">return gpus, nil</span>
}

// getNvidiaDriverVersion gets NVIDIA driver version
func (c *GPUCollector) getNvidiaDriverVersion() (string, error) <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("nvidia-smi", "--query-gpu=driver_version", "--format=csv,noheader")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(output), nil</span>
}

// AMD GPU collection using radeontop (broader AMD GPU compatibility)
func (c *GPUCollector) collectAMDGPU() ([]*dto.GPUMetrics, error) <span class="cov0" title="0">{
        // Try radeontop first (supports consumer Radeon GPUs)
        if lib.CommandExists("radeontop") </span><span class="cov0" title="0">{
                return c.collectAMDGPUWithRadeontop()
        }</span>

        // Fallback to rocm-smi for datacenter GPUs
        <span class="cov0" title="0">if lib.CommandExists("rocm-smi") </span><span class="cov0" title="0">{
                return c.collectAMDGPUWithROCm()
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("neither radeontop nor rocm-smi found")</span>
}

// collectAMDGPUWithRadeontop uses radeontop for consumer AMD GPUs
func (c *GPUCollector) collectAMDGPUWithRadeontop() ([]*dto.GPUMetrics, error) <span class="cov0" title="0">{
        // First, detect AMD GPUs using lspci
        output, err := lib.ExecCommandOutput("lspci", "-Dmm")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("lspci query failed: %w", err)
        }</span>

        <span class="cov0" title="0">type amdGPUInfo struct {
                PCIID string
                Model string
        }
        amdGPUs := make([]amdGPUInfo, 0)

        for _, line := range strings.Split(output, "\n") </span><span class="cov0" title="0">{
                if (strings.Contains(line, "VGA") || strings.Contains(line, "Display")) &amp;&amp;
                        (strings.Contains(line, "AMD") || strings.Contains(line, "Advanced Micro Devices") || strings.Contains(line, "ATI")) </span><span class="cov0" title="0">{

                        var pciID, model string

                        // Extract PCI ID
                        firstQuote := strings.Index(line, "\"")
                        if firstQuote &gt; 0 </span><span class="cov0" title="0">{
                                pciID = strings.TrimSpace(line[:firstQuote])
                        }</span>

                        // Extract model name
                        <span class="cov0" title="0">re := regexp.MustCompile(`"([^"]*)"`)
                        matches := re.FindAllStringSubmatch(line, -1)
                        if len(matches) &gt;= 3 </span><span class="cov0" title="0">{
                                fullModel := matches[2][1]
                                // Extract marketing name from brackets if present
                                if strings.Contains(fullModel, "[") </span><span class="cov0" title="0">{
                                        start := strings.Index(fullModel, "[")
                                        end := strings.Index(fullModel, "]")
                                        if start != -1 &amp;&amp; end != -1 &amp;&amp; end &gt; start </span><span class="cov0" title="0">{
                                                model = strings.TrimSpace(fullModel[start+1 : end])
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        model = fullModel
                                }</span>
                        }

                        <span class="cov0" title="0">if pciID != "" &amp;&amp; model != "" </span><span class="cov0" title="0">{
                                amdGPUs = append(amdGPUs, amdGPUInfo{PCIID: pciID, Model: model})
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(amdGPUs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no AMD GPU found")
        }</span>

        <span class="cov0" title="0">logger.Debug("AMD GPU: Found %d AMD GPU(s)", len(amdGPUs))

        // Collect metrics for each AMD GPU
        gpuMetrics := make([]*dto.GPUMetrics, 0, len(amdGPUs))
        for idx, amdGPU := range amdGPUs </span><span class="cov0" title="0">{
                gpu := c.collectSingleAMDGPU(amdGPU.PCIID, amdGPU.Model, idx)
                if gpu != nil </span><span class="cov0" title="0">{
                        gpuMetrics = append(gpuMetrics, gpu)
                }</span>
        }

        <span class="cov0" title="0">return gpuMetrics, nil</span>
}

// collectSingleAMDGPU collects metrics for a single AMD GPU using radeontop
func (c *GPUCollector) collectSingleAMDGPU(pciID, model string, index int) *dto.GPUMetrics <span class="cov0" title="0">{
        logger.Debug("AMD GPU: Collecting metrics for GPU %d (%s)", index, pciID)

        // Run radeontop with dump mode: radeontop -d - -l 1
        // Output format: bus 0000:01:00.0, gpu 45.00%, ee 0.00%, vgt 0.00%, ta 0.00%, tc 0.00%, sx 0.00%, sh 0.00%, spi 0.00%, sc 0.00%, pa 0.00%, db 0.00%, cb 0.00%, vram 15.00% 1234mb, gtt 5.00% 123mb, mclk 100.00% 1.750ghz, sclk 50.00% 1.200ghz
        cmdOutput, err := lib.ExecCommandOutput("timeout", "3", "radeontop", "-d", "-", "-l", "1")
        if err != nil &amp;&amp; len(cmdOutput) == 0 </span><span class="cov0" title="0">{
                logger.Debug("AMD GPU: radeontop query failed: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">gpu := &amp;dto.GPUMetrics{
                Available: true,
                Index:     index,
                PCIID:     pciID,
                Vendor:    "amd",
                Name:      "AMD " + model,
                Timestamp: time.Now(),
        }

        // Parse radeontop output
        // Example: bus 0000:03:00.0, gpu 12.34%, vram 25.50% 2048mb, sclk 50.00% 1.200ghz
        output := strings.TrimSpace(cmdOutput)
        if output != "" </span><span class="cov0" title="0">{
                // Extract GPU utilization
                if matches := regexp.MustCompile(`gpu\s+([\d.]+)%`).FindStringSubmatch(output); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if util, err := strconv.ParseFloat(matches[1], 64); err == nil </span><span class="cov0" title="0">{
                                gpu.UtilizationGPU = util
                        }</span>
                }

                // Extract VRAM usage: "vram 15.00% 1234mb"
                <span class="cov0" title="0">if matches := regexp.MustCompile(`vram\s+([\d.]+)%\s+([\d]+)mb`).FindStringSubmatch(output); len(matches) &gt; 2 </span><span class="cov0" title="0">{
                        if vramPercent, err := strconv.ParseFloat(matches[1], 64); err == nil </span><span class="cov0" title="0">{
                                gpu.UtilizationMemory = vramPercent
                        }</span>
                        <span class="cov0" title="0">if vramUsedMB, err := strconv.ParseUint(matches[2], 10, 64); err == nil </span><span class="cov0" title="0">{
                                gpu.MemoryUsed = vramUsedMB * 1024 * 1024 // Convert MB to bytes
                                // Calculate total from percentage
                                if gpu.UtilizationMemory &gt; 0 </span><span class="cov0" title="0">{
                                        gpu.MemoryTotal = uint64(float64(gpu.MemoryUsed) / (gpu.UtilizationMemory / 100.0))
                                }</span>
                        }
                }
        }

        // Get temperature from sysfs
        <span class="cov0" title="0">if temp, err := c.getAMDGPUTemp(index); err == nil </span><span class="cov0" title="0">{
                gpu.Temperature = temp
        }</span>

        // Get fan speed from sysfs (discrete GPUs only)
        <span class="cov0" title="0">if fanRPM, fanMaxRPM, err := c.getAMDGPUFanSpeed(index); err == nil </span><span class="cov0" title="0">{
                gpu.FanRPM = fanRPM
                gpu.FanMaxRPM = fanMaxRPM
        }</span>

        // Get driver version
        <span class="cov0" title="0">if driverVersion, err := c.getAMDDriverVersion(); err == nil </span><span class="cov0" title="0">{
                gpu.DriverVersion = driverVersion
        }</span>

        <span class="cov0" title="0">return gpu</span>
}

// getAMDGPUTemp gets AMD GPU temperature from sysfs
func (c *GPUCollector) getAMDGPUTemp(cardIndex int) (float64, error) <span class="cov0" title="0">{
        // AMD GPU temp is in hwmon
        output, err := lib.ExecCommandOutput("bash", "-c", fmt.Sprintf("cat /sys/class/drm/card%d/device/hwmon/hwmon*/temp1_input 2&gt;/dev/null | head -1", cardIndex))
        if err != nil || output == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read AMD GPU temperature")
        }</span>

        <span class="cov0" title="0">tempMilliC, err := strconv.ParseFloat(strings.TrimSpace(output), 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return tempMilliC / 1000.0, nil</span>
}

// getAMDGPUFanSpeed gets AMD GPU fan speed from sysfs (discrete GPUs only)
func (c *GPUCollector) getAMDGPUFanSpeed(cardIndex int) (int, int, error) <span class="cov0" title="0">{
        // Read current fan RPM
        rpmOutput, err := lib.ExecCommandOutput("bash", "-c", fmt.Sprintf("cat /sys/class/drm/card%d/device/hwmon/hwmon*/fan1_input 2&gt;/dev/null | head -1", cardIndex))
        if err != nil || rpmOutput == "" </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("fan speed not available (integrated GPU or no fan sensor)")
        }</span>

        <span class="cov0" title="0">rpm, err := strconv.Atoi(strings.TrimSpace(rpmOutput))
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        // Read max fan RPM
        <span class="cov0" title="0">maxRPMOutput, err := lib.ExecCommandOutput("bash", "-c", fmt.Sprintf("cat /sys/class/drm/card%d/device/hwmon/hwmon*/fan1_max 2&gt;/dev/null | head -1", cardIndex))
        maxRPM := 0
        if err == nil &amp;&amp; maxRPMOutput != "" </span><span class="cov0" title="0">{
                if val, err := strconv.Atoi(strings.TrimSpace(maxRPMOutput)); err == nil </span><span class="cov0" title="0">{
                        maxRPM = val
                }</span>
        }

        <span class="cov0" title="0">return rpm, maxRPM, nil</span>
}

// getAMDDriverVersion gets AMD driver version
func (c *GPUCollector) getAMDDriverVersion() (string, error) <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("modinfo", "amdgpu")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Parse modinfo output for version
        <span class="cov0" title="0">for _, line := range strings.Split(output, "\n") </span><span class="cov0" title="0">{
                if strings.HasPrefix(line, "version:") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, ":", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                return strings.TrimSpace(parts[1]), nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed to parse driver version")</span>
}

// collectAMDGPUWithROCm uses rocm-smi for datacenter AMD GPUs (fallback)
func (c *GPUCollector) collectAMDGPUWithROCm() ([]*dto.GPUMetrics, error) <span class="cov0" title="0">{
        // Query rocm-smi with JSON output
        output, err := lib.ExecCommandOutput("rocm-smi", "--showid", "--showtemp", "--showuse", "--showmeminfo", "vram", "--json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rocm-smi query failed: %w", err)
        }</span>

        <span class="cov0" title="0">var rocmData map[string]interface{}
        if err := json.Unmarshal([]byte(output), &amp;rocmData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse rocm-smi JSON: %w", err)
        }</span>

        <span class="cov0" title="0">gpus := make([]*dto.GPUMetrics, 0)
        index := 0

        // Parse each GPU
        for gpuID, gpuDataInterface := range rocmData </span><span class="cov0" title="0">{
                if !strings.HasPrefix(gpuID, "card") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">gpuData, ok := gpuDataInterface.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">gpu := &amp;dto.GPUMetrics{
                        Available: true,
                        Index:     index,
                        Vendor:    "amd",
                        Timestamp: time.Now(),
                }

                // Get GPU name/model
                if cardSeries, ok := gpuData["Card series"].(string); ok </span><span class="cov0" title="0">{
                        gpu.Name = "AMD " + cardSeries
                }</span>

                // Get temperature
                <span class="cov0" title="0">if temp, ok := gpuData["Temperature (Sensor edge) (C)"].(float64); ok </span><span class="cov0" title="0">{
                        gpu.Temperature = temp
                }</span>

                // Get GPU utilization
                <span class="cov0" title="0">if util, ok := gpuData["GPU use (%)"].(float64); ok </span><span class="cov0" title="0">{
                        gpu.UtilizationGPU = util
                }</span>

                // Get memory info
                <span class="cov0" title="0">if memUsed, ok := gpuData["VRAM Total Used Memory (B)"].(float64); ok </span><span class="cov0" title="0">{
                        gpu.MemoryUsed = uint64(memUsed)
                }</span>
                <span class="cov0" title="0">if memTotal, ok := gpuData["VRAM Total Memory (B)"].(float64); ok </span><span class="cov0" title="0">{
                        gpu.MemoryTotal = uint64(memTotal)
                        if gpu.MemoryTotal &gt; 0 </span><span class="cov0" title="0">{
                                gpu.UtilizationMemory = float64(gpu.MemoryUsed) / float64(gpu.MemoryTotal) * 100
                        }</span>
                }

                // Get driver version
                <span class="cov0" title="0">if index == 0 </span><span class="cov0" title="0">{
                        if driverVersion, err := c.getAMDDriverVersion(); err == nil </span><span class="cov0" title="0">{
                                gpu.DriverVersion = driverVersion
                        }</span>
                }

                <span class="cov0" title="0">gpus = append(gpus, gpu)
                index++</span>
        }

        <span class="cov0" title="0">return gpus, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package collectors

import (
        "context"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// HardwareCollector collects detailed hardware information using dmidecode.
// It gathers BIOS, baseboard, CPU, cache, and memory information from the system's DMI tables.
type HardwareCollector struct {
        ctx *domain.Context
}

// NewHardwareCollector creates a new hardware information collector with the given context.
func NewHardwareCollector(ctx *domain.Context) *HardwareCollector <span class="cov8" title="1">{
        return &amp;HardwareCollector{ctx: ctx}
}</span>

// Start begins the hardware collector's periodic data collection.
// It runs in a goroutine and publishes hardware information updates at the specified interval until the context is cancelled.
func (c *HardwareCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting hardware collector (interval: %v)", interval)

        // Run once immediately with panic recovery
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("Hardware collector PANIC on startup: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">c.Collect()</span>
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Hardware collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                logger.Error("Hardware collector PANIC in loop: %v", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.Collect()</span>
                        }()
                }
        }
}

// Collect gathers hardware information from DMI tables and publishes it to the event bus.
// It uses dmidecode to extract BIOS, baseboard, CPU, cache, and memory device information.
func (c *HardwareCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting hardware data...")

        // Collect hardware information
        hardwareInfo, err := c.collectHardwareInfo()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Hardware: Failed to collect hardware data: %v", err)
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Hardware: Successfully collected hardware info, publishing event")
        // Publish event
        c.ctx.Hub.Pub(hardwareInfo, "hardware_update")
        logger.Debug("Hardware: Published hardware_update event")</span>
}

func (c *HardwareCollector) collectHardwareInfo() (*dto.HardwareInfo, error) <span class="cov0" title="0">{
        info := &amp;dto.HardwareInfo{
                Timestamp: time.Now(),
        }

        // Check if dmidecode is available
        if !lib.CommandExists("dmidecode") </span><span class="cov0" title="0">{
                logger.Warning("dmidecode command not found, skipping hardware collection")
                return info, nil
        }</span>

        // Collect BIOS information
        <span class="cov0" title="0">if bios, err := lib.ParseBIOSInfo(); err == nil </span><span class="cov0" title="0">{
                info.BIOS = bios
                logger.Debug("Hardware: Collected BIOS info - Vendor: %s, Version: %s", bios.Vendor, bios.Version)
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("Hardware: Failed to collect BIOS info: %v", err)
        }</span>

        // Collect baseboard information
        <span class="cov0" title="0">if baseboard, err := lib.ParseBaseboardInfo(); err == nil </span><span class="cov0" title="0">{
                info.Baseboard = baseboard
                logger.Debug("Hardware: Collected baseboard info - Manufacturer: %s, Product: %s", baseboard.Manufacturer, baseboard.ProductName)
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("Hardware: Failed to collect baseboard info: %v", err)
        }</span>

        // Collect CPU hardware information
        <span class="cov0" title="0">if cpu, err := lib.ParseCPUInfo(); err == nil </span><span class="cov0" title="0">{
                info.CPU = cpu
                logger.Debug("Hardware: Collected CPU hardware info - Socket: %s, Manufacturer: %s", cpu.SocketDesignation, cpu.Manufacturer)
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("Hardware: Failed to collect CPU hardware info: %v", err)
        }</span>

        // Collect CPU cache information
        <span class="cov0" title="0">if caches, err := lib.ParseCPUCacheInfo(); err == nil </span><span class="cov0" title="0">{
                info.Cache = caches
                logger.Debug("Hardware: Collected %d CPU cache levels", len(caches))
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("Hardware: Failed to collect CPU cache info: %v", err)
        }</span>

        // Collect memory array information
        <span class="cov0" title="0">if memArray, err := lib.ParseMemoryArrayInfo(); err == nil </span><span class="cov0" title="0">{
                info.MemoryArray = memArray
                logger.Debug("Hardware: Collected memory array info - Max Capacity: %s, Devices: %d", memArray.MaximumCapacity, memArray.NumberOfDevices)
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("Hardware: Failed to collect memory array info: %v", err)
        }</span>

        // Collect memory device information
        <span class="cov0" title="0">if memDevices, err := lib.ParseMemoryDevices(); err == nil </span><span class="cov0" title="0">{
                info.MemoryDevices = memDevices
                logger.Debug("Hardware: Collected %d memory devices", len(memDevices))
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("Hardware: Failed to collect memory devices: %v", err)
        }</span>

        <span class="cov0" title="0">return info, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package collectors

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// NetworkCollector collects network interface information including status, speed, and statistics.
// It gathers data from network interfaces, bonds, bridges, and VLANs.
type NetworkCollector struct {
        ctx *domain.Context
}

// NewNetworkCollector creates a new network interface collector with the given context.
func NewNetworkCollector(ctx *domain.Context) *NetworkCollector <span class="cov8" title="1">{
        return &amp;NetworkCollector{ctx: ctx}
}</span>

// Start begins the network collector's periodic data collection.
// It runs in a goroutine and publishes network interface updates at the specified interval until the context is cancelled.
func (c *NetworkCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting network collector (interval: %v)", interval)

        // Run once immediately with panic recovery
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("Network collector PANIC on startup: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">c.Collect()</span>
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Network collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                logger.Error("Network collector PANIC in loop: %v", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.Collect()</span>
                        }()
                }
        }
}

// Collect gathers network interface information and publishes it to the event bus.
// It collects data from /sys/class/net and uses ethtool for detailed interface information.
func (c *NetworkCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting network data...")

        // Collect network interfaces
        interfaces, err := c.collectNetworkInterfaces()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Network: Failed to collect interface data: %v", err)
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Network: Successfully collected %d interfaces, publishing event", len(interfaces))
        // Publish event
        c.ctx.Hub.Pub(interfaces, "network_list_update")
        logger.Debug("Network: Published network_list_update event with %d interfaces", len(interfaces))</span>
}

func (c *NetworkCollector) collectNetworkInterfaces() ([]dto.NetworkInfo, error) <span class="cov0" title="0">{
        logger.Debug("Network: Starting collection from /proc/net/dev and /sys/class/net")
        var interfaces []dto.NetworkInfo

        // Parse /proc/net/dev for bandwidth stats
        stats, err := c.parseNetDev()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Network: Failed to parse /proc/net/dev: %v", err)
                return nil, err
        }</span>

        // Get interface details from /sys/class/net
        <span class="cov0" title="0">for ifName, ifStats := range stats </span><span class="cov0" title="0">{
                // Skip loopback
                if ifName == "lo" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">netInfo := dto.NetworkInfo{
                        Name:            ifName,
                        BytesReceived:   ifStats.BytesReceived,
                        BytesSent:       ifStats.BytesSent,
                        PacketsReceived: ifStats.PacketsReceived,
                        PacketsSent:     ifStats.PacketsSent,
                        ErrorsReceived:  ifStats.ErrorsReceived,
                        ErrorsSent:      ifStats.ErrorsSent,
                        Timestamp:       time.Now(),
                }

                // Get MAC address
                netInfo.MACAddress = c.getMACAddress(ifName)

                // Get IP address
                netInfo.IPAddress = c.getIPAddress(ifName)

                // Get link speed
                netInfo.Speed = c.getLinkSpeed(ifName)

                // Get operational state
                netInfo.State = c.getOperState(ifName)

                // Get ethtool information (enhanced network details)
                c.enrichWithEthtool(&amp;netInfo, ifName)

                interfaces = append(interfaces, netInfo)</span>
        }

        <span class="cov0" title="0">logger.Debug("Network: Parsed %d interfaces successfully", len(interfaces))
        return interfaces, nil</span>
}

type netStats struct {
        BytesReceived   uint64
        PacketsReceived uint64
        ErrorsReceived  uint64
        BytesSent       uint64
        PacketsSent     uint64
        ErrorsSent      uint64
}

func (c *NetworkCollector) parseNetDev() (map[string]netStats, error) <span class="cov0" title="0">{
        file, err := os.Open("/proc/net/dev")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing network stats file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">stats := make(map[string]netStats)
        scanner := bufio.NewScanner(file)

        // Skip header lines
        scanner.Scan()
        scanner.Scan()

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                parts := strings.Split(line, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ifName := strings.TrimSpace(parts[0])
                fields := strings.Fields(parts[1])

                if len(fields) &lt; 16 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">stats[ifName] = netStats{
                        BytesReceived:   parseUint64(fields[0]),
                        PacketsReceived: parseUint64(fields[1]),
                        ErrorsReceived:  parseUint64(fields[2]),
                        BytesSent:       parseUint64(fields[8]),
                        PacketsSent:     parseUint64(fields[9]),
                        ErrorsSent:      parseUint64(fields[10]),
                }</span>
        }

        <span class="cov0" title="0">return stats, scanner.Err()</span>
}

func (c *NetworkCollector) getMACAddress(ifName string) string <span class="cov0" title="0">{
        path := fmt.Sprintf("/sys/class/net/%s/address", ifName)
        //nolint:gosec // G304: Path is constructed from /sys/class/net system directory, ifName from trusted source
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(data))</span>
}

func (c *NetworkCollector) getIPAddress(ifName string) string <span class="cov0" title="0">{
        // Use ip command to get IP address
        output, err := lib.ExecCommandOutput("ip", "-4", "addr", "show", ifName)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if strings.HasPrefix(line, "inet ") </span><span class="cov0" title="0">{
                        fields := strings.Fields(line)
                        if len(fields) &gt;= 2 </span><span class="cov0" title="0">{
                                // Return IP without CIDR notation
                                ip := strings.Split(fields[1], "/")[0]
                                return ip
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (c *NetworkCollector) getLinkSpeed(ifName string) int <span class="cov0" title="0">{
        path := fmt.Sprintf("/sys/class/net/%s/speed", ifName)
        //nolint:gosec // G304: Path is constructed from /sys/class/net system directory, ifName from trusted source
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">speed, err := strconv.Atoi(strings.TrimSpace(string(data)))
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return speed</span>
}

func (c *NetworkCollector) getOperState(ifName string) string <span class="cov0" title="0">{
        path := fmt.Sprintf("/sys/class/net/%s/operstate", ifName)
        //nolint:gosec // G304: Path is constructed from /sys/class/net system directory, ifName from trusted source
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(data))</span>
}

func parseUint64(s string) uint64 <span class="cov8" title="1">{
        val, _ := strconv.ParseUint(s, 10, 64)
        return val
}</span>

// enrichWithEthtool adds ethtool information to the network interface
func (c *NetworkCollector) enrichWithEthtool(netInfo *dto.NetworkInfo, ifName string) <span class="cov0" title="0">{
        // Parse ethtool information
        ethtoolInfo, err := lib.ParseEthtool(ifName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Network: Failed to get ethtool info for %s: %v", ifName, err)
                return
        }</span>

        // Populate ethtool fields
        <span class="cov0" title="0">netInfo.SupportedPorts = ethtoolInfo.SupportedPorts
        netInfo.SupportedLinkModes = ethtoolInfo.SupportedLinkModes
        netInfo.SupportedPauseFrame = ethtoolInfo.SupportedPauseFrame
        netInfo.SupportsAutoNeg = ethtoolInfo.SupportsAutoNeg
        netInfo.SupportedFECModes = ethtoolInfo.SupportedFECModes
        netInfo.AdvertisedLinkModes = ethtoolInfo.AdvertisedLinkModes
        netInfo.AdvertisedPauseFrame = ethtoolInfo.AdvertisedPauseFrame
        netInfo.AdvertisedAutoNeg = ethtoolInfo.AdvertisedAutoNeg
        netInfo.AdvertisedFECModes = ethtoolInfo.AdvertisedFECModes
        netInfo.Duplex = ethtoolInfo.Duplex
        netInfo.AutoNegotiation = ethtoolInfo.AutoNegotiation
        netInfo.Port = ethtoolInfo.Port
        netInfo.PHYAD = ethtoolInfo.PHYAD
        netInfo.Transceiver = ethtoolInfo.Transceiver
        netInfo.MDIX = ethtoolInfo.MDIX
        netInfo.SupportsWakeOn = ethtoolInfo.SupportsWakeOn
        netInfo.WakeOn = ethtoolInfo.WakeOn
        netInfo.MessageLevel = ethtoolInfo.MessageLevel
        netInfo.LinkDetected = ethtoolInfo.LinkDetected
        netInfo.MTU = ethtoolInfo.MTU

        logger.Debug("Network: Enriched %s with ethtool data - Duplex: %s, Link: %v", ifName, netInfo.Duplex, netInfo.LinkDetected)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package collectors

import (
        "context"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/fsnotify/fsnotify"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

const (
        notificationsDir        = "/usr/local/emhttp/state/notifications"
        notificationsArchiveDir = "/usr/local/emhttp/state/notifications/archive"
)

// NotificationCollector collects Unraid notifications
type NotificationCollector struct {
        ctx     *domain.Context
        watcher *fsnotify.Watcher
}

// NewNotificationCollector creates a new notification collector
func NewNotificationCollector(ctx *domain.Context) *NotificationCollector <span class="cov8" title="1">{
        return &amp;NotificationCollector{ctx: ctx}
}</span>

// Start begins collecting notification data
func (c *NotificationCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("Notification collector panic: %v", r)
                }</span>
        }()

        // Initialize file watcher
        <span class="cov0" title="0">var err error
        c.watcher, err = fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create file watcher: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := c.watcher.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to close file watcher: %v", err)
                }</span>
        }()

        // Ensure directories exist
        // #nosec G301 - Unraid standard permissions (0755 for directories)
        <span class="cov0" title="0">if err := os.MkdirAll(notificationsDir, 0755); err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to create notifications directory: %v", err)
        }</span>
        // #nosec G301 - Unraid standard permissions (0755 for directories)
        <span class="cov0" title="0">if err := os.MkdirAll(notificationsArchiveDir, 0755); err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to create notifications archive directory: %v", err)
        }</span>

        // Watch notification directories
        <span class="cov0" title="0">if err := c.watcher.Add(notificationsDir); err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to watch notifications directory: %v", err)
        }</span>
        <span class="cov0" title="0">if err := c.watcher.Add(notificationsArchiveDir); err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to watch notifications archive directory: %v", err)
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        // Initial collection
        c.collect()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Notification collector stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.collect()</span>
                case event := &lt;-c.watcher.Events:<span class="cov0" title="0">
                        // Trigger immediate collection on file changes
                        if event.Op&amp;fsnotify.Create == fsnotify.Create ||
                                event.Op&amp;fsnotify.Remove == fsnotify.Remove ||
                                event.Op&amp;fsnotify.Write == fsnotify.Write </span><span class="cov0" title="0">{
                                logger.Debug("Notification file change detected: %s", event.Name)
                                c.collect()
                        }</span>
                case err := &lt;-c.watcher.Errors:<span class="cov0" title="0">
                        logger.Error("File watcher error: %v", err)</span>
                }
        }
}

// collect gathers all notifications and publishes to event bus
func (c *NotificationCollector) collect() <span class="cov0" title="0">{
        unread := c.collectNotifications(notificationsDir, "unread")
        archived := c.collectNotifications(notificationsArchiveDir, "archive")

        overview := c.calculateOverview(unread, archived)

        notificationList := &amp;dto.NotificationList{
                Overview:      overview,
                Notifications: append(unread, archived...),
                Timestamp:     time.Now(),
        }

        c.ctx.Hub.Pub(notificationList, "notifications_update")
}</span>

// collectNotifications reads all notification files from a directory
func (c *NotificationCollector) collectNotifications(dir string, notifType string) []dto.Notification <span class="cov0" title="0">{
        files, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to read notifications directory %s: %v", dir, err)
                return []dto.Notification{}
        }</span>

        <span class="cov0" title="0">var notifications []dto.Notification
        for _, file := range files </span><span class="cov0" title="0">{
                if !strings.HasSuffix(file.Name(), ".notify") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">notification := c.parseNotificationFile(filepath.Join(dir, file.Name()), notifType)
                if notification != nil </span><span class="cov0" title="0">{
                        notifications = append(notifications, *notification)
                }</span>
        }

        // Sort by timestamp descending (newest first)
        <span class="cov0" title="0">sort.Slice(notifications, func(i, j int) bool </span><span class="cov0" title="0">{
                return notifications[i].Timestamp.After(notifications[j].Timestamp)
        }</span>)

        <span class="cov0" title="0">return notifications</span>
}

// parseNotificationFile parses a notification file and returns a Notification
func (c *NotificationCollector) parseNotificationFile(path string, notifType string) *dto.Notification <span class="cov0" title="0">{
        content, err := os.ReadFile(path) // #nosec G304 - Path is from controlled directory scan
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to read notification file %s: %v", path, err)
                return nil
        }</span>

        <span class="cov0" title="0">notification := &amp;dto.Notification{
                ID:   filepath.Base(path),
                Type: notifType,
        }

        lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                switch key </span>{
                case "event":<span class="cov0" title="0">
                        notification.Title = value</span>
                case "subject":<span class="cov0" title="0">
                        notification.Subject = value</span>
                case "description":<span class="cov0" title="0">
                        notification.Description = value</span>
                case "importance":<span class="cov0" title="0">
                        notification.Importance = value</span>
                case "timestamp":<span class="cov0" title="0">
                        if ts, err := time.Parse("2006-01-02 15:04:05", value); err == nil </span><span class="cov0" title="0">{
                                notification.Timestamp = ts
                                notification.FormattedTimestamp = ts.Format(time.RFC3339)
                        }</span>
                case "link":<span class="cov0" title="0">
                        notification.Link = value</span>
                }
        }

        // If timestamp wasn't parsed, use file modification time
        <span class="cov0" title="0">if notification.Timestamp.IsZero() </span><span class="cov0" title="0">{
                if info, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        notification.Timestamp = info.ModTime()
                        notification.FormattedTimestamp = info.ModTime().Format(time.RFC3339)
                }</span>
        }

        <span class="cov0" title="0">return notification</span>
}

// calculateOverview calculates notification counts by type and importance
func (c *NotificationCollector) calculateOverview(unread, archived []dto.Notification) dto.NotificationOverview <span class="cov0" title="0">{
        return dto.NotificationOverview{
                Unread:  c.countByImportance(unread),
                Archive: c.countByImportance(archived),
        }
}</span>

// countByImportance counts notifications by importance level
func (c *NotificationCollector) countByImportance(notifications []dto.Notification) dto.NotificationCounts <span class="cov0" title="0">{
        counts := dto.NotificationCounts{}
        for _, n := range notifications </span><span class="cov0" title="0">{
                switch n.Importance </span>{
                case "alert":<span class="cov0" title="0">
                        counts.Alert++</span>
                case "warning":<span class="cov0" title="0">
                        counts.Warning++</span>
                case "info":<span class="cov0" title="0">
                        counts.Info++</span>
                }
        }
        <span class="cov0" title="0">counts.Total = counts.Alert + counts.Warning + counts.Info
        return counts</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package collectors

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// NUTCollector collects NUT (Network UPS Tools) status information.
// This collector provides detailed UPS data when the NUT plugin is installed.
type NUTCollector struct {
        ctx *domain.Context
}

// NewNUTCollector creates a new NUT status collector with the given context.
func NewNUTCollector(ctx *domain.Context) *NUTCollector <span class="cov8" title="1">{
        return &amp;NUTCollector{ctx: ctx}
}</span>

// Start begins the NUT collector's periodic data collection.
func (c *NUTCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting NUT collector (interval: %v)", interval)

        // Run once immediately
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("NUT collector PANIC on startup: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">c.Collect()</span>
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("NUT collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                logger.Error("NUT collector PANIC in loop: %v", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.Collect()</span>
                        }()
                }
        }
}

// Collect gathers NUT status information and publishes it to the event bus.
func (c *NUTCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting NUT data...")

        response := &amp;dto.NUTResponse{
                Timestamp: time.Now(),
        }

        // Check if NUT plugin is installed
        if _, err := os.Stat(constants.NutPluginDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                response.Installed = false
                c.ctx.Hub.Pub(response, "nut_status_update")
                logger.Debug("NUT plugin not installed")
                return
        }</span>
        <span class="cov0" title="0">response.Installed = true

        // Load NUT configuration
        config, err := c.loadNUTConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to load NUT config: %v", err)
        }</span> else<span class="cov0" title="0"> {
                response.Config = config
        }</span>

        // Check if NUT service is running
        <span class="cov0" title="0">response.Running = c.isNUTRunning()

        if !response.Running </span><span class="cov0" title="0">{
                c.ctx.Hub.Pub(response, "nut_status_update")
                logger.Debug("NUT service not running")
                return
        }</span>

        // Get list of UPS devices
        <span class="cov0" title="0">devices, err := c.listDevices()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to list NUT devices: %v", err)
        }</span> else<span class="cov0" title="0"> {
                response.Devices = devices
        }</span>

        // Get detailed status for the first available device
        <span class="cov0" title="0">if len(devices) &gt; 0 </span><span class="cov0" title="0">{
                status, err := c.collectStatus(devices[0].Name, c.getHostFromConfig(config))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warning("Failed to collect NUT status: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        response.Status = status
                }</span>
        }

        <span class="cov0" title="0">c.ctx.Hub.Pub(response, "nut_status_update")
        logger.Debug("Published nut_status_update event")</span>
}

// loadNUTConfig reads the NUT plugin configuration file
func (c *NUTCollector) loadNUTConfig() (*dto.NUTConfig, error) <span class="cov0" title="0">{
        file, err := os.Open(constants.NutPluginCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        config := &amp;dto.NUTConfig{}
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.Trim(strings.TrimSpace(parts[1]), "\"")

                switch key </span>{
                case "SERVICE":<span class="cov0" title="0">
                        config.ServiceEnabled = value == "enable"</span>
                case "MODE":<span class="cov0" title="0">
                        config.Mode = value</span>
                case "NAME":<span class="cov0" title="0">
                        config.UPSName = value</span>
                case "DRIVER":<span class="cov0" title="0">
                        config.Driver = value</span>
                case "PORT":<span class="cov0" title="0">
                        config.Port = value</span>
                case "IPADDR":<span class="cov0" title="0">
                        config.IPAddress = value</span>
                case "POLL":<span class="cov0" title="0">
                        if poll, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                config.PollInterval = poll
                        }</span>
                case "SHUTDOWN":<span class="cov0" title="0">
                        config.ShutdownMode = value</span>
                case "BATTERYLEVEL":<span class="cov0" title="0">
                        if level, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                config.BatteryLevel = level
                        }</span>
                case "RTVALUE":<span class="cov0" title="0">
                        if rt, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                config.RuntimeValue = rt
                        }</span>
                case "TIMEOUT":<span class="cov0" title="0">
                        if timeout, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                config.Timeout = timeout
                        }</span>
                }
        }

        <span class="cov0" title="0">return config, scanner.Err()</span>
}

// isNUTRunning checks if the NUT service is running
func (c *NUTCollector) isNUTRunning() bool <span class="cov0" title="0">{
        // Check for PID file
        if _, err := os.Stat(constants.NutPidFile); err == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Also check if upsd process is running
        <span class="cov0" title="0">output, err := lib.ExecCommandOutput("pgrep", "-x", "upsd")
        if err == nil &amp;&amp; strings.TrimSpace(output) != "" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// listDevices returns a list of available NUT UPS devices
func (c *NUTCollector) listDevices() ([]dto.NUTDevice, error) <span class="cov0" title="0">{
        if !lib.CommandExists("upsc") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("upsc command not found")
        }</span>

        <span class="cov0" title="0">output, err := lib.ExecCommandOutput("upsc", "-l", "localhost")
        if err != nil </span><span class="cov0" title="0">{
                // Try without host
                output, err = lib.ExecCommandOutput("upsc", "-l")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">var devices []dto.NUTDevice
        lines := strings.Split(strings.TrimSpace(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                name := strings.TrimSpace(line)
                if name == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">devices = append(devices, dto.NUTDevice{
                        Name:        name,
                        Description: fmt.Sprintf("UPS device: %s", name),
                        Available:   true,
                })</span>
        }

        <span class="cov0" title="0">return devices, nil</span>
}

// getHostFromConfig returns the host from NUT config, defaulting to localhost
func (c *NUTCollector) getHostFromConfig(config *dto.NUTConfig) string <span class="cov0" title="0">{
        if config != nil &amp;&amp; config.IPAddress != "" &amp;&amp; config.IPAddress != "127.0.0.1" </span><span class="cov0" title="0">{
                return config.IPAddress
        }</span>
        <span class="cov0" title="0">return "localhost"</span>
}

// collectStatus collects detailed status for a specific UPS device
func (c *NUTCollector) collectStatus(deviceName, host string) (*dto.NUTStatus, error) <span class="cov0" title="0">{
        target := fmt.Sprintf("%s@%s", deviceName, host)
        output, err := lib.ExecCommandOutput("upsc", target)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query UPS %s: %w", target, err)
        }</span>

        <span class="cov0" title="0">status := &amp;dto.NUTStatus{
                Connected:    true,
                DeviceName:   deviceName,
                Host:         host,
                RawVariables: make(map[string]string),
                Timestamp:    time.Now(),
        }

        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Store in raw variables
                status.RawVariables[key] = value

                // Parse specific fields
                switch key </span>{
                // Driver info
                case "driver.name":<span class="cov0" title="0">
                        status.Driver = value</span>
                case "driver.state":<span class="cov0" title="0">
                        status.DriverState = value</span>
                case "driver.version":<span class="cov0" title="0">
                        status.DriverVersion = value</span>
                case "driver.version.data":<span class="cov0" title="0">
                        status.DriverVersionData = value</span>
                case "driver.version.usb":<span class="cov0" title="0">
                        status.DriverVersionUSB = value</span>

                // Device identification
                case "device.mfr", "ups.mfr":<span class="cov0" title="0">
                        status.Manufacturer = value</span>
                case "device.model", "ups.model":<span class="cov0" title="0">
                        status.Model = value</span>
                case "device.serial", "ups.serial":<span class="cov0" title="0">
                        status.Serial = value</span>
                case "device.type":<span class="cov0" title="0">
                        status.Type = value</span>
                case "ups.productid":<span class="cov0" title="0">
                        status.ProductID = value</span>
                case "ups.vendorid":<span class="cov0" title="0">
                        status.VendorID = value</span>

                // UPS status
                case "ups.status":<span class="cov0" title="0">
                        status.Status = value
                        status.StatusText = dto.NUTStatusText(value)</span>
                case "ups.beeper.status":<span class="cov0" title="0">
                        status.BeeperStatus = value</span>
                case "ups.test.result":<span class="cov0" title="0">
                        status.TestResult = value</span>

                // Battery info
                case "battery.charge":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryCharge = v
                        }</span>
                case "battery.charge.low":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryChargeLow = v
                        }</span>
                case "battery.charge.warning":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryChargeWarning = v
                        }</span>
                case "battery.runtime":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryRuntime = int(v)
                        }</span>
                case "battery.runtime.low":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryRuntimeLow = int(v)
                        }</span>
                case "battery.voltage":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryVoltage = v
                        }</span>
                case "battery.voltage.nominal":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryVoltageNominal = v
                        }</span>
                case "battery.type":<span class="cov0" title="0">
                        status.BatteryType = value</span>
                case "battery.status":<span class="cov0" title="0">
                        status.BatteryStatus = value</span>
                case "battery.mfr.date":<span class="cov0" title="0">
                        status.BatteryMfrDate = value</span>

                // Input power
                case "input.voltage":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.InputVoltage = v
                        }</span>
                case "input.voltage.nominal":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.InputVoltageNominal = v
                        }</span>
                case "input.frequency":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.InputFrequency = v
                        }</span>
                case "input.transfer.high":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.InputTransferHigh = v
                        }</span>
                case "input.transfer.low":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.InputTransferLow = v
                        }</span>
                case "input.current":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.InputCurrent = v
                        }</span>

                // Output power
                case "output.voltage":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.OutputVoltage = v
                        }</span>
                case "output.frequency":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.OutputFrequency = v
                        }</span>
                case "output.current":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.OutputCurrent = v
                        }</span>

                // Load and power
                case "ups.load":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.LoadPercent = v
                        }</span>
                case "ups.realpower":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.RealPower = v
                        }</span>
                case "ups.realpower.nominal":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.RealPowerNominal = v
                        }</span>
                case "ups.power":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.ApparentPower = v
                        }</span>
                case "ups.power.nominal":<span class="cov0" title="0">
                        if v, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.ApparentPowerNominal = v
                        }</span>

                // Timing
                case "ups.delay.shutdown":<span class="cov0" title="0">
                        if v, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                status.DelayShutdown = v
                        }</span>
                case "ups.delay.start":<span class="cov0" title="0">
                        if v, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                status.DelayStart = v
                        }</span>
                case "ups.timer.shutdown":<span class="cov0" title="0">
                        if v, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                status.TimerShutdown = v
                        }</span>
                case "ups.timer.start":<span class="cov0" title="0">
                        if v, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                status.TimerStart = v
                        }</span>
                }
        }

        // Calculate real power if not directly available
        <span class="cov0" title="0">if status.RealPower == 0 &amp;&amp; status.RealPowerNominal &gt; 0 &amp;&amp; status.LoadPercent &gt; 0 </span><span class="cov0" title="0">{
                status.RealPower = status.RealPowerNominal * status.LoadPercent / 100.0
        }</span>

        // Calculate apparent power if not directly available
        <span class="cov0" title="0">if status.ApparentPower == 0 &amp;&amp; status.ApparentPowerNominal &gt; 0 &amp;&amp; status.LoadPercent &gt; 0 </span><span class="cov0" title="0">{
                status.ApparentPower = status.ApparentPowerNominal * status.LoadPercent / 100.0
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package collectors

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

const parityLogPath = "/boot/config/parity-checks.log"

// ParityCollector collects parity check history
type ParityCollector struct{}

// NewParityCollector creates a new parity collector
func NewParityCollector() *ParityCollector <span class="cov8" title="1">{
        return &amp;ParityCollector{}
}</span>

// GetParityHistory reads and parses the parity-checks.log file
func (c *ParityCollector) GetParityHistory() (*dto.ParityCheckHistory, error) <span class="cov0" title="0">{
        logger.Debug("Parity: Reading parity check history from %s", parityLogPath)

        file, err := os.Open(parityLogPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        logger.Debug("Parity: Parity log file does not exist: %s", parityLogPath)
                        return &amp;dto.ParityCheckHistory{
                                Records:   []dto.ParityCheckRecord{},
                                Timestamp: time.Now(),
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to open parity log: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing parity log file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">var records []dto.ParityCheckRecord
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">record, err := c.parseLine(line)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Parity: Failed to parse line: %s - %v", line, err)
                        continue</span>
                }

                <span class="cov0" title="0">records = append(records, record)</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading parity log: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Debug("Parity: Found %d parity check records", len(records))

        return &amp;dto.ParityCheckHistory{
                Records:   records,
                Timestamp: time.Now(),
        }, nil</span>
}

// parseLine parses a single line from parity-checks.log
// Format examples:
// Parity-Check|2024-11-30, 00:30:26 (Saturday)|10 TB|1 day, 4 hr, 1 min, 28 sec|99.1 MB/s|OK|1348756140
// Parity-Sync|2025-05-04, 07:55:41 (Sunday)|16 TB|9 min, 3 sec|Unavailable|Canceled|0
func (c *ParityCollector) parseLine(line string) (dto.ParityCheckRecord, error) <span class="cov0" title="0">{
        parts := strings.Split(line, "|")
        if len(parts) &lt; 7 </span><span class="cov0" title="0">{
                return dto.ParityCheckRecord{}, fmt.Errorf("invalid line format: expected 7 parts, got %d", len(parts))
        }</span>

        <span class="cov0" title="0">record := dto.ParityCheckRecord{
                Action: strings.TrimSpace(parts[0]),
        }

        // Parse date (format: "2024-11-30, 00:30:26 (Saturday)")
        dateStr := strings.TrimSpace(parts[1])
        // Remove day of week in parentheses
        if idx := strings.Index(dateStr, "("); idx &gt; 0 </span><span class="cov0" title="0">{
                dateStr = strings.TrimSpace(dateStr[:idx])
        }</span>

        <span class="cov0" title="0">date, err := time.Parse("2006-01-02, 15:04:05", dateStr)
        if err != nil </span><span class="cov0" title="0">{
                return dto.ParityCheckRecord{}, fmt.Errorf("failed to parse date '%s': %w", dateStr, err)
        }</span>
        <span class="cov0" title="0">record.Date = date

        // Parse size (format: "10 TB" or "16 TB")
        sizeStr := strings.TrimSpace(parts[2])
        size, err := c.parseSize(sizeStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Parity: Failed to parse size '%s': %v", sizeStr, err)
                record.Size = 0
        }</span> else<span class="cov0" title="0"> {
                record.Size = size
        }</span>

        // Parse duration (format: "1 day, 4 hr, 1 min, 28 sec" or "9 min, 3 sec")
        <span class="cov0" title="0">durationStr := strings.TrimSpace(parts[3])
        duration, err := c.parseDuration(durationStr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Parity: Failed to parse duration '%s': %v", durationStr, err)
                record.Duration = 0
        }</span> else<span class="cov0" title="0"> {
                record.Duration = duration
        }</span>

        // Parse speed (format: "99.1 MB/s" or "Unavailable")
        <span class="cov0" title="0">speedStr := strings.TrimSpace(parts[4])
        if speedStr == "Unavailable" || speedStr == "" </span><span class="cov0" title="0">{
                record.Speed = 0
        }</span> else<span class="cov0" title="0"> {
                speed, err := c.parseSpeed(speedStr)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Parity: Failed to parse speed '%s': %v", speedStr, err)
                        record.Speed = 0
                }</span> else<span class="cov0" title="0"> {
                        record.Speed = speed
                }</span>
        }

        // Parse status (format: "OK", "Canceled", or error count like "3572342875")
        <span class="cov0" title="0">statusStr := strings.TrimSpace(parts[5])
        record.Status = statusStr
        if statusStr != "OK" &amp;&amp; statusStr != "Canceled" </span><span class="cov0" title="0">{
                // Try to parse as error count
                if errors, err := strconv.ParseInt(statusStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        record.Errors = errors
                        record.Status = fmt.Sprintf("%d errors", errors)
                }</span>
        }

        // Parse errors (last field - error count)
        <span class="cov0" title="0">errorsStr := strings.TrimSpace(parts[6])
        if errors, err := strconv.ParseInt(errorsStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                record.Errors = errors
        }</span>

        <span class="cov0" title="0">return record, nil</span>
}

// parseSize converts size string like "10 TB" to bytes
func (c *ParityCollector) parseSize(sizeStr string) (uint64, error) <span class="cov8" title="1">{
        parts := strings.Fields(sizeStr)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid size format: %s", sizeStr)
        }</span>

        <span class="cov8" title="1">value, err := strconv.ParseFloat(parts[0], 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid size value: %s", parts[0])
        }</span>

        <span class="cov8" title="1">unit := strings.ToUpper(parts[1])
        var multiplier uint64

        switch unit </span>{
        case "B":<span class="cov8" title="1">
                multiplier = 1</span>
        case "KB":<span class="cov8" title="1">
                multiplier = 1024</span>
        case "MB":<span class="cov8" title="1">
                multiplier = 1024 * 1024</span>
        case "GB":<span class="cov8" title="1">
                multiplier = 1024 * 1024 * 1024</span>
        case "TB":<span class="cov8" title="1">
                multiplier = 1024 * 1024 * 1024 * 1024</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("unknown size unit: %s", unit)</span>
        }

        <span class="cov8" title="1">return uint64(value * float64(multiplier)), nil</span>
}

// parseDuration converts duration string like "1 day, 4 hr, 1 min, 28 sec" to seconds
func (c *ParityCollector) parseDuration(durationStr string) (int64, error) <span class="cov8" title="1">{
        var totalSeconds int64

        parts := strings.Split(durationStr, ",")
        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                fields := strings.Fields(part)
                if len(fields) != 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">value, err := strconv.ParseInt(fields[0], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">unit := strings.ToLower(fields[1])
                switch </span>{
                case strings.HasPrefix(unit, "day"):<span class="cov8" title="1">
                        totalSeconds += value * 86400</span>
                case strings.HasPrefix(unit, "hr") || strings.HasPrefix(unit, "hour"):<span class="cov8" title="1">
                        totalSeconds += value * 3600</span>
                case strings.HasPrefix(unit, "min"):<span class="cov8" title="1">
                        totalSeconds += value * 60</span>
                case strings.HasPrefix(unit, "sec"):<span class="cov8" title="1">
                        totalSeconds += value</span>
                }
        }

        <span class="cov8" title="1">return totalSeconds, nil</span>
}

// parseSpeed converts speed string like "99.1 MB/s" to MB/s
func (c *ParityCollector) parseSpeed(speedStr string) (float64, error) <span class="cov8" title="1">{
        // Remove " MB/s" suffix
        speedStr = strings.TrimSuffix(speedStr, " MB/s")
        speedStr = strings.TrimSpace(speedStr)

        speed, err := strconv.ParseFloat(speedStr, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid speed value: %s", speedStr)
        }</span>

        <span class="cov8" title="1">return speed, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package collectors

import (
        "context"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
        "gopkg.in/ini.v1"
)

// RegistrationCollector collects Unraid registration/license information
type RegistrationCollector struct {
        ctx *domain.Context
}

// NewRegistrationCollector creates a new registration collector
func NewRegistrationCollector(ctx *domain.Context) *RegistrationCollector <span class="cov8" title="1">{
        return &amp;RegistrationCollector{ctx: ctx}
}</span>

// Start begins collecting registration information at the specified interval
func (c *RegistrationCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting registration collector (interval: %v)", interval)

        // Run once immediately with panic recovery
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("Registration collector PANIC on startup: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">c.Collect()</span>
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Registration collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                logger.Error("Registration collector PANIC in loop: %v", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.Collect()</span>
                        }()
                }
        }
}

// Collect gathers registration information
func (c *RegistrationCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting registration data...")

        registration, err := c.collectRegistration()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Registration: Failed to collect registration info: %v", err)
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Registration: Successfully collected, publishing event")
        c.ctx.Hub.Pub(registration, "registration_update")
        logger.Debug("Registration: Published registration_update event - type=%s, state=%s", registration.Type, registration.State)</span>
}

// collectRegistration reads registration information from var.ini
func (c *RegistrationCollector) collectRegistration() (*dto.Registration, error) <span class="cov0" title="0">{
        logger.Debug("Registration: Reading from %s", constants.VarIni)

        registration := &amp;dto.Registration{
                Timestamp: time.Now(),
        }

        // Parse var.ini for registration information
        cfg, err := ini.Load(constants.VarIni)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Registration: Failed to load file: %v", err)
                return nil, err
        }</span>

        // Get the default section (unnamed section)
        <span class="cov0" title="0">section := cfg.Section("")

        // Registration type (regTy)
        if section.HasKey("regTy") </span><span class="cov0" title="0">{
                regType := strings.Trim(section.Key("regTy").String(), `"`)
                registration.Type = strings.ToLower(regType)
        }</span> else<span class="cov0" title="0"> {
                registration.Type = "unknown"
        }</span>

        // Registration GUID (regGUID)
        <span class="cov0" title="0">if section.HasKey("regGUID") </span><span class="cov0" title="0">{
                registration.GUID = strings.Trim(section.Key("regGUID").String(), `"`)
        }</span>

        // Server name (NAME)
        <span class="cov0" title="0">if section.HasKey("NAME") </span><span class="cov0" title="0">{
                registration.ServerName = strings.Trim(section.Key("NAME").String(), `"`)
        }</span>

        // Registration timestamp/expiration (regTm)
        <span class="cov0" title="0">if section.HasKey("regTm") </span><span class="cov0" title="0">{
                regTmStr := strings.Trim(section.Key("regTm").String(), `"`)
                if timestamp, err := strconv.ParseInt(regTmStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        registration.Expiration = time.Unix(timestamp, 0)
                        registration.UpdateExpiration = time.Unix(timestamp, 0)
                }</span>
        }

        // Determine state based on expiration
        <span class="cov0" title="0">switch </span>{
        case !registration.Expiration.IsZero():<span class="cov0" title="0">
                if time.Now().After(registration.Expiration) </span><span class="cov0" title="0">{
                        registration.State = "expired"
                }</span> else<span class="cov0" title="0"> {
                        registration.State = "valid"
                }</span>
        case registration.Type == "trial":<span class="cov0" title="0">
                registration.State = "trial"</span>
        case registration.Type == "lifetime" || registration.Type == "unleashed":<span class="cov0" title="0">
                registration.State = "valid"</span>
        case registration.Type == "unknown":<span class="cov0" title="0">
                registration.State = "invalid"</span>
        default:<span class="cov0" title="0">
                registration.State = "valid"</span>
        }

        <span class="cov0" title="0">logger.Debug("Registration: Parsed - type=%s, state=%s, server=%s",
                registration.Type, registration.State, registration.ServerName)

        return registration, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package collectors

import (
        "bufio"
        "context"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// ShareCollector collects information about Unraid user shares.
// It gathers share configuration, usage statistics, and disk allocation details.
type ShareCollector struct {
        ctx *domain.Context
}

// NewShareCollector creates a new user share collector with the given context.
func NewShareCollector(ctx *domain.Context) *ShareCollector <span class="cov8" title="1">{
        return &amp;ShareCollector{ctx: ctx}
}</span>

// Start begins the share collector's periodic data collection.
// It runs in a goroutine and publishes share information updates at the specified interval until the context is cancelled.
func (c *ShareCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting share collector (interval: %v)", interval)

        // Run once immediately with panic recovery
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("Share collector PANIC on startup: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">c.Collect()</span>
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Share collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                logger.Error("Share collector PANIC in loop: %v", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.Collect()</span>
                        }()
                }
        }
}

// Collect gathers user share information and publishes it to the event bus.
// It reads share configuration from /boot/config/shares/ and enriches with usage data from df command.
func (c *ShareCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting share data...")

        // Collect share information
        shares, err := c.collectShares()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Share: Failed to collect share data: %v", err)
                return
        }</span>

        <span class="cov0" title="0">logger.Debug("Share: Successfully collected %d shares, publishing event", len(shares))
        // Publish event
        c.ctx.Hub.Pub(shares, "share_list_update")
        logger.Debug("Share: Published share_list_update event with %d shares", len(shares))</span>
}

func (c *ShareCollector) collectShares() ([]dto.ShareInfo, error) <span class="cov0" title="0">{
        logger.Debug("Share: Starting collection from %s", constants.SharesIni)
        var shares []dto.ShareInfo

        // Parse shares.ini
        file, err := os.Open(constants.SharesIni)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Share: Failed to open file: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing share file: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">logger.Debug("Share: File opened successfully")

        scanner := bufio.NewScanner(file)
        var currentShare *dto.ShareInfo
        var currentShareName string

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())

                // Check for section header: [shareName="appdata"]
                if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov0" title="0">{
                        // Save previous share if exists
                        if currentShare != nil </span><span class="cov0" title="0">{
                                shares = append(shares, *currentShare)
                        }</span>

                        // Extract share name from [shareName="appdata"]
                        <span class="cov0" title="0">if strings.Contains(line, "=") </span><span class="cov0" title="0">{
                                parts := strings.SplitN(line[1:len(line)-1], "=", 2)
                                if len(parts) == 2 </span><span class="cov0" title="0">{
                                        currentShareName = strings.Trim(parts[1], `"`)
                                }</span>
                        }

                        // Start new share
                        <span class="cov0" title="0">currentShare = &amp;dto.ShareInfo{
                                Name: currentShareName,
                        }
                        continue</span>
                }

                // Parse key=value pairs
                <span class="cov0" title="0">if currentShare != nil &amp;&amp; strings.Contains(line, "=") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                        switch key </span>{
                        case "name":<span class="cov0" title="0">
                                // Use the name field from the INI file
                                currentShare.Name = value</span>
                        case "size":<span class="cov0" title="0">
                                if size, err := strconv.ParseUint(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                                        currentShare.Total = size
                                }</span>
                        case "free":<span class="cov0" title="0">
                                if free, err := strconv.ParseUint(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                                        currentShare.Free = free
                                }</span>
                        case "used":<span class="cov0" title="0">
                                if used, err := strconv.ParseUint(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                                        currentShare.Used = used
                                }</span>
                        }
                }
        }

        // Save last share
        <span class="cov0" title="0">if currentShare != nil </span><span class="cov0" title="0">{
                shares = append(shares, *currentShare)
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Share: Scanner error: %v", err)
                return shares, err
        }</span>

        // Calculate total and usage percentage for each share
        <span class="cov0" title="0">for i := range shares </span><span class="cov0" title="0">{
                // If total is 0, calculate it from used + free
                if shares[i].Total == 0 &amp;&amp; (shares[i].Used &gt; 0 || shares[i].Free &gt; 0) </span><span class="cov0" title="0">{
                        shares[i].Total = shares[i].Used + shares[i].Free
                }</span>

                // Calculate usage percentage
                <span class="cov0" title="0">if shares[i].Total &gt; 0 </span><span class="cov0" title="0">{
                        shares[i].UsagePercent = float64(shares[i].Used) / float64(shares[i].Total) * 100
                }</span>

                // Set timestamp
                <span class="cov0" title="0">shares[i].Timestamp = time.Now()</span>
        }

        // Enrich shares with configuration data
        <span class="cov0" title="0">configCollector := NewConfigCollector()
        for i := range shares </span><span class="cov0" title="0">{
                c.enrichShareWithConfig(&amp;shares[i], configCollector)
        }</span>

        <span class="cov0" title="0">logger.Debug("Share: Parsed %d shares successfully", len(shares))
        return shares, nil</span>
}

// enrichShareWithConfig enriches a share with configuration data
func (c *ShareCollector) enrichShareWithConfig(share *dto.ShareInfo, configCollector *ConfigCollector) <span class="cov0" title="0">{
        config, err := configCollector.GetShareConfig(share.Name)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Share: Failed to get config for share %s: %v", share.Name, err)
                // Set default values for shares without config
                share.Storage = "unknown"
                share.SMBExport = false
                share.NFSExport = false
                return
        }</span>

        // Populate configuration fields
        <span class="cov0" title="0">share.Comment = config.Comment
        share.UseCache = config.UseCache
        share.Security = config.Security
        share.Storage = c.determineStorage(config.UseCache)
        share.SMBExport = c.isSMBExported(config.Export, config.Security)
        share.NFSExport = c.isNFSExported(config.Export)

        logger.Debug("Share: Enriched %s - Storage: %s, SMB: %v, NFS: %v", share.Name, share.Storage, share.SMBExport, share.NFSExport)</span>
}

// determineStorage determines storage location based on UseCache setting
func (c *ShareCollector) determineStorage(useCache string) string <span class="cov0" title="0">{
        switch useCache </span>{
        case "no":<span class="cov0" title="0">
                return "array"</span>
        case "only":<span class="cov0" title="0">
                return "cache"</span>
        case "yes", "prefer":<span class="cov0" title="0">
                return "cache+array"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// isSMBExported checks if share is exported via SMB
func (c *ShareCollector) isSMBExported(export string, security string) bool <span class="cov0" title="0">{
        // If security is set, share is typically SMB exported
        if security == "public" || security == "private" || security == "secure" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check export field for SMB indicators
        <span class="cov0" title="0">if strings.Contains(export, "smb") || strings.Contains(export, "-e") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// isNFSExported checks if share is exported via NFS
func (c *ShareCollector) isNFSExported(export string) bool <span class="cov0" title="0">{
        // Check export field for NFS indicators
        return strings.Contains(export, "nfs") || strings.Contains(export, "-n")
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package collectors provides data collection services for system metrics.
package collectors

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// SystemCollector collects overall system information including CPU, memory, uptime, and temperatures.
// It provides high-level system metrics and status information.
type SystemCollector struct {
        ctx *domain.Context
}

// NewSystemCollector creates a new system information collector with the given context.
func NewSystemCollector(ctx *domain.Context) *SystemCollector <span class="cov8" title="1">{
        return &amp;SystemCollector{ctx: ctx}
}</span>

// Start begins the system collector's periodic data collection.
// It runs in a goroutine and publishes system information updates at the specified interval until the context is cancelled.
func (c *SystemCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting system collector (interval: %v)", interval)

        // Run once immediately with panic recovery
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                logger.Error("System collector PANIC on startup: %v", r)
                        }</span>
                }()
                <span class="cov0" title="0">c.Collect()</span>
        }()

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("System collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        func() </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                logger.Error("System collector PANIC in loop: %v", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">c.Collect()</span>
                        }()
                }
        }
}

// Collect gathers system information and publishes it to the event bus.
// It collects CPU, memory, uptime, and temperature data from /proc and /sys filesystems.
func (c *SystemCollector) Collect() <span class="cov0" title="0">{
        logger.Debug("Collecting system data...")

        // Collect system info
        systemInfo, err := c.collectSystemInfo()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to collect system info: %v", err)
                return
        }</span>

        // Publish event
        <span class="cov0" title="0">c.ctx.Hub.Pub(systemInfo, "system_update")
        logger.Debug("Published system_update event")</span>
}

func (c *SystemCollector) collectSystemInfo() (*dto.SystemInfo, error) <span class="cov0" title="0">{
        info := &amp;dto.SystemInfo{}

        // Get hostname
        hostname, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to get hostname", "error", err)
                info.Hostname = "unknown"
        }</span> else<span class="cov0" title="0"> {
                info.Hostname = hostname
        }</span>

        // Get Unraid version
        <span class="cov0" title="0">info.Version = c.getUnraidVersion()

        // Get Management Agent version
        info.AgentVersion = c.ctx.Version

        // Get uptime
        uptime, err := c.getUptime()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to get uptime", "error", err)
        }</span> else<span class="cov0" title="0"> {
                info.Uptime = uptime
        }</span>

        // Get CPU info
        <span class="cov0" title="0">cpuPercent, err := c.getCPUInfo()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to get CPU info", "error", err)
        }</span> else<span class="cov0" title="0"> {
                info.CPUUsage = cpuPercent
        }</span>

        // Get CPU model and specs
        <span class="cov0" title="0">cpuModel, cpuCores, cpuThreads, cpuMHz := c.getCPUSpecs()
        info.CPUModel = cpuModel
        info.CPUCores = cpuCores
        info.CPUThreads = cpuThreads
        info.CPUMHz = cpuMHz

        // Get per-core CPU usage
        perCoreUsage, err := c.getPerCoreCPUUsage()
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to get per-core CPU usage: %v", err)
        }</span> else<span class="cov0" title="0"> {
                info.CPUPerCore = perCoreUsage
        }</span>

        // Get memory info
        <span class="cov0" title="0">memUsed, memTotal, memFree, memBuffers, memCached, err := c.getMemoryInfo()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to get memory info", "error", err)
        }</span> else<span class="cov0" title="0"> {
                info.RAMUsed = memUsed
                info.RAMTotal = memTotal
                info.RAMFree = memFree
                info.RAMBuffers = memBuffers
                info.RAMCached = memCached
                if memTotal &gt; 0 </span><span class="cov0" title="0">{
                        info.RAMUsage = float64(memUsed) / float64(memTotal) * 100
                }</span>
        }

        // Get server model and BIOS info
        <span class="cov0" title="0">serverModel, biosVersion, biosDate := c.getSystemHardwareInfo()
        info.ServerModel = serverModel
        info.BIOSVersion = biosVersion
        info.BIOSDate = biosDate

        // Get temperatures
        temperatures, err := c.getTemperatures()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to get temperatures", "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Extract CPU and motherboard temps if available
                for name, temp := range temperatures </span><span class="cov0" title="0">{
                        nameLower := strings.ToLower(name)
                        // CPU temperature - look for Core temps, Package, or CPUTIN
                        if strings.Contains(nameLower, "core") || strings.Contains(nameLower, "package") || strings.Contains(nameLower, "cputin") </span><span class="cov0" title="0">{
                                if info.CPUTemp == 0 || temp &gt; info.CPUTemp </span><span class="cov0" title="0">{
                                        info.CPUTemp = temp
                                }</span>
                        }
                        // Motherboard temperature - look for "MB Temp" or "MB_Temp" specifically from coretemp
                        // Ignore SYSTIN and AUXTIN as they often have bogus readings
                        <span class="cov0" title="0">if strings.Contains(nameLower, "mb_temp") </span><span class="cov0" title="0">{
                                // Sanity check: temperature should be reasonable (0-100C)
                                if temp &gt; 0 &amp;&amp; temp &lt; 100 </span><span class="cov0" title="0">{
                                        info.MotherboardTemp = temp
                                }</span>
                        }
                }
        }

        // Get fan speeds
        <span class="cov0" title="0">fans, err := c.getFans()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to get fan speeds", "error", err)
        }</span> else<span class="cov0" title="0"> {
                info.Fans = fans
        }</span>

        // Get virtualization features
        <span class="cov0" title="0">info.HVMEnabled = c.isHVMEnabled()
        info.IOMMUEnabled = c.isIOMMUEnabled()

        // Get additional system information
        info.OpenSSLVersion = c.getOpenSSLVersion()
        info.KernelVersion = c.getKernelVersion()
        info.ParityCheckSpeed = c.getParityCheckSpeed()

        // Set timestamp
        info.Timestamp = time.Now()

        return info, nil</span>
}

func (c *SystemCollector) getUptime() (int64, error) <span class="cov0" title="0">{
        data, err := os.ReadFile("/proc/uptime")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">fields := strings.Fields(string(data))
        if len(fields) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid uptime format")
        }</span>

        <span class="cov0" title="0">uptime, err := strconv.ParseFloat(fields[0], 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int64(uptime), nil</span>
}

func (c *SystemCollector) getCPUInfo() (float64, error) <span class="cov0" title="0">{
        // Get CPU usage by reading /proc/stat
        cpuPercent, err := c.calculateCPUPercent()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to calculate CPU percent", "error", err)
                return 0, err
        }</span>

        <span class="cov0" title="0">return cpuPercent, nil</span>
}

func (c *SystemCollector) calculateCPUPercent() (float64, error) <span class="cov0" title="0">{
        // Read first snapshot
        stat1, err := c.readCPUStat()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Wait a short time
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        // Read second snapshot
        stat2, err := c.readCPUStat()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Calculate usage
        <span class="cov0" title="0">total1 := stat1["user"] + stat1["nice"] + stat1["system"] + stat1["idle"] + stat1["iowait"] + stat1["irq"] + stat1["softirq"] + stat1["steal"]
        total2 := stat2["user"] + stat2["nice"] + stat2["system"] + stat2["idle"] + stat2["iowait"] + stat2["irq"] + stat2["softirq"] + stat2["steal"]

        idle1 := stat1["idle"] + stat1["iowait"]
        idle2 := stat2["idle"] + stat2["iowait"]

        totalDelta := total2 - total1
        idleDelta := idle2 - idle1

        if totalDelta == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">usage := (float64(totalDelta-idleDelta) / float64(totalDelta)) * 100
        return usage, nil</span>
}

func (c *SystemCollector) readCPUStat() (map[string]uint64, error) <span class="cov0" title="0">{
        file, err := os.Open("/proc/stat")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing CPU stat file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.HasPrefix(line, "cpu ") </span><span class="cov0" title="0">{
                        fields := strings.Fields(line)
                        if len(fields) &lt; 9 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid cpu stat format")
                        }</span>

                        <span class="cov0" title="0">stat := make(map[string]uint64)
                        var err error
                        if stat["user"], err = strconv.ParseUint(fields[1], 10, 64); err != nil </span><span class="cov0" title="0">{
                                logger.Warning("Failed to parse CPU user stat: %v", err)
                        }</span>
                        <span class="cov0" title="0">if stat["nice"], err = strconv.ParseUint(fields[2], 10, 64); err != nil </span><span class="cov0" title="0">{
                                logger.Warning("Failed to parse CPU nice stat: %v", err)
                        }</span>
                        <span class="cov0" title="0">if stat["system"], err = strconv.ParseUint(fields[3], 10, 64); err != nil </span><span class="cov0" title="0">{
                                logger.Warning("Failed to parse CPU system stat: %v", err)
                        }</span>
                        <span class="cov0" title="0">if stat["idle"], err = strconv.ParseUint(fields[4], 10, 64); err != nil </span><span class="cov0" title="0">{
                                logger.Warning("Failed to parse CPU idle stat: %v", err)
                        }</span>
                        <span class="cov0" title="0">if stat["iowait"], err = strconv.ParseUint(fields[5], 10, 64); err != nil </span><span class="cov0" title="0">{
                                logger.Warning("Failed to parse CPU iowait stat: %v", err)
                        }</span>
                        <span class="cov0" title="0">if stat["irq"], err = strconv.ParseUint(fields[6], 10, 64); err != nil </span><span class="cov0" title="0">{
                                logger.Warning("Failed to parse CPU irq stat: %v", err)
                        }</span>
                        <span class="cov0" title="0">if stat["softirq"], err = strconv.ParseUint(fields[7], 10, 64); err != nil </span><span class="cov0" title="0">{
                                logger.Warning("Failed to parse CPU softirq stat: %v", err)
                        }</span>
                        <span class="cov0" title="0">if stat["steal"], err = strconv.ParseUint(fields[8], 10, 64); err != nil </span><span class="cov0" title="0">{
                                logger.Warning("Failed to parse CPU steal stat: %v", err)
                        }</span>

                        <span class="cov0" title="0">return stat, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("cpu line not found in /proc/stat")</span>
}

func (c *SystemCollector) getMemoryInfo() (uint64, uint64, uint64, uint64, uint64, error) <span class="cov0" title="0">{
        file, err := os.Open("/proc/meminfo")
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, 0, 0, 0, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing meminfo file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">var memTotal, memFree, memBuffers, memCached uint64

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                fields := strings.Fields(line)
                if len(fields) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSuffix(fields[0], ":")
                value, _ := strconv.ParseUint(fields[1], 10, 64)
                value *= 1024 // Convert from KB to bytes

                switch key </span>{
                case "MemTotal":<span class="cov0" title="0">
                        memTotal = value</span>
                case "MemFree":<span class="cov0" title="0">
                        memFree = value</span>
                case "Buffers":<span class="cov0" title="0">
                        memBuffers = value</span>
                case "Cached":<span class="cov0" title="0">
                        memCached = value</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return 0, 0, 0, 0, 0, err
        }</span>

        // Calculate used memory (excluding buffers and cache)
        <span class="cov0" title="0">memUsed := memTotal - memFree - memBuffers - memCached
        // Calculate actual free (including buffers and cache)
        memActualFree := memFree + memBuffers + memCached

        return memUsed, memTotal, memActualFree, memBuffers, memCached, nil</span>
}

func (c *SystemCollector) getTemperatures() (map[string]float64, error) <span class="cov0" title="0">{
        // Try using sensors command first
        output, err := lib.ExecCommandOutput("sensors", "-u")
        if err == nil </span><span class="cov0" title="0">{
                temperatures := c.parseSensorsOutput(output)
                if len(temperatures) &gt; 0 </span><span class="cov0" title="0">{
                        return temperatures, nil
                }</span>
        }

        // Fallback: try reading from /sys/class/hwmon
        <span class="cov0" title="0">temperatures, err := c.readHwmonTemperatures()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return temperatures, nil</span>
}

func (c *SystemCollector) parseSensorsOutput(output string) map[string]float64 <span class="cov8" title="1">{
        temperatures := make(map[string]float64)
        lines := strings.Split(output, "\n")

        var currentChip string
        var currentLabel string
        for _, line := range lines </span><span class="cov8" title="1">{
                originalLine := line
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // New chip/adapter
                <span class="cov8" title="1">if !strings.Contains(line, ":") &amp;&amp; !strings.HasPrefix(originalLine, " ") </span><span class="cov8" title="1">{
                        currentChip = line
                        currentLabel = ""
                        continue</span>
                }

                // Sensor label (e.g., "MB Temp:", "Core 0:", "SYSTIN:")
                // These are lines that end with ":" and are not indented with spaces
                <span class="cov8" title="1">if strings.HasSuffix(line, ":") &amp;&amp; !strings.HasPrefix(originalLine, " ") &amp;&amp; !strings.Contains(line, "_") </span><span class="cov8" title="1">{
                        currentLabel = strings.TrimSuffix(line, ":")
                        continue</span>
                }

                // Temperature input line (indented with spaces)
                <span class="cov8" title="1">if strings.Contains(line, "_input:") &amp;&amp; currentChip != "" </span><span class="cov8" title="1">{
                        parts := strings.Split(line, ":")
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                key := strings.TrimSpace(parts[0])
                                valueStr := strings.TrimSpace(parts[1])
                                if value, err := strconv.ParseFloat(valueStr, 64); err == nil </span><span class="cov8" title="1">{
                                        // Create a friendly name using label if available, otherwise use key
                                        var name string
                                        if currentLabel != "" </span><span class="cov8" title="1">{
                                                name = fmt.Sprintf("%s_%s_%s", currentChip, currentLabel, key)
                                        }</span> else<span class="cov0" title="0"> {
                                                name = fmt.Sprintf("%s_%s", currentChip, key)
                                        }</span>
                                        <span class="cov8" title="1">name = strings.ReplaceAll(name, " ", "_")
                                        // sensors -u already outputs in degrees, no need to divide
                                        temperatures[name] = value</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return temperatures</span>
}

func (c *SystemCollector) readHwmonTemperatures() (map[string]float64, error) <span class="cov0" title="0">{
        temperatures := make(map[string]float64)

        // Read from /sys/class/hwmon/hwmon*/temp*_input
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                for j := 1; j &lt; 20; j++ </span><span class="cov0" title="0">{
                        path := fmt.Sprintf("/sys/class/hwmon/hwmon%d/temp%d_input", i, j)
                        //nolint:gosec // G304: Path is constructed from /sys/class/hwmon system directory with numeric indices
                        data, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">value, err := strconv.ParseFloat(strings.TrimSpace(string(data)), 64)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Try to get label
                        <span class="cov0" title="0">labelPath := fmt.Sprintf("/sys/class/hwmon/hwmon%d/temp%d_label", i, j)
                        //nolint:gosec // G304: Path is constructed from /sys/class/hwmon system directory with numeric indices
                        labelData, err := os.ReadFile(labelPath)
                        label := fmt.Sprintf("hwmon%d_temp%d", i, j)
                        if err == nil </span><span class="cov0" title="0">{
                                label = strings.TrimSpace(string(labelData))
                        }</span>

                        <span class="cov0" title="0">temperatures[label] = value / 1000.0</span> // Convert from millidegrees
                }
        }

        <span class="cov0" title="0">if len(temperatures) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no temperature sensors found")
        }</span>

        <span class="cov0" title="0">return temperatures, nil</span>
}

func (c *SystemCollector) getFans() ([]dto.FanInfo, error) <span class="cov0" title="0">{
        fanMap := make(map[string]int)

        // Try using sensors command first
        output, err := lib.ExecCommandOutput("sensors", "-u")
        if err == nil </span><span class="cov0" title="0">{
                fanMap = c.parseFanSpeeds(output)
        }</span>

        // If no fans found, try fallback
        <span class="cov0" title="0">if len(fanMap) == 0 </span><span class="cov0" title="0">{
                fanMap, err = c.readHwmonFanSpeeds()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Convert map to slice
        <span class="cov0" title="0">fans := make([]dto.FanInfo, 0, len(fanMap))
        for name, rpm := range fanMap </span><span class="cov0" title="0">{
                fans = append(fans, dto.FanInfo{
                        Name: name,
                        RPM:  rpm,
                })
        }</span>

        <span class="cov0" title="0">return fans, nil</span>
}

func (c *SystemCollector) parseFanSpeeds(output string) map[string]int <span class="cov8" title="1">{
        fanSpeeds := make(map[string]int)
        lines := strings.Split(output, "\n")

        var currentChip string
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // New chip/adapter
                <span class="cov8" title="1">if !strings.Contains(line, ":") &amp;&amp; !strings.HasPrefix(line, " ") </span><span class="cov8" title="1">{
                        currentChip = line
                        continue</span>
                }

                // Fan input line
                <span class="cov8" title="1">if strings.Contains(line, "fan") &amp;&amp; strings.Contains(line, "_input:") &amp;&amp; currentChip != "" </span><span class="cov8" title="1">{
                        parts := strings.Split(line, ":")
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                key := strings.TrimSpace(parts[0])
                                valueStr := strings.TrimSpace(parts[1])
                                if value, err := strconv.Atoi(valueStr); err == nil </span><span class="cov8" title="1">{
                                        name := fmt.Sprintf("%s_%s", currentChip, key)
                                        name = strings.ReplaceAll(name, " ", "_")
                                        fanSpeeds[name] = value
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return fanSpeeds</span>
}

func (c *SystemCollector) readHwmonFanSpeeds() (map[string]int, error) <span class="cov0" title="0">{
        fanSpeeds := make(map[string]int)

        // Read from /sys/class/hwmon/hwmon*/fan*_input
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                for j := 1; j &lt; 20; j++ </span><span class="cov0" title="0">{
                        path := fmt.Sprintf("/sys/class/hwmon/hwmon%d/fan%d_input", i, j)
                        //nolint:gosec // G304: Path is constructed from /sys/class/hwmon system directory with numeric indices
                        data, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">value, err := strconv.Atoi(strings.TrimSpace(string(data)))
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Try to get label
                        <span class="cov0" title="0">labelPath := fmt.Sprintf("/sys/class/hwmon/hwmon%d/fan%d_label", i, j)
                        //nolint:gosec // G304: Path is constructed from /sys/class/hwmon system directory with numeric indices
                        labelData, err := os.ReadFile(labelPath)
                        label := fmt.Sprintf("hwmon%d_fan%d", i, j)
                        if err == nil </span><span class="cov0" title="0">{
                                label = strings.TrimSpace(string(labelData))
                        }</span>

                        <span class="cov0" title="0">fanSpeeds[label] = value</span>
                }
        }

        <span class="cov0" title="0">if len(fanSpeeds) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no fan sensors found")
        }</span>

        <span class="cov0" title="0">return fanSpeeds, nil</span>
}

// getCPUSpecs reads CPU model, cores, threads, and frequency from /proc/cpuinfo
func (c *SystemCollector) getCPUSpecs() (string, int, int, float64) <span class="cov8" title="1">{
        file, err := os.Open("/proc/cpuinfo")
        if err != nil </span><span class="cov0" title="0">{
                return "Unknown", 0, 0, 0.0
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing cpuinfo file: %v", err)
                }</span>
        }()

        <span class="cov8" title="1">var cpuModel string
        var cpuMHz float64
        physicalIDs := make(map[string]bool)
        processors := 0

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                if strings.TrimSpace(line) == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                switch key </span>{
                case "model name":<span class="cov8" title="1">
                        if cpuModel == "" </span><span class="cov8" title="1">{
                                cpuModel = value
                        }</span>
                case "cpu MHz":<span class="cov8" title="1">
                        if mhz, err := strconv.ParseFloat(value, 64); err == nil &amp;&amp; cpuMHz == 0 </span><span class="cov8" title="1">{
                                cpuMHz = mhz
                        }</span>
                case "physical id":<span class="cov8" title="1">
                        physicalIDs[value] = true</span>
                case "processor":<span class="cov8" title="1">
                        processors++</span>
                }
        }

        <span class="cov8" title="1">cpuCores := len(physicalIDs)
        if cpuCores == 0 </span><span class="cov0" title="0">{
                cpuCores = 1 // Fallback to at least 1 core
        }</span>

        <span class="cov8" title="1">return cpuModel, cpuCores, processors, cpuMHz</span>
}

// getSystemHardwareInfo uses dmidecode to get server model and BIOS info
func (c *SystemCollector) getSystemHardwareInfo() (string, string, string) <span class="cov0" title="0">{
        var serverModel, biosVersion, biosDate string

        // Get system product name (server model)
        if output, err := lib.ExecCommandOutput("dmidecode", "-s", "system-product-name"); err == nil </span><span class="cov0" title="0">{
                serverModel = strings.TrimSpace(output)
        }</span>

        // Get BIOS version
        <span class="cov0" title="0">if output, err := lib.ExecCommandOutput("dmidecode", "-s", "bios-version"); err == nil </span><span class="cov0" title="0">{
                biosVersion = strings.TrimSpace(output)
        }</span>

        // Get BIOS release date
        <span class="cov0" title="0">if output, err := lib.ExecCommandOutput("dmidecode", "-s", "bios-release-date"); err == nil </span><span class="cov0" title="0">{
                biosDate = strings.TrimSpace(output)
        }</span>

        <span class="cov0" title="0">return serverModel, biosVersion, biosDate</span>
}

// getPerCoreCPUUsage calculates per-core CPU usage
func (c *SystemCollector) getPerCoreCPUUsage() (map[string]float64, error) <span class="cov0" title="0">{
        // Read first snapshot
        stat1, err := c.readPerCoreCPUStat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Wait a short time
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        // Read second snapshot
        stat2, err := c.readPerCoreCPUStat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate usage per core
        <span class="cov0" title="0">perCoreUsage := make(map[string]float64)
        for core, values1 := range stat1 </span><span class="cov0" title="0">{
                if values2, exists := stat2[core]; exists </span><span class="cov0" title="0">{
                        total1 := values1["user"] + values1["nice"] + values1["system"] + values1["idle"] + values1["iowait"] + values1["irq"] + values1["softirq"] + values1["steal"]
                        total2 := values2["user"] + values2["nice"] + values2["system"] + values2["idle"] + values2["iowait"] + values2["irq"] + values2["softirq"] + values2["steal"]

                        idle1 := values1["idle"] + values1["iowait"]
                        idle2 := values2["idle"] + values2["iowait"]

                        totalDelta := total2 - total1
                        idleDelta := idle2 - idle1

                        if totalDelta &gt; 0 </span><span class="cov0" title="0">{
                                usage := (float64(totalDelta-idleDelta) / float64(totalDelta)) * 100
                                perCoreUsage[core] = usage
                        }</span>
                }
        }

        <span class="cov0" title="0">return perCoreUsage, nil</span>
}

// readPerCoreCPUStat reads CPU statistics for each core from /proc/stat
func (c *SystemCollector) readPerCoreCPUStat() (map[string]map[string]uint64, error) <span class="cov0" title="0">{
        file, err := os.Open("/proc/stat")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Error closing per-core CPU stat file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">coreStats := make(map[string]map[string]uint64)
        scanner := bufio.NewScanner(file)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                // Look for lines starting with "cpu" followed by a number (cpu0, cpu1, etc.)
                if strings.HasPrefix(line, "cpu") &amp;&amp; len(line) &gt; 3 </span><span class="cov0" title="0">{
                        fields := strings.Fields(line)
                        if len(fields) &lt; 9 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">coreName := fields[0]
                        // Skip the aggregate "cpu" line
                        if coreName == "cpu" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">stat := make(map[string]uint64)
                        var parseErr error
                        if stat["user"], parseErr = strconv.ParseUint(fields[1], 10, 64); parseErr != nil </span><span class="cov0" title="0">{
                                logger.Debug("Failed to parse per-core CPU user stat for %s: %v", coreName, parseErr)
                        }</span>
                        <span class="cov0" title="0">if stat["nice"], parseErr = strconv.ParseUint(fields[2], 10, 64); parseErr != nil </span><span class="cov0" title="0">{
                                logger.Debug("Failed to parse per-core CPU nice stat for %s: %v", coreName, parseErr)
                        }</span>
                        <span class="cov0" title="0">if stat["system"], parseErr = strconv.ParseUint(fields[3], 10, 64); parseErr != nil </span><span class="cov0" title="0">{
                                logger.Debug("Failed to parse per-core CPU system stat for %s: %v", coreName, parseErr)
                        }</span>
                        <span class="cov0" title="0">if stat["idle"], parseErr = strconv.ParseUint(fields[4], 10, 64); parseErr != nil </span><span class="cov0" title="0">{
                                logger.Debug("Failed to parse per-core CPU idle stat for %s: %v", coreName, parseErr)
                        }</span>
                        <span class="cov0" title="0">if stat["iowait"], parseErr = strconv.ParseUint(fields[5], 10, 64); parseErr != nil </span><span class="cov0" title="0">{
                                logger.Debug("Failed to parse per-core CPU iowait stat for %s: %v", coreName, parseErr)
                        }</span>
                        <span class="cov0" title="0">if stat["irq"], parseErr = strconv.ParseUint(fields[6], 10, 64); parseErr != nil </span><span class="cov0" title="0">{
                                logger.Debug("Failed to parse per-core CPU irq stat for %s: %v", coreName, parseErr)
                        }</span>
                        <span class="cov0" title="0">if stat["softirq"], parseErr = strconv.ParseUint(fields[7], 10, 64); parseErr != nil </span><span class="cov0" title="0">{
                                logger.Debug("Failed to parse per-core CPU softirq stat for %s: %v", coreName, parseErr)
                        }</span>
                        <span class="cov0" title="0">if stat["steal"], parseErr = strconv.ParseUint(fields[8], 10, 64); parseErr != nil </span><span class="cov0" title="0">{
                                logger.Debug("Failed to parse per-core CPU steal stat for %s: %v", coreName, parseErr)
                        }</span>

                        <span class="cov0" title="0">coreStats[coreName] = stat</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(coreStats) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no per-core CPU stats found")
        }</span>

        <span class="cov0" title="0">return coreStats, nil</span>
}

// isHVMEnabled checks if hardware virtualization (HVM) is enabled
// Checks for vmx (Intel) or svm (AMD) flags in /proc/cpuinfo
func (c *SystemCollector) isHVMEnabled() bool <span class="cov8" title="1">{
        data, err := os.ReadFile("/proc/cpuinfo")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">content := string(data)
        // Check for Intel VT-x (vmx) or AMD-V (svm)
        return strings.Contains(content, " vmx ") || strings.Contains(content, " svm ")</span>
}

// isIOMMUEnabled checks if IOMMU is enabled
// Checks kernel command line and /sys/class/iommu/
func (c *SystemCollector) isIOMMUEnabled() bool <span class="cov8" title="1">{
        // Check kernel command line for IOMMU parameters
        cmdline, err := os.ReadFile("/proc/cmdline")
        if err == nil </span><span class="cov8" title="1">{
                content := string(cmdline)
                if strings.Contains(content, "intel_iommu=on") || strings.Contains(content, "amd_iommu=on") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check if /sys/class/iommu/ exists and has entries
        <span class="cov8" title="1">entries, err := os.ReadDir("/sys/class/iommu")
        if err == nil &amp;&amp; len(entries) &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// getOpenSSLVersion gets the OpenSSL version
func (c *SystemCollector) getOpenSSLVersion() string <span class="cov8" title="1">{
        output, err := lib.ExecCommandOutput("openssl", "version")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(output)</span>
}

// getKernelVersion gets the kernel version
func (c *SystemCollector) getKernelVersion() string <span class="cov8" title="1">{
        output, err := lib.ExecCommandOutput("uname", "-r")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(output)</span>
}

// getUnraidVersion gets the Unraid OS version
func (c *SystemCollector) getUnraidVersion() string <span class="cov0" title="0">{
        // Try reading from /etc/unraid-version first
        data, err := os.ReadFile("/etc/unraid-version")
        if err == nil </span><span class="cov0" title="0">{
                content := strings.TrimSpace(string(data))
                // The file contains version="7.2.0" format
                if strings.HasPrefix(content, "version=") </span><span class="cov0" title="0">{
                        version := strings.TrimPrefix(content, "version=")
                        version = strings.Trim(version, "\"")
                        return version
                }</span>
                // If it's just the version number without the prefix
                <span class="cov0" title="0">return content</span>
        }

        // Fallback: try reading from /var/local/emhttp/var.ini
        <span class="cov0" title="0">varIniPath := "/var/local/emhttp/var.ini"
        varIniData, err := os.ReadFile(varIniPath)
        if err == nil </span><span class="cov0" title="0">{
                lines := strings.Split(string(varIniData), "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        line = strings.TrimSpace(line)
                        if strings.HasPrefix(line, "version=") </span><span class="cov0" title="0">{
                                version := strings.TrimPrefix(line, "version=")
                                version = strings.Trim(version, "\"")
                                return version
                        }</span>
                }
        }

        // If all else fails, return empty string
        <span class="cov0" title="0">return ""</span>
}

// getParityCheckSpeed gets the parity check speed from var.ini
func (c *SystemCollector) getParityCheckSpeed() string <span class="cov0" title="0">{
        // Try to read from /var/local/emhttp/var.ini
        data, err := os.ReadFile("/var/local/emhttp/var.ini")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Parse for sbSynced line which contains parity check speed
        <span class="cov0" title="0">lines := strings.Split(string(data), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(line, "sbSynced=") </span><span class="cov0" title="0">{
                        // Extract the speed part (e.g., "18645 MB/s + 38044 MB/s")
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                value := strings.Trim(parts[1], "\"")
                                // Look for the speed pattern
                                if strings.Contains(value, "MB/s") </span><span class="cov0" title="0">{
                                        return value
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package collectors

import (
        "context"
        "encoding/json"
        "os"
        "os/exec"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// UnassignedCollector collects information about unassigned devices
type UnassignedCollector struct {
        ctx *domain.Context
}

// NewUnassignedCollector creates a new unassigned devices collector
func NewUnassignedCollector(ctx *domain.Context) *UnassignedCollector <span class="cov8" title="1">{
        return &amp;UnassignedCollector{ctx: ctx}
}</span>

// Start begins collecting unassigned device information
func (c *UnassignedCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("Unassigned collector panic: %v", r)
                }</span>
        }()

        <span class="cov0" title="0">logger.Info("Starting unassigned devices collector (interval: %v)", interval)

        // Initial collection
        c.collect()

        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Stopping unassigned devices collector")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.collect()</span>
                }
        }
}

// collect gathers unassigned device information
func (c *UnassignedCollector) collect() <span class="cov0" title="0">{
        devices := c.collectUnassignedDevices()
        remoteShares := c.collectRemoteShares()

        deviceList := &amp;dto.UnassignedDeviceList{
                Devices:      devices,
                RemoteShares: remoteShares,
                Timestamp:    time.Now(),
        }

        // Publish event
        c.ctx.Hub.Pub(deviceList, "unassigned_devices_update")
        logger.Debug("Published unassigned devices update - devices=%d, remote_shares=%d",
                len(devices), len(remoteShares))
}</span>

// collectUnassignedDevices discovers and collects unassigned disk devices
func (c *UnassignedCollector) collectUnassignedDevices() []dto.UnassignedDevice <span class="cov0" title="0">{
        // Check if plugin is installed
        if !c.isPluginInstalled() </span><span class="cov0" title="0">{
                logger.Debug("Unassigned Devices plugin not installed")
                return []dto.UnassignedDevice{}
        }</span>

        // Get array disks to filter them out
        <span class="cov0" title="0">arrayDisks := c.getArrayDisks()

        // Get all block devices
        allDevices := c.getAllBlockDevices()

        var unassignedDevices []dto.UnassignedDevice
        for _, device := range allDevices </span><span class="cov0" title="0">{
                // Skip if it's an array disk
                if c.isArrayDisk(device, arrayDisks) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip loop devices, md devices, zram, and partitions
                <span class="cov0" title="0">if strings.HasPrefix(device, "loop") ||
                        strings.HasPrefix(device, "md") ||
                        strings.HasPrefix(device, "zram") ||
                        strings.Contains(device, "nvme0n1p") ||
                        (len(device) &gt; 3 &amp;&amp; device[3] &gt;= '1' &amp;&amp; device[3] &lt;= '9') </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">unassignedDevice := c.getDeviceInfo(device)
                if unassignedDevice != nil </span><span class="cov0" title="0">{
                        unassignedDevices = append(unassignedDevices, *unassignedDevice)
                }</span>
        }

        <span class="cov0" title="0">return unassignedDevices</span>
}

// collectRemoteShares collects remote SMB/NFS/ISO shares
func (c *UnassignedCollector) collectRemoteShares() []dto.UnassignedRemoteShare <span class="cov0" title="0">{
        if !c.isPluginInstalled() </span><span class="cov0" title="0">{
                return []dto.UnassignedRemoteShare{}
        }</span>

        <span class="cov0" title="0">var shares []dto.UnassignedRemoteShare

        // Parse SMB mounts
        smbShares := c.parseSMBMounts()
        shares = append(shares, smbShares...)

        // Parse ISO mounts
        isoShares := c.parseISOMounts()
        shares = append(shares, isoShares...)

        return shares</span>
}

// isPluginInstalled checks if the Unassigned Devices plugin is installed
func (c *UnassignedCollector) isPluginInstalled() bool <span class="cov0" title="0">{
        _, err := os.Stat("/boot/config/plugins/unassigned.devices")
        return err == nil
}</span>

// getArrayDisks returns a map of array disk devices
func (c *UnassignedCollector) getArrayDisks() map[string]bool <span class="cov0" title="0">{
        arrayDisks := make(map[string]bool)

        // Read disks.ini file directly
        data, err := os.ReadFile("/var/local/emhttp/disks.ini")
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to read disks.ini: %v", err)
                return arrayDisks
        }</span>

        // Parse the INI file to extract device names
        <span class="cov0" title="0">lines := strings.Split(string(data), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if device, found := strings.CutPrefix(line, "device="); found </span><span class="cov0" title="0">{
                        device = strings.Trim(device, "\"")
                        if device != "" </span><span class="cov0" title="0">{
                                arrayDisks[device] = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return arrayDisks</span>
}

// getAllBlockDevices returns a list of all block device names
func (c *UnassignedCollector) getAllBlockDevices() []string <span class="cov0" title="0">{
        cmd := exec.Command("lsblk", "-d", "-n", "-o", "NAME")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to list block devices: %v", err)
                return []string{}
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        return lines</span>
}

// isArrayDisk checks if a device is part of the Unraid array
func (c *UnassignedCollector) isArrayDisk(device string, arrayDisks map[string]bool) bool <span class="cov0" title="0">{
        return arrayDisks[device]
}</span>

// getDeviceInfo retrieves detailed information about a device
func (c *UnassignedCollector) getDeviceInfo(device string) *dto.UnassignedDevice <span class="cov0" title="0">{
        // Get device info using lsblk
        cmd := exec.Command("lsblk", "-J", "-o", "NAME,SIZE,TYPE,MOUNTPOINT,FSTYPE,LABEL,SERIAL,MODEL", "/dev/"+device) // #nosec G204 - device is validated from lsblk output
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to get info for device %s: %v", device, err)
                return nil
        }</span>

        <span class="cov0" title="0">var lsblkOutput struct {
                BlockDevices []struct {
                        Name       string `json:"name"`
                        Size       string `json:"size"`
                        Type       string `json:"type"`
                        MountPoint string `json:"mountpoint"`
                        FSType     string `json:"fstype"`
                        Label      string `json:"label"`
                        Serial     string `json:"serial"`
                        Model      string `json:"model"`
                        Children   []struct {
                                Name       string `json:"name"`
                                Size       string `json:"size"`
                                Type       string `json:"type"`
                                MountPoint string `json:"mountpoint"`
                                FSType     string `json:"fstype"`
                                Label      string `json:"label"`
                        } `json:"children"`
                } `json:"blockdevices"`
        }

        if err := json.Unmarshal(output, &amp;lsblkOutput); err != nil </span><span class="cov0" title="0">{
                logger.Debug("Failed to parse lsblk output for %s: %v", device, err)
                return nil
        }</span>

        <span class="cov0" title="0">if len(lsblkOutput.BlockDevices) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">blockDev := lsblkOutput.BlockDevices[0]

        unassignedDevice := &amp;dto.UnassignedDevice{
                Device:         blockDev.Name,
                SerialNumber:   blockDev.Serial,
                Model:          blockDev.Model,
                Identification: blockDev.Model,
                Status:         "unmounted",
                SpinState:      "unknown",
                AutoMount:      false,
                PassThrough:    false,
                DisableMount:   false,
                ScriptEnabled:  false,
                Timestamp:      time.Now(),
        }

        // Process partitions
        var partitions []dto.UnassignedPartition
        for i, child := range blockDev.Children </span><span class="cov0" title="0">{
                partition := dto.UnassignedPartition{
                        PartitionNumber: i + 1,
                        Label:           child.Label,
                        FileSystem:      child.FSType,
                        MountPoint:      child.MountPoint,
                        ReadOnly:        false,
                        SMBShare:        false,
                        NFSShare:        false,
                        Status:          "unmounted",
                }

                if child.MountPoint != "" </span><span class="cov0" title="0">{
                        partition.Status = "mounted"
                        unassignedDevice.Status = "mounted"

                        // Get partition size info if mounted
                        c.getPartitionSizeInfo(&amp;partition, child.MountPoint)
                }</span>

                <span class="cov0" title="0">partitions = append(partitions, partition)</span>
        }

        <span class="cov0" title="0">unassignedDevice.Partitions = partitions

        return unassignedDevice</span>
}

// getPartitionSizeInfo retrieves size information for a mounted partition
func (c *UnassignedCollector) getPartitionSizeInfo(partition *dto.UnassignedPartition, mountPoint string) <span class="cov0" title="0">{
        cmd := exec.Command("df", "-B1", mountPoint)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        if len(lines) &lt; 2 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fields := strings.Fields(lines[1])
        if len(fields) &lt; 6 </span><span class="cov0" title="0">{
                return
        }</span>

        // Parse size, used, free
        <span class="cov0" title="0">size := lib.ParseUint64(fields[1])
        used := lib.ParseUint64(fields[2])
        free := lib.ParseUint64(fields[3])

        partition.Size = size
        partition.Used = used
        partition.Free = free

        // Calculate usage percent
        if size &gt; 0 </span><span class="cov0" title="0">{
                partition.UsagePercent = float64(used) / float64(size) * 100.0
        }</span>
}

// parseSMBMounts parses SMB mount configuration
func (c *UnassignedCollector) parseSMBMounts() []dto.UnassignedRemoteShare <span class="cov0" title="0">{
        configPath := "/boot/config/plugins/unassigned.devices/samba_mount.cfg"
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return []dto.UnassignedRemoteShare{}
        }</span>

        // For now, return empty list - full implementation would parse the config file
        <span class="cov0" title="0">return []dto.UnassignedRemoteShare{}</span>
}

// parseISOMounts parses ISO mount configuration
func (c *UnassignedCollector) parseISOMounts() []dto.UnassignedRemoteShare <span class="cov0" title="0">{
        configPath := "/boot/config/plugins/unassigned.devices/iso_mount.cfg"
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return []dto.UnassignedRemoteShare{}
        }</span>

        // Check if any ISO files are mounted
        <span class="cov0" title="0">mounts, err := os.ReadFile("/proc/mounts")
        if err != nil </span><span class="cov0" title="0">{
                return []dto.UnassignedRemoteShare{}
        }</span>

        <span class="cov0" title="0">var isoShares []dto.UnassignedRemoteShare
        lines := strings.Split(string(mounts), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                fields := strings.Fields(line)
                if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if it's an ISO mount (loop device mounted under /mnt/disks/)
                <span class="cov0" title="0">if strings.HasPrefix(fields[0], "/dev/loop") &amp;&amp; strings.HasPrefix(fields[1], "/mnt/disks/") </span><span class="cov0" title="0">{
                        share := dto.UnassignedRemoteShare{
                                Type:       "iso",
                                Source:     fields[0],
                                MountPoint: fields[1],
                                Status:     "mounted",
                                ReadOnly:   true,
                                AutoMount:  false,
                                Timestamp:  time.Now(),
                        }

                        // Get size info
                        c.getRemoteShareSizeInfo(&amp;share, fields[1])

                        isoShares = append(isoShares, share)
                }</span>
        }

        <span class="cov0" title="0">return isoShares</span>
}

// getRemoteShareSizeInfo retrieves size information for a remote share
func (c *UnassignedCollector) getRemoteShareSizeInfo(share *dto.UnassignedRemoteShare, mountPoint string) <span class="cov0" title="0">{
        cmd := exec.Command("df", "-B1", mountPoint)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        if len(lines) &lt; 2 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">fields := strings.Fields(lines[1])
        if len(fields) &lt; 6 </span><span class="cov0" title="0">{
                return
        }</span>

        // Parse size, used, free
        <span class="cov0" title="0">size := lib.ParseUint64(fields[1])
        used := lib.ParseUint64(fields[2])
        free := lib.ParseUint64(fields[3])

        share.Size = size
        share.Used = used
        share.Free = free

        // Calculate usage percent
        if size &gt; 0 </span><span class="cov0" title="0">{
                share.UsagePercent = float64(used) / float64(size) * 100.0
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package collectors

import (
        "context"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// UPSCollector collects UPS (Uninterruptible Power Supply) status information.
// It supports both apcupsd and NUT (Network UPS Tools) monitoring systems.
type UPSCollector struct {
        ctx *domain.Context
}

// NewUPSCollector creates a new UPS status collector with the given context.
func NewUPSCollector(ctx *domain.Context) *UPSCollector <span class="cov8" title="1">{
        return &amp;UPSCollector{ctx: ctx}
}</span>

// Start begins the UPS collector's periodic data collection.
// It runs in a goroutine and publishes UPS status updates at the specified interval until the context is cancelled.
func (c *UPSCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting ups collector (interval: %v)", interval)
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("UPS collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.Collect()</span>
                }
        }
}

// Collect gathers UPS status information and publishes it to the event bus.
// It attempts to collect data from apcupsd first, then falls back to NUT if apcupsd is not available.
func (c *UPSCollector) Collect() <span class="cov0" title="0">{

        logger.Debug("Collecting ups data...")

        // Try apcaccess first (APC UPS)
        var upsData *dto.UPSStatus
        var err error

        if lib.CommandExists("apcaccess") </span><span class="cov0" title="0">{
                upsData, err = c.collectAPC()
                if err == nil </span><span class="cov0" title="0">{
                        c.ctx.Hub.Pub(upsData, "ups_status_update")
                        logger.Debug("Published ups_status_update event (APC)")
                        return
                }</span>
                <span class="cov0" title="0">logger.Warning("Failed to collect APC UPS data", "error", err)</span>
        }

        // Fallback to upsc (NUT - Network UPS Tools)
        <span class="cov0" title="0">if lib.CommandExists("upsc") </span><span class="cov0" title="0">{
                upsData, err = c.collectNUT()
                if err == nil </span><span class="cov0" title="0">{
                        c.ctx.Hub.Pub(upsData, "ups_status_update")
                        logger.Debug("Published ups_status_update event (NUT)")
                        return
                }</span>
                <span class="cov0" title="0">logger.Warning("Failed to collect NUT UPS data", "error", err)</span>
        }

        // No UPS available
        <span class="cov0" title="0">logger.Debug("No UPS detected or configured")</span>
}

func (c *UPSCollector) collectAPC() (*dto.UPSStatus, error) <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("apcaccess")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status := &amp;dto.UPSStatus{
                Connected: true,
                Timestamp: time.Now(),
        }

        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                switch key </span>{
                case "STATUS":<span class="cov0" title="0">
                        status.Status = value</span>
                case "LOADPCT":<span class="cov0" title="0">
                        if strings.HasSuffix(value, "Percent") </span><span class="cov0" title="0">{
                                value = strings.TrimSuffix(value, " Percent")
                        }</span>
                        <span class="cov0" title="0">if load, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.LoadPercent = load
                        }</span>
                case "BCHARGE":<span class="cov0" title="0">
                        if strings.HasSuffix(value, "Percent") </span><span class="cov0" title="0">{
                                value = strings.TrimSuffix(value, " Percent")
                        }</span>
                        <span class="cov0" title="0">if charge, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryCharge = charge
                        }</span>
                case "TIMELEFT":<span class="cov0" title="0">
                        if strings.HasSuffix(value, "Minutes") </span><span class="cov0" title="0">{
                                value = strings.TrimSuffix(value, " Minutes")
                        }</span>
                        <span class="cov0" title="0">if minutes, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.RuntimeLeft = int(minutes * 60) // Convert minutes to seconds
                        }</span>
                case "NOMPOWER":<span class="cov0" title="0">
                        // Parse nominal power (e.g., "800 Watts")
                        if strings.HasSuffix(value, "Watts") </span><span class="cov0" title="0">{
                                value = strings.TrimSuffix(value, " Watts")
                        }</span>
                        <span class="cov0" title="0">if power, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.NominalPower = power
                        }</span>
                case "LINEV":<span class="cov0" title="0">
                        if strings.HasSuffix(value, "Volts") </span><span class="cov0" title="0">{
                                value = strings.TrimSuffix(value, " Volts")
                        }</span>
                        // InputVoltage field not in DTO, parsing for potential future use
                        <span class="cov0" title="0">_, _ = strconv.ParseFloat(value, 64)</span>
                case "BATTV":<span class="cov0" title="0">
                        if strings.HasSuffix(value, "Volts") </span><span class="cov0" title="0">{
                                value = strings.TrimSuffix(value, " Volts")
                        }</span>
                        // BatteryVoltage field not in DTO, parsing for potential future use
                        <span class="cov0" title="0">_, _ = strconv.ParseFloat(value, 64)</span>
                case "MODEL":<span class="cov0" title="0">
                        status.Model = value</span>
                }
        }

        // Calculate actual power consumption from load percentage and nominal power
        <span class="cov0" title="0">if status.NominalPower &gt; 0 &amp;&amp; status.LoadPercent &gt; 0 </span><span class="cov0" title="0">{
                status.PowerWatts = status.NominalPower * status.LoadPercent / 100.0
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

func (c *UPSCollector) collectNUT() (*dto.UPSStatus, error) <span class="cov0" title="0">{
        // First, get list of UPS devices (try localhost first, then without host)
        output, err := lib.ExecCommandOutput("upsc", "-l", "localhost")
        if err != nil </span><span class="cov0" title="0">{
                output, err = lib.ExecCommandOutput("upsc", "-l")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">devices := strings.Split(strings.TrimSpace(output), "\n")
        if len(devices) == 0 || devices[0] == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no UPS devices found")
        }</span>

        // Use first device with @localhost suffix for NUT protocol
        <span class="cov0" title="0">device := devices[0] + "@localhost"

        // Get device status
        output, err = lib.ExecCommandOutput("upsc", device)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">status := &amp;dto.UPSStatus{
                Connected: true,
                Timestamp: time.Now(),
        }

        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                switch key </span>{
                case "ups.status":<span class="cov0" title="0">
                        status.Status = value</span>
                case "ups.load":<span class="cov0" title="0">
                        if load, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.LoadPercent = load
                        }</span>
                case "battery.charge":<span class="cov0" title="0">
                        if charge, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.BatteryCharge = charge
                        }</span>
                case "battery.runtime":<span class="cov0" title="0">
                        if seconds, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.RuntimeLeft = int(seconds) // Already in seconds
                        }</span>
                case "ups.power.nominal", "ups.realpower.nominal":<span class="cov0" title="0">
                        // Parse nominal power (usually in Watts)
                        if power, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                status.NominalPower = power
                        }</span>
                case "input.voltage":<span class="cov0" title="0">
                        // InputVoltage field not in DTO, parsing for potential future use
                        _, _ = strconv.ParseFloat(value, 64)</span>
                case "battery.voltage":<span class="cov0" title="0">
                        // BatteryVoltage field not in DTO, parsing for potential future use
                        _, _ = strconv.ParseFloat(value, 64)</span>
                case "device.model", "ups.model":<span class="cov0" title="0">
                        status.Model = value</span>
                }
        }

        // Calculate actual power consumption from load percentage and nominal power
        <span class="cov0" title="0">if status.NominalPower &gt; 0 &amp;&amp; status.LoadPercent &gt; 0 </span><span class="cov0" title="0">{
                status.PowerWatts = status.NominalPower * status.LoadPercent / 100.0
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package collectors

import (
        "context"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// cpuStats holds CPU usage tracking data for a VM
type cpuStats struct {
        guestCPUTime uint64    // Cumulative guest CPU time in nanoseconds
        hostCPUTime  uint64    // Cumulative host CPU time in clock ticks
        timestamp    time.Time // When this measurement was taken
}

// VMCollector collects information about virtual machines managed by libvirt/virsh.
// It gathers VM status, resource allocation, CPU usage, and configuration details.
type VMCollector struct {
        ctx           *domain.Context
        cpuStatsMutex sync.RWMutex
        previousStats map[string]*cpuStats // vmName -&gt; previous CPU stats
}

// NewVMCollector creates a new virtual machine collector with the given context.
func NewVMCollector(ctx *domain.Context) *VMCollector <span class="cov8" title="1">{
        return &amp;VMCollector{
                ctx:           ctx,
                previousStats: make(map[string]*cpuStats),
        }
}</span>

// Start begins the VM collector's periodic data collection.
// It runs in a goroutine and publishes VM information updates at the specified interval until the context is cancelled.
func (c *VMCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        logger.Info("Starting vm collector (interval: %v)", interval)
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("VM collector stopping due to context cancellation")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.Collect()</span>
                }
        }
}

// Collect gathers virtual machine information and publishes it to the event bus.
// It uses virsh to query VM status and calculates CPU usage based on previous measurements.
func (c *VMCollector) Collect() <span class="cov0" title="0">{

        logger.Debug("Collecting vm data...")

        // Check if virsh is available
        if !lib.CommandExists("virsh") </span><span class="cov0" title="0">{
                logger.Warning("virsh command not found, skipping collection")
                return
        }</span>

        // Collect VM information
        <span class="cov0" title="0">vms, err := c.collectVMs()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to collect VMs: %v", err)
                return
        }</span>

        // Publish event
        <span class="cov0" title="0">c.ctx.Hub.Pub(vms, "vm_list_update")
        logger.Debug("Published vm_list_update event with %d VMs", len(vms))</span>
}

func (c *VMCollector) collectVMs() ([]*dto.VMInfo, error) <span class="cov0" title="0">{
        // Get list of all VM names (one per line)
        // This approach handles VM names with spaces correctly
        output, err := lib.ExecCommandOutput("virsh", "list", "--all", "--name")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list VMs: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(output, "\n")
        vms := make([]*dto.VMInfo, 0)

        for _, line := range lines </span><span class="cov0" title="0">{
                vmName := strings.TrimSpace(line)
                if vmName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get VM state
                <span class="cov0" title="0">vmState, err := c.getVMState(vmName)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warning("Failed to get state for VM %s: %v", vmName, err)
                        continue</span>
                }

                // Get VM UUID (stable identifier for all VM states)
                <span class="cov0" title="0">vmID := c.getVMID(vmName)

                vm := &amp;dto.VMInfo{
                        ID:        vmID,
                        Name:      vmName,
                        State:     vmState,
                        Timestamp: time.Now(),
                }

                // Get detailed info for this VM
                if info, err := c.getVMInfo(vmName); err == nil </span><span class="cov0" title="0">{
                        vm.CPUCount = info.CPUCount
                        vm.MemoryAllocated = info.MemoryAllocated
                        vm.Autostart = info.Autostart
                        vm.PersistentState = info.PersistentState
                }</span>

                // Get memory usage if running
                <span class="cov0" title="0">if strings.Contains(strings.ToLower(vmState), "running") </span><span class="cov0" title="0">{
                        if memUsed, err := c.getVMMemoryUsage(vmName); err == nil </span><span class="cov0" title="0">{
                                vm.MemoryUsed = memUsed
                        }</span>

                        // Get CPU usage (pass number of vCPUs for percentage calculation)
                        <span class="cov0" title="0">if vm.CPUCount &gt; 0 </span><span class="cov0" title="0">{
                                if guestCPU, hostCPU, err := c.getVMCPUUsage(vmName, vm.CPUCount); err == nil </span><span class="cov0" title="0">{
                                        vm.GuestCPUPercent = guestCPU
                                        vm.HostCPUPercent = hostCPU
                                }</span> else<span class="cov0" title="0"> {
                                        logger.Debug("Failed to get CPU usage for VM %s: %v", vmName, err)
                                }</span>
                        }

                        // Get disk I/O stats
                        <span class="cov0" title="0">if readBytes, writeBytes, err := c.getVMDiskIO(vmName); err == nil </span><span class="cov0" title="0">{
                                vm.DiskReadBytes = readBytes
                                vm.DiskWriteBytes = writeBytes
                        }</span>

                        // Get network I/O stats
                        <span class="cov0" title="0">if rxBytes, txBytes, err := c.getVMNetworkIO(vmName); err == nil </span><span class="cov0" title="0">{
                                vm.NetworkRXBytes = rxBytes
                                vm.NetworkTXBytes = txBytes
                        }</span>
                } else<span class="cov0" title="0"> {
                        // VM is not running, clear CPU stats history
                        c.clearCPUStats(vmName)
                }</span>

                // Format memory display
                <span class="cov0" title="0">vm.MemoryDisplay = c.formatMemoryDisplay(vm.MemoryUsed, vm.MemoryAllocated)

                vms = append(vms, vm)</span>
        }

        <span class="cov0" title="0">return vms, nil</span>
}

// clearCPUStats removes CPU stats history for a VM (called when VM is shut off)
func (c *VMCollector) clearCPUStats(vmName string) <span class="cov0" title="0">{
        c.cpuStatsMutex.Lock()
        defer c.cpuStatsMutex.Unlock()
        delete(c.previousStats, vmName)
}</span>

type vmInfo struct {
        CPUCount        int
        MemoryAllocated uint64
        Autostart       bool
        PersistentState bool
}

// getVMState returns the state of a VM (e.g., "running", "shut off", "paused")
func (c *VMCollector) getVMState(vmName string) (string, error) <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("virsh", "domstate", vmName)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get VM state: %w", err)
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(output), nil</span>
}

// getVMID returns the UUID of a VM (stable identifier that works for all VM states)
func (c *VMCollector) getVMID(vmName string) string <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("virsh", "domuuid", vmName)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to using VM name as ID if UUID is not available
                return vmName
        }</span>
        <span class="cov0" title="0">uuid := strings.TrimSpace(output)
        if uuid == "" </span><span class="cov0" title="0">{
                // Fallback to using VM name as ID
                return vmName
        }</span>
        <span class="cov0" title="0">return uuid</span>
}

func (c *VMCollector) getVMInfo(vmName string) (*vmInfo, error) <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("virsh", "dominfo", vmName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">info := &amp;vmInfo{}
        lines := strings.Split(output, "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                switch key </span>{
                case "CPU(s)":<span class="cov0" title="0">
                        if cpu, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                info.CPUCount = cpu
                        }</span>
                case "Max memory":<span class="cov0" title="0">
                        // Value is in KiB
                        // Extract number before " KiB"
                        if memStr := strings.Fields(value); len(memStr) &gt; 0 </span><span class="cov0" title="0">{
                                if mem, err := strconv.ParseUint(memStr[0], 10, 64); err == nil </span><span class="cov0" title="0">{
                                        info.MemoryAllocated = mem * 1024 // Convert KiB to bytes
                                }</span>
                        }
                case "Autostart":<span class="cov0" title="0">
                        info.Autostart = strings.ToLower(value) == "enable"</span>
                case "Persistent":<span class="cov0" title="0">
                        info.PersistentState = strings.ToLower(value) == "yes"</span>
                }
        }

        <span class="cov0" title="0">return info, nil</span>
}

func (c *VMCollector) getVMMemoryUsage(vmName string) (uint64, error) <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("virsh", "dommemstat", vmName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Parse output for actual memory usage
        // Format: "actual 4194304" (in KiB)
        <span class="cov0" title="0">re := regexp.MustCompile(`actual\s+(\d+)`)
        if matches := re.FindStringSubmatch(output); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                if mem, err := strconv.ParseUint(matches[1], 10, 64); err == nil </span><span class="cov0" title="0">{
                        return mem * 1024, nil // Convert KiB to bytes
                }</span>
        }

        // Fallback: look for rss (resident set size)
        <span class="cov0" title="0">re = regexp.MustCompile(`rss\s+(\d+)`)
        if matches := re.FindStringSubmatch(output); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                if mem, err := strconv.ParseUint(matches[1], 10, 64); err == nil </span><span class="cov0" title="0">{
                        return mem * 1024, nil // Convert KiB to bytes
                }</span>
        }

        <span class="cov0" title="0">return 0, nil</span>
}

// getVMCPUUsage returns guest and host CPU usage percentages
func (c *VMCollector) getVMCPUUsage(vmName string, numVCPUs int) (float64, float64, error) <span class="cov0" title="0">{
        currentTime := time.Now()

        // Get guest CPU time from virsh domstats
        guestCPUTime, err := c.getGuestCPUTime(vmName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("failed to get guest CPU time: %w", err)
        }</span>

        // Get host CPU time from QEMU process
        <span class="cov0" title="0">hostCPUTime, err := c.getHostCPUTime(vmName)
        if err != nil </span><span class="cov0" title="0">{
                // Host CPU might not be available, log but don't fail
                logger.Debug("Failed to get host CPU time for VM %s: %v", vmName, err)
                hostCPUTime = 0
        }</span>

        // Calculate percentages using historical data
        <span class="cov0" title="0">c.cpuStatsMutex.Lock()
        defer c.cpuStatsMutex.Unlock()

        var guestCPUPercent, hostCPUPercent float64

        if prevStats, exists := c.previousStats[vmName]; exists </span><span class="cov0" title="0">{
                // Calculate time delta in seconds
                timeDelta := currentTime.Sub(prevStats.timestamp).Seconds()

                if timeDelta &gt; 0 </span><span class="cov0" title="0">{
                        // Calculate guest CPU percentage
                        // Guest CPU time is in nanoseconds, convert to seconds
                        guestCPUDelta := float64(guestCPUTime-prevStats.guestCPUTime) / 1e9
                        guestCPUPercent = (guestCPUDelta / timeDelta / float64(numVCPUs)) * 100

                        // Clamp to valid range [0, 100]
                        if guestCPUPercent &lt; 0 </span><span class="cov0" title="0">{
                                guestCPUPercent = 0
                        }</span> else<span class="cov0" title="0"> if guestCPUPercent &gt; 100 </span><span class="cov0" title="0">{
                                guestCPUPercent = 100
                        }</span>

                        // Calculate host CPU percentage if available
                        <span class="cov0" title="0">if hostCPUTime &gt; 0 &amp;&amp; prevStats.hostCPUTime &gt; 0 </span><span class="cov0" title="0">{
                                // Host CPU time is in clock ticks, need to convert
                                // Clock ticks per second (typically 100 on Linux)
                                clockTicksPerSec := 100.0
                                hostCPUDelta := float64(hostCPUTime-prevStats.hostCPUTime) / clockTicksPerSec
                                hostCPUPercent = (hostCPUDelta / timeDelta) * 100

                                // Clamp to valid range [0, 100]
                                if hostCPUPercent &lt; 0 </span><span class="cov0" title="0">{
                                        hostCPUPercent = 0
                                }</span> else<span class="cov0" title="0"> if hostCPUPercent &gt; 100 </span><span class="cov0" title="0">{
                                        hostCPUPercent = 100
                                }</span>
                        }
                }
        }

        // Store current stats for next calculation
        <span class="cov0" title="0">c.previousStats[vmName] = &amp;cpuStats{
                guestCPUTime: guestCPUTime,
                hostCPUTime:  hostCPUTime,
                timestamp:    currentTime,
        }

        return guestCPUPercent, hostCPUPercent, nil</span>
}

// getGuestCPUTime returns cumulative guest CPU time in nanoseconds
func (c *VMCollector) getGuestCPUTime(vmName string) (uint64, error) <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput("virsh", "domstats", vmName, "--cpu-total")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Parse cpu.time from output
        // Format: "cpu.time=123456789"
        <span class="cov0" title="0">re := regexp.MustCompile(`cpu\.time=(\d+)`)
        matches := re.FindStringSubmatch(output)
        if len(matches) &lt; 2 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse cpu.time from domstats output")
        }</span>

        <span class="cov0" title="0">cpuTime, err := strconv.ParseUint(matches[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse cpu time value: %w", err)
        }</span>

        <span class="cov0" title="0">return cpuTime, nil</span>
}

// getHostCPUTime returns cumulative host CPU time in clock ticks for the QEMU process
func (c *VMCollector) getHostCPUTime(vmName string) (uint64, error) <span class="cov0" title="0">{
        // Get QEMU process PID
        pid, err := c.getQEMUProcessPID(vmName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Read /proc/[pid]/stat
        <span class="cov0" title="0">output, err := lib.ExecCommandOutput("cat", fmt.Sprintf("/proc/%d/stat", pid))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read /proc/%d/stat: %w", pid, err)
        }</span>

        // Parse /proc/[pid]/stat
        // Format: pid (comm) state ppid pgrp session tty_nr tpgid flags minflt cminflt majflt cmajflt utime stime ...
        // We need utime (field 14) + stime (field 15)
        <span class="cov0" title="0">fields := strings.Fields(output)
        if len(fields) &lt; 15 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("unexpected /proc/stat format")
        }</span>

        // utime is at index 13 (0-based), stime at index 14
        <span class="cov0" title="0">utime, err := strconv.ParseUint(fields[13], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse utime: %w", err)
        }</span>

        <span class="cov0" title="0">stime, err := strconv.ParseUint(fields[14], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse stime: %w", err)
        }</span>

        // Total CPU time = utime + stime
        <span class="cov0" title="0">return utime + stime, nil</span>
}

// getQEMUProcessPID returns the PID of the QEMU process for a VM
func (c *VMCollector) getQEMUProcessPID(vmName string) (int, error) <span class="cov0" title="0">{
        // Use pgrep to find QEMU process with VM name
        output, err := lib.ExecCommandOutput("pgrep", "-f", fmt.Sprintf("qemu.*guest=%s", vmName))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to find QEMU process for VM %s: %w", vmName, err)
        }</span>

        <span class="cov0" title="0">pidStr := strings.TrimSpace(output)
        if pidStr == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("no QEMU process found for VM %s", vmName)
        }</span>

        // If multiple PIDs, take the first one
        <span class="cov0" title="0">pidStr = strings.Split(pidStr, "\n")[0]

        pid, err := strconv.Atoi(pidStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse PID: %w", err)
        }</span>

        <span class="cov0" title="0">return pid, nil</span>
}

// getVMDiskIO returns disk read and write bytes
func (c *VMCollector) getVMDiskIO(vmName string) (uint64, uint64, error) <span class="cov0" title="0">{
        // Get list of disk devices
        output, err := lib.ExecCommandOutput("virsh", "domblklist", vmName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">var totalRead, totalWrite uint64
        lines := strings.Split(output, "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                fields := strings.Fields(line)
                if len(fields) &lt; 2 || fields[0] == "Target" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">device := fields[0]
                stats, err := lib.ExecCommandOutput("virsh", "domblkstat", vmName, device)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse read and write bytes
                // Format: "rd_bytes 123456"
                <span class="cov0" title="0">reRead := regexp.MustCompile(`rd_bytes\s+(\d+)`)
                if matches := reRead.FindStringSubmatch(stats); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if bytes, err := strconv.ParseUint(matches[1], 10, 64); err == nil </span><span class="cov0" title="0">{
                                totalRead += bytes
                        }</span>
                }

                <span class="cov0" title="0">reWrite := regexp.MustCompile(`wr_bytes\s+(\d+)`)
                if matches := reWrite.FindStringSubmatch(stats); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if bytes, err := strconv.ParseUint(matches[1], 10, 64); err == nil </span><span class="cov0" title="0">{
                                totalWrite += bytes
                        }</span>
                }
        }

        <span class="cov0" title="0">return totalRead, totalWrite, nil</span>
}

// getVMNetworkIO returns network RX and TX bytes
func (c *VMCollector) getVMNetworkIO(vmName string) (uint64, uint64, error) <span class="cov0" title="0">{
        // Get list of network interfaces
        output, err := lib.ExecCommandOutput("virsh", "domiflist", vmName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">var totalRX, totalTX uint64
        lines := strings.Split(output, "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                fields := strings.Fields(line)
                if len(fields) &lt; 1 || fields[0] == "Interface" || fields[0] == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">iface := fields[0]
                stats, err := lib.ExecCommandOutput("virsh", "domifstat", vmName, iface)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse RX and TX bytes
                // Format: "rx_bytes 123456"
                <span class="cov0" title="0">reRX := regexp.MustCompile(`rx_bytes\s+(\d+)`)
                if matches := reRX.FindStringSubmatch(stats); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if bytes, err := strconv.ParseUint(matches[1], 10, 64); err == nil </span><span class="cov0" title="0">{
                                totalRX += bytes
                        }</span>
                }

                <span class="cov0" title="0">reTX := regexp.MustCompile(`tx_bytes\s+(\d+)`)
                if matches := reTX.FindStringSubmatch(stats); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if bytes, err := strconv.ParseUint(matches[1], 10, 64); err == nil </span><span class="cov0" title="0">{
                                totalTX += bytes
                        }</span>
                }
        }

        <span class="cov0" title="0">return totalRX, totalTX, nil</span>
}

// formatMemoryDisplay formats memory usage as "used / allocated"
func (c *VMCollector) formatMemoryDisplay(used, allocated uint64) string <span class="cov8" title="1">{
        if allocated == 0 </span><span class="cov8" title="1">{
                return "0 / 0"
        }</span>

        <span class="cov8" title="1">usedGB := float64(used) / (1024 * 1024 * 1024)
        allocatedGB := float64(allocated) / (1024 * 1024 * 1024)

        return fmt.Sprintf("%.2f GB / %.2f GB", usedGB, allocatedGB)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package collectors

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// ZFSCollector collects ZFS pool, dataset, and ARC statistics
type ZFSCollector struct {
        ctx *domain.Context
}

// NewZFSCollector creates a new ZFS collector
func NewZFSCollector(ctx *domain.Context) *ZFSCollector <span class="cov8" title="1">{
        return &amp;ZFSCollector{ctx: ctx}
}</span>

// Start begins the ZFS collection loop
func (c *ZFSCollector) Start(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        logger.Info("ZFS collector started", "interval", interval)

        // Collect immediately on start
        c.collect()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("ZFS collector stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.collect()</span>
                }
        }
}

// collect gathers all ZFS data and publishes events
func (c *ZFSCollector) collect() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        logger.Error("ZFS collector panic recovered", "error", r)
                }</span>
        }()

        // Check if ZFS is available
        <span class="cov0" title="0">if !c.isZFSAvailable() </span><span class="cov0" title="0">{
                logger.Debug("ZFS not available, skipping collection")
                return
        }</span>

        // Collect pools
        <span class="cov0" title="0">pools, err := c.collectPools()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to collect ZFS pools", "error", err)
        }</span> else<span class="cov0" title="0"> if len(pools) &gt; 0 </span><span class="cov0" title="0">{
                c.ctx.Hub.Pub(pools, "zfs_pools_update")
                logger.Debug("Published ZFS pools update", "count", len(pools))
        }</span>

        // Collect datasets
        <span class="cov0" title="0">datasets, err := c.collectDatasets()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to collect ZFS datasets", "error", err)
        }</span> else<span class="cov0" title="0"> if len(datasets) &gt; 0 </span><span class="cov0" title="0">{
                c.ctx.Hub.Pub(datasets, "zfs_datasets_update")
                logger.Debug("Published ZFS datasets update", "count", len(datasets))
        }</span>

        // Collect snapshots
        <span class="cov0" title="0">snapshots, err := c.collectSnapshots()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to collect ZFS snapshots", "error", err)
        }</span> else<span class="cov0" title="0"> if len(snapshots) &gt; 0 </span><span class="cov0" title="0">{
                c.ctx.Hub.Pub(snapshots, "zfs_snapshots_update")
                logger.Debug("Published ZFS snapshots update", "count", len(snapshots))
        }</span>

        // Collect ARC stats
        <span class="cov0" title="0">arcStats, err := c.collectARCStats()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to collect ZFS ARC stats", "error", err)
        }</span> else<span class="cov0" title="0"> {
                c.ctx.Hub.Pub(arcStats, "zfs_arc_stats_update")
                logger.Debug("Published ZFS ARC stats update")
        }</span>
}

// isZFSAvailable checks if ZFS kernel module is loaded and binaries exist
func (c *ZFSCollector) isZFSAvailable() bool <span class="cov0" title="0">{
        // Check if zpool binary exists
        if _, err := os.Stat(constants.ZpoolBin); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Try to execute zpool list to verify ZFS is functional
        <span class="cov0" title="0">_, err := lib.ExecCommandOutput(constants.ZpoolBin, "list", "-H")
        return err == nil</span>
}

// collectPools collects information about all ZFS pools
func (c *ZFSCollector) collectPools() ([]dto.ZFSPool, error) <span class="cov0" title="0">{
        // Get list of pool names
        output, err := lib.ExecCommandOutput(constants.ZpoolBin, "list", "-H", "-o", "name")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list pools: %w", err)
        }</span>

        <span class="cov0" title="0">poolNames := strings.Split(strings.TrimSpace(output), "\n")
        if len(poolNames) == 0 || poolNames[0] == "" </span><span class="cov0" title="0">{
                return []dto.ZFSPool{}, nil
        }</span>

        <span class="cov0" title="0">pools := make([]dto.ZFSPool, 0, len(poolNames))
        for _, name := range poolNames </span><span class="cov0" title="0">{
                name = strings.TrimSpace(name)
                if name == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">pool, err := c.collectPoolDetails(name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warning("Failed to collect pool details", "pool", name, "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">pools = append(pools, pool)</span>
        }

        <span class="cov0" title="0">return pools, nil</span>
}

// collectPoolDetails collects detailed information about a specific pool
func (c *ZFSCollector) collectPoolDetails(name string) (dto.ZFSPool, error) <span class="cov0" title="0">{
        pool := dto.ZFSPool{
                Name:      name,
                Timestamp: time.Now(),
        }

        // Get basic pool info (parseable format)
        // Fields: name, size, allocated, free, fragmentation, capacity, dedupratio, health, altroot
        output, err := lib.ExecCommandOutput(constants.ZpoolBin, "list", "-Hp", "-o",
                "name,size,allocated,free,fragmentation,capacity,dedupratio,health,altroot", name)
        if err != nil </span><span class="cov0" title="0">{
                return pool, fmt.Errorf("failed to get pool info: %w", err)
        }</span>

        // Parse tab-separated values
        <span class="cov0" title="0">fields := strings.Split(strings.TrimSpace(output), "\t")
        if len(fields) &lt; 9 </span><span class="cov0" title="0">{
                return pool, fmt.Errorf("unexpected pool info format: got %d fields", len(fields))
        }</span>

        <span class="cov0" title="0">pool.SizeBytes, _ = strconv.ParseUint(fields[1], 10, 64)
        pool.AllocatedBytes, _ = strconv.ParseUint(fields[2], 10, 64)
        pool.FreeBytes, _ = strconv.ParseUint(fields[3], 10, 64)

        // Parse fragmentation and capacity (can be "-" if not available)
        if fields[4] != "-" </span><span class="cov0" title="0">{
                pool.FragmentationPct, _ = strconv.ParseFloat(fields[4], 64)
        }</span>
        <span class="cov0" title="0">if fields[5] != "-" </span><span class="cov0" title="0">{
                pool.CapacityPct, _ = strconv.ParseFloat(fields[5], 64)
        }</span>

        // Parse dedup ratio (format: "1.00x" or "1.00")
        <span class="cov0" title="0">dedupStr := strings.TrimSuffix(fields[6], "x")
        pool.DedupRatio, _ = strconv.ParseFloat(dedupStr, 64)

        pool.Health = fields[7]

        // Altroot (can be "-" if not set)
        if fields[8] != "-" </span><span class="cov0" title="0">{
                pool.Altroot = fields[8]
        }</span>

        // Get pool properties for additional details
        <span class="cov0" title="0">if err := c.enrichPoolProperties(&amp;pool); err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to enrich pool properties", "pool", name, "error", err)
        }</span>

        // Get pool status (vdevs, errors, scrub info)
        <span class="cov0" title="0">if err := c.parsePoolStatus(&amp;pool); err != nil </span><span class="cov0" title="0">{
                logger.Warning("Failed to parse pool status", "pool", name, "error", err)
        }</span>

        <span class="cov0" title="0">return pool, nil</span>
}

// enrichPoolProperties adds additional properties from 'zpool get all'
func (c *ZFSCollector) enrichPoolProperties(pool *dto.ZFSPool) error <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput(constants.ZpoolBin, "get", "-Hp", "-o", "property,value",
                "guid,readonly,autoexpand,autotrim", pool.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(strings.NewReader(output))
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fields := strings.Split(line, "\t")
                if len(fields) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">property := fields[0]
                value := fields[1]

                switch property </span>{
                case "guid":<span class="cov0" title="0">
                        pool.GUID = value</span>
                case "readonly":<span class="cov0" title="0">
                        pool.Readonly = value == "on"</span>
                case "autoexpand":<span class="cov0" title="0">
                        pool.Autoexpand = value == "on"</span>
                case "autotrim":<span class="cov0" title="0">
                        pool.Autotrim = value</span>
                }
        }

        <span class="cov0" title="0">return scanner.Err()</span>
}

// parsePoolStatus parses 'zpool status' output for vdevs, errors, and scrub info
func (c *ZFSCollector) parsePoolStatus(pool *dto.ZFSPool) error <span class="cov0" title="0">{
        output, err := lib.ExecCommandOutput(constants.ZpoolBin, "status", "-v", pool.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(strings.NewReader(output))
        inConfig := false
        var currentVdev *dto.ZFSVdev

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                trimmed := strings.TrimSpace(line)

                // Parse state
                if state, found := strings.CutPrefix(trimmed, "state:"); found </span><span class="cov0" title="0">{
                        pool.State = strings.TrimSpace(state)
                }</span>

                // Parse scan/scrub info
                <span class="cov0" title="0">if strings.HasPrefix(trimmed, "scan:") </span><span class="cov0" title="0">{
                        c.parseScanInfo(pool, trimmed)
                }</span>

                // Parse errors line
                <span class="cov0" title="0">if strings.HasPrefix(trimmed, "errors:") </span><span class="cov0" title="0">{
                        // Error summary is in the line, but individual errors are in vdev stats
                        continue</span>
                }

                // Parse config section (vdev tree)
                <span class="cov0" title="0">if strings.HasPrefix(trimmed, "config:") </span><span class="cov0" title="0">{
                        inConfig = true
                        continue</span>
                }

                <span class="cov0" title="0">if inConfig &amp;&amp; trimmed != "" &amp;&amp; !strings.HasPrefix(trimmed, "NAME") </span><span class="cov0" title="0">{
                        // Parse vdev line
                        vdev := c.parseVdevLine(line)
                        if vdev != nil </span><span class="cov0" title="0">{
                                // Determine if this is a top-level vdev or a device
                                indent := len(line) - len(strings.TrimLeft(line, "\t "))

                                if indent &lt;= 1 </span><span class="cov0" title="0">{
                                        // Top-level vdev (pool itself)
                                        pool.ReadErrors = vdev.ReadErrors
                                        pool.WriteErrors = vdev.WriteErrors
                                        pool.ChecksumErrors = vdev.ChecksumErrors
                                }</span> else<span class="cov0" title="0"> if indent &lt;= 3 </span><span class="cov0" title="0">{
                                        // Mid-level vdev (raidz, mirror, etc.)
                                        if currentVdev != nil </span><span class="cov0" title="0">{
                                                pool.VDEVs = append(pool.VDEVs, *currentVdev)
                                        }</span>
                                        <span class="cov0" title="0">currentVdev = vdev</span>
                                } else<span class="cov0" title="0"> {
                                        // Device within a vdev
                                        if currentVdev != nil </span><span class="cov0" title="0">{
                                                device := dto.ZFSDevice{
                                                        Name:           vdev.Name,
                                                        State:          vdev.State,
                                                        ReadErrors:     vdev.ReadErrors,
                                                        WriteErrors:    vdev.WriteErrors,
                                                        ChecksumErrors: vdev.ChecksumErrors,
                                                }
                                                currentVdev.Devices = append(currentVdev.Devices, device)
                                        }</span>
                                }
                        }
                }
        }

        // Add last vdev if exists
        <span class="cov0" title="0">if currentVdev != nil </span><span class="cov0" title="0">{
                pool.VDEVs = append(pool.VDEVs, *currentVdev)
        }</span>

        <span class="cov0" title="0">return scanner.Err()</span>
}

// parseScanInfo parses scrub/resilver information from status output
func (c *ZFSCollector) parseScanInfo(pool *dto.ZFSPool, line string) <span class="cov8" title="1">{
        // Example: "scan: scrub repaired 0B in 00:00:01 with 0 errors on Sun Nov 10 02:39:43 2025"
        // Example: "scan: scrub in progress since Sun Nov 10 02:39:43 2025"
        line = strings.TrimPrefix(line, "scan:")
        line = strings.TrimSpace(line)

        if strings.Contains(line, "in progress") </span><span class="cov8" title="1">{
                pool.ScanStatus = "in progress"
                pool.ScanState = "scanning"
        }</span> else<span class="cov8" title="1"> if strings.Contains(line, "scrub repaired") </span><span class="cov8" title="1">{
                pool.ScanStatus = "scrub completed"
                pool.ScanState = "finished"

                // Try to parse "with X errors"
                if strings.Contains(line, "with") &amp;&amp; strings.Contains(line, "errors") </span><span class="cov8" title="1">{
                        parts := strings.Split(line, "with")
                        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                errorPart := strings.TrimSpace(parts[1])
                                errorFields := strings.Fields(errorPart)
                                if len(errorFields) &gt; 0 </span><span class="cov8" title="1">{
                                        pool.ScanErrors, _ = strconv.Atoi(errorFields[0])
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> if strings.Contains(line, "resilver") </span><span class="cov8" title="1">{
                pool.ScanStatus = "resilver in progress"
                pool.ScanState = "scanning"
        }</span>
}

// parseVdevLine parses a single vdev line from zpool status output
// Format: "NAME        STATE     READ WRITE CKSUM"
// Example: "  sdg1      ONLINE       0     0     0"
func (c *ZFSCollector) parseVdevLine(line string) *dto.ZFSVdev <span class="cov8" title="1">{
        fields := strings.Fields(line)
        if len(fields) &lt; 5 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">vdev := &amp;dto.ZFSVdev{
                Name:  fields[0],
                State: fields[1],
        }

        // Determine vdev type based on name
        if strings.Contains(vdev.Name, "raidz1") </span><span class="cov8" title="1">{
                vdev.Type = "raidz1"
        }</span> else<span class="cov8" title="1"> if strings.Contains(vdev.Name, "raidz2") </span><span class="cov8" title="1">{
                vdev.Type = "raidz2"
        }</span> else<span class="cov8" title="1"> if strings.Contains(vdev.Name, "raidz3") </span><span class="cov8" title="1">{
                vdev.Type = "raidz3"
        }</span> else<span class="cov8" title="1"> if strings.Contains(vdev.Name, "mirror") </span><span class="cov8" title="1">{
                vdev.Type = "mirror"
        }</span> else<span class="cov8" title="1"> if strings.Contains(vdev.Name, "spare") </span><span class="cov8" title="1">{
                vdev.Type = "spare"
        }</span> else<span class="cov8" title="1"> if strings.Contains(vdev.Name, "cache") </span><span class="cov8" title="1">{
                vdev.Type = "cache"
        }</span> else<span class="cov8" title="1"> if strings.Contains(vdev.Name, "log") </span><span class="cov8" title="1">{
                vdev.Type = "log"
        }</span> else<span class="cov8" title="1"> {
                vdev.Type = "disk"
        }</span>

        <span class="cov8" title="1">vdev.ReadErrors, _ = strconv.ParseUint(fields[2], 10, 64)
        vdev.WriteErrors, _ = strconv.ParseUint(fields[3], 10, 64)
        vdev.ChecksumErrors, _ = strconv.ParseUint(fields[4], 10, 64)

        return vdev</span>
}

// collectDatasets collects information about all ZFS datasets
func (c *ZFSCollector) collectDatasets() ([]dto.ZFSDataset, error) <span class="cov0" title="0">{
        // Get all datasets across all pools
        // Fields: name, type, used, available, referenced, compressratio, mountpoint, quota, reservation, compression, readonly
        output, err := lib.ExecCommandOutput(constants.ZfsBin, "list", "-Hp", "-o",
                "name,type,used,available,referenced,compressratio,mountpoint,quota,reservation,compression,readonly")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list datasets: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(output), "\n")
        datasets := make([]dto.ZFSDataset, 0, len(lines))

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">dataset := c.parseDatasetLine(line)
                if dataset != nil </span><span class="cov0" title="0">{
                        datasets = append(datasets, *dataset)
                }</span>
        }

        <span class="cov0" title="0">return datasets, nil</span>
}

// parseDatasetLine parses a single dataset line from zfs list output
func (c *ZFSCollector) parseDatasetLine(line string) *dto.ZFSDataset <span class="cov0" title="0">{
        fields := strings.Split(line, "\t")
        if len(fields) &lt; 11 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">dataset := &amp;dto.ZFSDataset{
                Name:      fields[0],
                Type:      fields[1],
                Timestamp: time.Now(),
        }

        dataset.UsedBytes, _ = strconv.ParseUint(fields[2], 10, 64)
        dataset.AvailableBytes, _ = strconv.ParseUint(fields[3], 10, 64)
        dataset.ReferencedBytes, _ = strconv.ParseUint(fields[4], 10, 64)

        // Parse compression ratio (format: "1.00x" or "1.00")
        compressStr := strings.TrimSuffix(fields[5], "x")
        dataset.CompressRatio, _ = strconv.ParseFloat(compressStr, 64)

        if fields[6] != "-" </span><span class="cov0" title="0">{
                dataset.Mountpoint = fields[6]
        }</span>

        <span class="cov0" title="0">dataset.QuotaBytes, _ = strconv.ParseUint(fields[7], 10, 64)
        dataset.ReservationBytes, _ = strconv.ParseUint(fields[8], 10, 64)
        dataset.Compression = fields[9]
        dataset.Readonly = fields[10] == "on"

        return dataset</span>
}

// collectSnapshots collects information about all ZFS snapshots
func (c *ZFSCollector) collectSnapshots() ([]dto.ZFSSnapshot, error) <span class="cov0" title="0">{
        // Get all snapshots
        // Fields: name, used, referenced, creation
        output, err := lib.ExecCommandOutput(constants.ZfsBin, "list", "-t", "snapshot", "-Hp", "-o",
                "name,used,referenced,creation")
        if err != nil </span><span class="cov0" title="0">{
                // No snapshots is not an error
                if strings.Contains(err.Error(), "no datasets available") </span><span class="cov0" title="0">{
                        return []dto.ZFSSnapshot{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to list snapshots: %w", err)</span>
        }

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(output), "\n")
        snapshots := make([]dto.ZFSSnapshot, 0, len(lines))

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">snapshot := c.parseSnapshotLine(line)
                if snapshot != nil </span><span class="cov0" title="0">{
                        snapshots = append(snapshots, *snapshot)
                }</span>
        }

        <span class="cov0" title="0">return snapshots, nil</span>
}

// parseSnapshotLine parses a single snapshot line from zfs list output
func (c *ZFSCollector) parseSnapshotLine(line string) *dto.ZFSSnapshot <span class="cov0" title="0">{
        fields := strings.Split(line, "\t")
        if len(fields) &lt; 4 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Parse snapshot name (format: dataset@snapshot)
        <span class="cov0" title="0">parts := strings.Split(fields[0], "@")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">snapshot := &amp;dto.ZFSSnapshot{
                Name:      fields[0],
                Dataset:   parts[0],
                Timestamp: time.Now(),
        }

        snapshot.UsedBytes, _ = strconv.ParseUint(fields[1], 10, 64)
        snapshot.ReferencedBytes, _ = strconv.ParseUint(fields[2], 10, 64)

        // Parse creation time (Unix timestamp)
        creationUnix, _ := strconv.ParseInt(fields[3], 10, 64)
        snapshot.CreationTime = time.Unix(creationUnix, 0)

        return snapshot</span>
}

// collectARCStats collects ZFS ARC (Adaptive Replacement Cache) statistics
func (c *ZFSCollector) collectARCStats() (dto.ZFSARCStats, error) <span class="cov0" title="0">{
        stats := dto.ZFSARCStats{
                Timestamp: time.Now(),
        }

        // Check if ARC stats file exists
        if _, err := os.Stat(constants.ProcSPLARCStats); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("ARC stats file not found: %w", err)
        }</span>

        // Read ARC stats file
        <span class="cov0" title="0">file, err := os.Open(constants.ProcSPLARCStats)
        if err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("failed to open ARC stats file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Parse ARC stats (format: "name type data")
        scanner := bufio.NewScanner(file)
        arcData := make(map[string]uint64)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fields := strings.Fields(line)
                if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">name := fields[0]
                // type is fields[1], but we don't need it
                value, _ := strconv.ParseUint(fields[2], 10, 64)
                arcData[name] = value</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("error reading ARC stats: %w", err)
        }</span>

        // Extract relevant stats
        <span class="cov0" title="0">stats.SizeBytes = arcData["size"]
        stats.TargetSizeBytes = arcData["c"]
        stats.MinSizeBytes = arcData["c_min"]
        stats.MaxSizeBytes = arcData["c_max"]
        stats.Hits = arcData["hits"]
        stats.Misses = arcData["misses"]

        // Calculate hit ratio
        totalAccesses := stats.Hits + stats.Misses
        if totalAccesses &gt; 0 </span><span class="cov0" title="0">{
                stats.HitRatioPct = (float64(stats.Hits) / float64(totalAccesses)) * 100.0
        }</span>

        // MRU/MFU hit ratios (if available)
        <span class="cov0" title="0">mruHits := arcData["mru_hits"]
        mfuHits := arcData["mfu_hits"]
        if mruHits &gt; 0 || mfuHits &gt; 0 </span><span class="cov0" title="0">{
                mruTotal := mruHits + arcData["mru_ghost_hits"]
                mfuTotal := mfuHits + arcData["mfu_ghost_hits"]

                if mruTotal &gt; 0 </span><span class="cov0" title="0">{
                        stats.MRUHitRatioPct = (float64(mruHits) / float64(mruTotal)) * 100.0
                }</span>
                <span class="cov0" title="0">if mfuTotal &gt; 0 </span><span class="cov0" title="0">{
                        stats.MFUHitRatioPct = (float64(mfuHits) / float64(mfuTotal)) * 100.0
                }</span>
        }

        // L2ARC stats (if available)
        <span class="cov0" title="0">stats.L2SizeBytes = arcData["l2_size"]
        stats.L2Hits = arcData["l2_hits"]
        stats.L2Misses = arcData["l2_misses"]

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package controllers provides control operations for Unraid system resources.
package controllers

import (
        "fmt"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// ArrayController provides control operations for the Unraid array.
// It handles array start/stop, parity check operations, and array management commands.
type ArrayController struct {
        ctx *domain.Context
}

// NewArrayController creates a new array controller with the given context.
func NewArrayController(ctx *domain.Context) *ArrayController <span class="cov8" title="1">{
        return &amp;ArrayController{ctx: ctx}
}</span>

// StartArray starts the Unraid array
func (c *ArrayController) StartArray() error <span class="cov8" title="1">{
        logger.Info("Array: Starting array...")

        // Use mdcmd to start the array
        _, err := lib.ExecCommand("/usr/local/sbin/mdcmd", "start")
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Array: Failed to start array: %v", err)
                return fmt.Errorf("failed to start array: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Array: Array started successfully")
        return nil</span>
}

// StopArray stops the Unraid array
func (c *ArrayController) StopArray() error <span class="cov8" title="1">{
        logger.Info("Array: Stopping array...")

        // Use mdcmd to stop the array
        _, err := lib.ExecCommand("/usr/local/sbin/mdcmd", "stop")
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Array: Failed to stop array: %v", err)
                return fmt.Errorf("failed to stop array: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Array: Array stopped successfully")
        return nil</span>
}

// StartParityCheck starts a parity check
func (c *ArrayController) StartParityCheck(correcting bool) error <span class="cov8" title="1">{
        logger.Info("Array: Starting parity check (correcting: %v)...", correcting)

        var mode string
        if correcting </span><span class="cov8" title="1">{
                mode = "check CORRECT"
        }</span> else<span class="cov8" title="1"> {
                mode = "check NOCORRECT"
        }</span>

        // Use mdcmd to start parity check
        <span class="cov8" title="1">_, err := lib.ExecCommand("/usr/local/sbin/mdcmd", mode)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Array: Failed to start parity check: %v", err)
                return fmt.Errorf("failed to start parity check: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Array: Parity check started successfully")
        return nil</span>
}

// StopParityCheck stops a running parity check
func (c *ArrayController) StopParityCheck() error <span class="cov8" title="1">{
        logger.Info("Array: Stopping parity check...")

        // Use mdcmd to stop parity check
        _, err := lib.ExecCommand("/usr/local/sbin/mdcmd", "nocheck")
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Array: Failed to stop parity check: %v", err)
                return fmt.Errorf("failed to stop parity check: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Array: Parity check stopped successfully")
        return nil</span>
}

// PauseParityCheck pauses a running parity check
func (c *ArrayController) PauseParityCheck() error <span class="cov8" title="1">{
        logger.Info("Array: Pausing parity check...")

        // Use mdcmd to pause parity check
        _, err := lib.ExecCommand("/usr/local/sbin/mdcmd", "pause")
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Array: Failed to pause parity check: %v", err)
                return fmt.Errorf("failed to pause parity check: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Array: Parity check paused successfully")
        return nil</span>
}

// ResumeParityCheck resumes a paused parity check
func (c *ArrayController) ResumeParityCheck() error <span class="cov8" title="1">{
        logger.Info("Array: Resuming parity check...")

        // Use mdcmd to resume parity check
        _, err := lib.ExecCommand("/usr/local/sbin/mdcmd", "resume")
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Array: Failed to resume parity check: %v", err)
                return fmt.Errorf("failed to resume parity check: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Array: Parity check resumed successfully")
        return nil</span>
}

// SpinDownDisk spins down a specific disk
func (c *ArrayController) SpinDownDisk(diskName string) error <span class="cov8" title="1">{
        logger.Info("Array: Spinning down disk %s...", diskName)

        // Use mdcmd to spin down disk
        _, err := lib.ExecCommand("/usr/local/sbin/mdcmd", "spindown", diskName)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Array: Failed to spin down disk %s: %v", diskName, err)
                return fmt.Errorf("failed to spin down disk: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Array: Disk %s spun down successfully", diskName)
        return nil</span>
}

// SpinUpDisk spins up a specific disk
func (c *ArrayController) SpinUpDisk(diskName string) error <span class="cov8" title="1">{
        logger.Info("Array: Spinning up disk %s...", diskName)

        // Use mdcmd to spin up disk
        _, err := lib.ExecCommand("/usr/local/sbin/mdcmd", "spinup", diskName)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Array: Failed to spin up disk %s: %v", diskName, err)
                return fmt.Errorf("failed to spin up disk: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Array: Disk %s spun up successfully", diskName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package controllers

import (
        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// DockerController provides control operations for Docker containers.
// It handles container lifecycle operations including start, stop, restart, pause, and unpause.
type DockerController struct{}

// NewDockerController creates a new Docker controller.
func NewDockerController() *DockerController <span class="cov8" title="1">{
        return &amp;DockerController{}
}</span>

// Start starts a Docker container by ID or name.
func (dc *DockerController) Start(containerID string) error <span class="cov8" title="1">{
        logger.Info("Starting Docker container: %s", containerID)
        _, err := lib.ExecCommand(constants.DockerBin, "start", containerID)
        return err
}</span>

// Stop stops a Docker container by ID or name.
func (dc *DockerController) Stop(containerID string) error <span class="cov8" title="1">{
        logger.Info("Stopping Docker container: %s", containerID)
        _, err := lib.ExecCommand(constants.DockerBin, "stop", containerID)
        return err
}</span>

// Restart restarts a Docker container by ID or name.
func (dc *DockerController) Restart(containerID string) error <span class="cov8" title="1">{
        logger.Info("Restarting Docker container: %s", containerID)
        _, err := lib.ExecCommand(constants.DockerBin, "restart", containerID)
        return err
}</span>

// Pause pauses a running Docker container by ID or name.
func (dc *DockerController) Pause(containerID string) error <span class="cov8" title="1">{
        logger.Info("Pausing Docker container: %s", containerID)
        _, err := lib.ExecCommand(constants.DockerBin, "pause", containerID)
        return err
}</span>

// Unpause resumes a paused Docker container by ID or name.
func (dc *DockerController) Unpause(containerID string) error <span class="cov8" title="1">{
        logger.Info("Unpausing Docker container: %s", containerID)
        _, err := lib.ExecCommand(constants.DockerBin, "unpause", containerID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package controllers

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

const (
        notificationsDir        = "/usr/local/emhttp/state/notifications"
        notificationsArchiveDir = "/usr/local/emhttp/state/notifications/archive"
)

// CreateNotification creates a new notification file
func CreateNotification(title, subject, description, importance, link string) error <span class="cov8" title="1">{
        // Validate importance
        if importance != "alert" &amp;&amp; importance != "warning" &amp;&amp; importance != "info" </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid importance level: %s (must be alert, warning, or info)", importance)
        }</span>

        <span class="cov8" title="1">timestamp := time.Now()
        sanitizedTitle := sanitizeFilename(title)

        // Validate sanitized title to prevent path traversal
        if err := validateFilename(sanitizedTitle); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid title: %w", err)
        }</span>

        <span class="cov8" title="1">filename := fmt.Sprintf("%s-%s.notify",
                timestamp.Format("20060102-150405"),
                sanitizedTitle)

        path := filepath.Join(notificationsDir, filename)

        // Verify the final path is within the notifications directory
        cleanPath := filepath.Clean(path)
        if !strings.HasPrefix(cleanPath, notificationsDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid notification path: path escapes notifications directory")
        }</span>

        <span class="cov8" title="1">content := fmt.Sprintf(`event="%s"
subject="%s"
description="%s"
importance="%s"
timestamp="%s"
link="%s"`,
                title, subject, description, importance,
                timestamp.Format("2006-01-02 15:04:05"), link)

        // #nosec G306 - Notification files need to be readable by Unraid web UI (0644)
        if err := os.WriteFile(path, []byte(content), 0644); err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to create notification: %v", err)
                return fmt.Errorf("failed to create notification: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Created notification: %s", filename)
        return nil</span>
}

// ArchiveNotification moves a notification to the archive directory
func ArchiveNotification(id string) error <span class="cov8" title="1">{
        // Validate notification ID to prevent path traversal
        if err := validateNotificationID(id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">src := filepath.Join(notificationsDir, id)
        dst := filepath.Join(notificationsArchiveDir, id)

        // Check if source file exists
        if _, err := os.Stat(src); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("notification not found: %s", id)
        }</span>

        // Ensure archive directory exists
        // #nosec G301 - Unraid standard permissions (0755 for directories)
        <span class="cov0" title="0">if err := os.MkdirAll(notificationsArchiveDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create archive directory: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.Rename(src, dst); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to archive notification %s: %v", id, err)
                return fmt.Errorf("failed to archive notification: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Archived notification: %s", id)
        return nil</span>
}

// UnarchiveNotification moves a notification from archive back to active
func UnarchiveNotification(id string) error <span class="cov8" title="1">{
        // Validate notification ID to prevent path traversal
        if err := validateNotificationID(id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">src := filepath.Join(notificationsArchiveDir, id)
        dst := filepath.Join(notificationsDir, id)

        // Check if source file exists
        if _, err := os.Stat(src); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("archived notification not found: %s", id)
        }</span>

        <span class="cov0" title="0">if err := os.Rename(src, dst); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to unarchive notification %s: %v", id, err)
                return fmt.Errorf("failed to unarchive notification: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Unarchived notification: %s", id)
        return nil</span>
}

// DeleteNotification deletes a notification file
func DeleteNotification(id string, isArchived bool) error <span class="cov8" title="1">{
        // Validate notification ID to prevent path traversal
        if err := validateNotificationID(id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">dir := notificationsDir
        if isArchived </span><span class="cov0" title="0">{
                dir = notificationsArchiveDir
        }</span>
        <span class="cov0" title="0">path := filepath.Join(dir, id)

        // Check if file exists
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("notification not found: %s", id)
        }</span>

        <span class="cov0" title="0">if err := os.Remove(path); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete notification %s: %v", id, err)
                return fmt.Errorf("failed to delete notification: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Deleted notification: %s", id)
        return nil</span>
}

// ArchiveAllNotifications archives all unread notifications
func ArchiveAllNotifications() error <span class="cov8" title="1">{
        files, err := os.ReadDir(notificationsDir)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read notifications directory: %w", err)
        }</span>

        // Ensure archive directory exists
        // #nosec G301 - Unraid standard permissions (0755 for directories)
        <span class="cov0" title="0">if err := os.MkdirAll(notificationsArchiveDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create archive directory: %w", err)
        }</span>

        <span class="cov0" title="0">count := 0
        for _, file := range files </span><span class="cov0" title="0">{
                if !strings.HasSuffix(file.Name(), ".notify") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">src := filepath.Join(notificationsDir, file.Name())
                dst := filepath.Join(notificationsArchiveDir, file.Name())

                if err := os.Rename(src, dst); err != nil </span><span class="cov0" title="0">{
                        logger.Warning("Failed to archive %s: %v", file.Name(), err)
                        continue</span>
                }
                <span class="cov0" title="0">count++</span>
        }

        <span class="cov0" title="0">logger.Info("Archived %d notifications", count)
        return nil</span>
}

// sanitizeFilename removes invalid characters from filename
func sanitizeFilename(s string) string <span class="cov8" title="1">{
        // Replace spaces with underscores
        s = strings.ReplaceAll(s, " ", "_")
        // Remove any character that's not alphanumeric, underscore, or hyphen
        reg := regexp.MustCompile(`[^a-zA-Z0-9_-]`)
        s = reg.ReplaceAllString(s, "")
        // Limit length
        if len(s) &gt; 50 </span><span class="cov8" title="1">{
                s = s[:50]
        }</span>
        <span class="cov8" title="1">return s</span>
}

// validateFilename validates a filename to prevent path traversal attacks
// This is used after sanitizeFilename to ensure the sanitized result is safe
func validateFilename(filename string) error <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("filename cannot be empty")
        }</span>

        // Check for parent directory references
        <span class="cov8" title="1">if strings.Contains(filename, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("parent directory references not allowed")
        }</span>

        // Check for absolute paths
        <span class="cov8" title="1">if strings.HasPrefix(filename, "/") || strings.HasPrefix(filename, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("absolute paths not allowed")
        }</span>

        // Check for path separators
        <span class="cov8" title="1">if strings.Contains(filename, "/") || strings.Contains(filename, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("path separators not allowed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateNotificationID validates a notification ID to prevent path traversal attacks
// Notification IDs should be filenames only (no path separators or parent directory references)
func validateNotificationID(id string) error <span class="cov8" title="1">{
        if id == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("notification ID cannot be empty")
        }</span>

        // Check for parent directory references first (most specific attack)
        <span class="cov8" title="1">if strings.Contains(id, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid notification ID: parent directory references not allowed")
        }</span>

        // Check for absolute paths
        <span class="cov8" title="1">if strings.HasPrefix(id, "/") || strings.HasPrefix(id, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid notification ID: absolute paths not allowed")
        }</span>

        // Check for path separators (both Unix and Windows)
        <span class="cov8" title="1">if strings.Contains(id, "/") || strings.Contains(id, "\\") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid notification ID: path separators not allowed")
        }</span>

        // Validate file extension (must be .notify)
        <span class="cov8" title="1">if !strings.HasSuffix(id, ".notify") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid notification ID: must have .notify extension")
        }</span>

        // Additional security: ensure the resolved path stays within the notifications directory
        // This prevents symlink attacks and other edge cases
        <span class="cov8" title="1">cleanPath := filepath.Clean(filepath.Join(notificationsDir, id))
        if !strings.HasPrefix(cleanPath, notificationsDir) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid notification ID: path escapes notifications directory")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package controllers provides control operations for Unraid system resources.
package controllers

import (
        "fmt"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// SystemController provides control operations for the Unraid system.
// It handles system reboot and shutdown operations.
type SystemController struct {
        ctx *domain.Context
}

// NewSystemController creates a new system controller with the given context.
func NewSystemController(ctx *domain.Context) *SystemController <span class="cov8" title="1">{
        return &amp;SystemController{ctx: ctx}
}</span>

// Reboot initiates a system reboot.
// This will gracefully stop services and reboot the Unraid server.
func (c *SystemController) Reboot() error <span class="cov8" title="1">{
        logger.Info("System: Initiating reboot...")

        // Use the shutdown command with -r flag for reboot
        // The command runs in background so we can return a response before reboot occurs
        _, err := lib.ExecCommand("/sbin/shutdown", "-r", "now")
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("System: Failed to initiate reboot: %v", err)
                return fmt.Errorf("failed to initiate reboot: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("System: Reboot initiated successfully")
        return nil</span>
}

// Shutdown initiates a system shutdown.
// This will gracefully stop services and power off the Unraid server.
func (c *SystemController) Shutdown() error <span class="cov8" title="1">{
        logger.Info("System: Initiating shutdown...")

        // Use the shutdown command with -h flag for halt/poweroff
        // The command runs in background so we can return a response before shutdown occurs
        _, err := lib.ExecCommand("/sbin/shutdown", "-h", "now")
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("System: Failed to initiate shutdown: %v", err)
                return fmt.Errorf("failed to initiate shutdown: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("System: Shutdown initiated successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package controllers

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/dto"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

const (
        // UserScriptsBasePath is the base directory for user scripts
        UserScriptsBasePath = "/boot/config/plugins/user.scripts/scripts"
)

// ListUserScripts returns a list of all available user scripts
func ListUserScripts() ([]dto.UserScriptInfo, error) <span class="cov8" title="1">{
        scripts := []dto.UserScriptInfo{}

        // Check if user scripts directory exists
        if _, err := os.Stat(UserScriptsBasePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                logger.Warning("User scripts directory does not exist: %s", UserScriptsBasePath)
                return scripts, nil
        }</span>

        // Read all subdirectories in the user scripts directory
        <span class="cov0" title="0">entries, err := os.ReadDir(UserScriptsBasePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read user scripts directory: %w", err)
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                // Skip files and macOS metadata files
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">scriptName := entry.Name()
                scriptDir := filepath.Join(UserScriptsBasePath, scriptName)
                scriptPath := filepath.Join(scriptDir, "script")
                descriptionPath := filepath.Join(scriptDir, "description")

                // Check if script file exists
                scriptInfo, err := os.Stat(scriptPath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Script file not found for %s: %v", scriptName, err)
                        continue</span>
                }

                // Read description if it exists
                <span class="cov0" title="0">description := ""
                // #nosec G304 - descriptionPath is constructed from trusted userscripts directory
                if descData, err := os.ReadFile(descriptionPath); err == nil </span><span class="cov0" title="0">{
                        description = strings.TrimSpace(string(descData))
                }</span>

                // Check if script is executable (has read permission at minimum)
                <span class="cov0" title="0">executable := scriptInfo.Mode().Perm()&amp;0400 != 0

                scripts = append(scripts, dto.UserScriptInfo{
                        Name:         scriptName,
                        Description:  description,
                        Path:         scriptPath,
                        Executable:   executable,
                        LastModified: scriptInfo.ModTime(),
                })</span>
        }

        <span class="cov0" title="0">logger.Debug("Found %d user scripts", len(scripts))
        return scripts, nil</span>
}

// ExecuteUserScript executes a user script with the specified options
func ExecuteUserScript(scriptName string, background bool, wait bool) (*dto.UserScriptExecuteResponse, error) <span class="cov8" title="1">{
        // Validate script name to prevent path traversal
        if err := lib.ValidateUserScriptName(scriptName); err != nil </span><span class="cov8" title="1">{
                return &amp;dto.UserScriptExecuteResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Invalid script name: %v", err),
                }, err
        }</span>

        // Build script path
        <span class="cov8" title="1">scriptPath := filepath.Join(UserScriptsBasePath, scriptName, "script")

        // Verify script exists
        if _, err := os.Stat(scriptPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return &amp;dto.UserScriptExecuteResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Script not found: %s", scriptName),
                }, fmt.Errorf("script not found: %s", scriptName)
        }</span>

        // Execute script based on options
        <span class="cov0" title="0">if background &amp;&amp; !wait </span><span class="cov0" title="0">{
                // Background execution - don't wait for completion
                return executeScriptBackground(scriptPath, scriptName)
        }</span>
        <span class="cov0" title="0">if wait </span><span class="cov0" title="0">{
                // Wait for completion and return output
                return executeScriptWait(scriptPath, scriptName)
        }</span>
        // Default: background execution
        <span class="cov0" title="0">return executeScriptBackground(scriptPath, scriptName)</span>
}

// executeScriptBackground executes a script in the background
func executeScriptBackground(scriptPath string, scriptName string) (*dto.UserScriptExecuteResponse, error) <span class="cov0" title="0">{
        // Execute script in background using bash with nohup to detach
        // We use sh -c to run the command in background
        _, err := lib.ExecCommand("sh", "-c", fmt.Sprintf("nohup bash %s &gt; /dev/null 2&gt;&amp;1 &amp;", scriptPath))

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to execute user script %s in background: %v", scriptName, err)
                return &amp;dto.UserScriptExecuteResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to execute script: %v", err),
                }, err
        }</span>

        <span class="cov0" title="0">logger.Info("User script %s started in background", scriptName)
        return &amp;dto.UserScriptExecuteResponse{
                Success: true,
                Message: fmt.Sprintf("Script %s started in background", scriptName),
        }, nil</span>
}

// executeScriptWait executes a script and waits for completion
func executeScriptWait(scriptPath string, scriptName string) (*dto.UserScriptExecuteResponse, error) <span class="cov0" title="0">{
        // Execute script and wait for completion
        startTime := time.Now()
        lines, err := lib.ExecCommand("bash", scriptPath)
        duration := time.Since(startTime)

        // Join output lines
        output := strings.Join(lines, "\n")

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("User script %s failed after %v: %v", scriptName, duration, err)
                return &amp;dto.UserScriptExecuteResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Script execution failed: %v", err),
                        Output:  output,
                }, err
        }</span>

        <span class="cov0" title="0">logger.Info("User script %s completed successfully in %v", scriptName, duration)
        return &amp;dto.UserScriptExecuteResponse{
                Success: true,
                Message: fmt.Sprintf("Script %s completed successfully", scriptName),
                Output:  output,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package controllers

import (
        "github.com/ruaan-deysel/unraid-management-agent/daemon/constants"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/lib"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// VMController provides control operations for virtual machines managed by libvirt.
// It handles VM lifecycle operations including start, stop, restart, pause, resume, hibernate, and force stop.
type VMController struct{}

// NewVMController creates a new VM controller.
func NewVMController() *VMController <span class="cov8" title="1">{
        return &amp;VMController{}
}</span>

// Start starts a virtual machine by name.
func (vc *VMController) Start(vmName string) error <span class="cov8" title="1">{
        logger.Info("Starting VM: %s", vmName)
        _, err := lib.ExecCommand(constants.VirshBin, "start", vmName)
        return err
}</span>

// Stop gracefully shuts down a virtual machine by name.
func (vc *VMController) Stop(vmName string) error <span class="cov8" title="1">{
        logger.Info("Stopping VM: %s", vmName)
        _, err := lib.ExecCommand(constants.VirshBin, "shutdown", vmName)
        return err
}</span>

// Restart reboots a virtual machine by name.
func (vc *VMController) Restart(vmName string) error <span class="cov8" title="1">{
        logger.Info("Restarting VM: %s", vmName)
        _, err := lib.ExecCommand(constants.VirshBin, "reboot", vmName)
        return err
}</span>

// Pause suspends a running virtual machine by name.
func (vc *VMController) Pause(vmName string) error <span class="cov8" title="1">{
        logger.Info("Pausing VM: %s", vmName)
        _, err := lib.ExecCommand(constants.VirshBin, "suspend", vmName)
        return err
}</span>

// Resume resumes a paused virtual machine by name.
func (vc *VMController) Resume(vmName string) error <span class="cov8" title="1">{
        logger.Info("Resuming VM: %s", vmName)
        _, err := lib.ExecCommand(constants.VirshBin, "resume", vmName)
        return err
}</span>

// Hibernate saves the VM state to disk and stops it.
func (vc *VMController) Hibernate(vmName string) error <span class="cov8" title="1">{
        logger.Info("Hibernating VM: %s", vmName)
        _, err := lib.ExecCommand(constants.VirshBin, "managedsave", vmName)
        return err
}</span>

// ForceStop immediately terminates a virtual machine by name without graceful shutdown.
func (vc *VMController) ForceStop(vmName string) error <span class="cov8" title="1">{
        logger.Info("Force stopping VM: %s", vmName)
        _, err := lib.ExecCommand(constants.VirshBin, "destroy", vmName)
        return err
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package services provides the orchestration layer for managing collectors, API server, and application lifecycle.
package services

import (
        "context"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/services/api"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/services/collectors"
)

// Orchestrator coordinates the lifecycle of all collectors, API server, and handles graceful shutdown.
// It manages the initialization order, starts all components, and ensures proper cleanup on termination.
type Orchestrator struct {
        ctx *domain.Context
}

// CreateOrchestrator creates a new orchestrator with the given context.
func CreateOrchestrator(ctx *domain.Context) *Orchestrator <span class="cov0" title="0">{
        return &amp;Orchestrator{ctx: ctx}
}</span>

// Run starts all collectors and the API server, then waits for a termination signal.
// It ensures proper initialization order and handles graceful shutdown of all components.
func (o *Orchestrator) Run() error <span class="cov0" title="0">{
        logger.Info("Starting Unraid Management Agent v%s", o.ctx.Version)

        // Create cancellable context for all goroutines
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // WaitGroup to track all goroutines
        var wg sync.WaitGroup

        // Initialize API server FIRST so subscriptions are ready
        apiServer := api.NewServer(o.ctx)

        // Start API server subscriptions and WebSocket hub
        apiServer.StartSubscriptions()
        logger.Success("API server subscriptions ready")

        // Small delay to ensure subscriptions are fully set up
        time.Sleep(100 * time.Millisecond)

        // Initialize collectors (only if enabled - interval &gt; 0)
        // Interval of 0 means the collector is disabled
        enabledCount := 0
        disabledCollectors := []string{}

        // System collector
        if o.ctx.Intervals.System &gt; 0 </span><span class="cov0" title="0">{
                systemCollector := collectors.NewSystemCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        systemCollector.Start(ctx, time.Duration(o.ctx.Intervals.System)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "system")
        }</span>

        // Array collector
        <span class="cov0" title="0">if o.ctx.Intervals.Array &gt; 0 </span><span class="cov0" title="0">{
                arrayCollector := collectors.NewArrayCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        arrayCollector.Start(ctx, time.Duration(o.ctx.Intervals.Array)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "array")
        }</span>

        // Disk collector
        <span class="cov0" title="0">if o.ctx.Intervals.Disk &gt; 0 </span><span class="cov0" title="0">{
                diskCollector := collectors.NewDiskCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        diskCollector.Start(ctx, time.Duration(o.ctx.Intervals.Disk)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "disk")
        }</span>

        // Docker collector
        <span class="cov0" title="0">if o.ctx.Intervals.Docker &gt; 0 </span><span class="cov0" title="0">{
                dockerCollector := collectors.NewDockerCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        dockerCollector.Start(ctx, time.Duration(o.ctx.Intervals.Docker)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "docker")
        }</span>

        // VM collector
        <span class="cov0" title="0">if o.ctx.Intervals.VM &gt; 0 </span><span class="cov0" title="0">{
                vmCollector := collectors.NewVMCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        vmCollector.Start(ctx, time.Duration(o.ctx.Intervals.VM)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "vm")
        }</span>

        // UPS collector
        <span class="cov0" title="0">if o.ctx.Intervals.UPS &gt; 0 </span><span class="cov0" title="0">{
                upsCollector := collectors.NewUPSCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        upsCollector.Start(ctx, time.Duration(o.ctx.Intervals.UPS)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "ups")
        }</span>

        // NUT collector (separate from UPS - for NUT plugin users)
        <span class="cov0" title="0">if o.ctx.Intervals.NUT &gt; 0 </span><span class="cov0" title="0">{
                nutCollector := collectors.NewNUTCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        nutCollector.Start(ctx, time.Duration(o.ctx.Intervals.NUT)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "nut")
        }</span>

        // GPU collector
        <span class="cov0" title="0">if o.ctx.Intervals.GPU &gt; 0 </span><span class="cov0" title="0">{
                gpuCollector := collectors.NewGPUCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        gpuCollector.Start(ctx, time.Duration(o.ctx.Intervals.GPU)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "gpu")
        }</span>

        // Share collector
        <span class="cov0" title="0">if o.ctx.Intervals.Shares &gt; 0 </span><span class="cov0" title="0">{
                shareCollector := collectors.NewShareCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        shareCollector.Start(ctx, time.Duration(o.ctx.Intervals.Shares)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "shares")
        }</span>

        // Network collector
        <span class="cov0" title="0">if o.ctx.Intervals.Network &gt; 0 </span><span class="cov0" title="0">{
                networkCollector := collectors.NewNetworkCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        networkCollector.Start(ctx, time.Duration(o.ctx.Intervals.Network)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "network")
        }</span>

        // Hardware collector
        <span class="cov0" title="0">if o.ctx.Intervals.Hardware &gt; 0 </span><span class="cov0" title="0">{
                hardwareCollector := collectors.NewHardwareCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        hardwareCollector.Start(ctx, time.Duration(o.ctx.Intervals.Hardware)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "hardware")
        }</span>

        // Registration collector
        <span class="cov0" title="0">if o.ctx.Intervals.Registration &gt; 0 </span><span class="cov0" title="0">{
                registrationCollector := collectors.NewRegistrationCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        registrationCollector.Start(ctx, time.Duration(o.ctx.Intervals.Registration)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "registration")
        }</span>

        // Notification collector
        <span class="cov0" title="0">if o.ctx.Intervals.Notification &gt; 0 </span><span class="cov0" title="0">{
                notificationCollector := collectors.NewNotificationCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        notificationCollector.Start(ctx, time.Duration(o.ctx.Intervals.Notification)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "notification")
        }</span>

        // Unassigned collector
        <span class="cov0" title="0">if o.ctx.Intervals.Unassigned &gt; 0 </span><span class="cov0" title="0">{
                unassignedCollector := collectors.NewUnassignedCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        unassignedCollector.Start(ctx, time.Duration(o.ctx.Intervals.Unassigned)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "unassigned")
        }</span>

        // ZFS collector
        <span class="cov0" title="0">if o.ctx.Intervals.ZFS &gt; 0 </span><span class="cov0" title="0">{
                zfsCollector := collectors.NewZFSCollector(o.ctx)
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        zfsCollector.Start(ctx, time.Duration(o.ctx.Intervals.ZFS)*time.Second)
                }</span>()
                <span class="cov0" title="0">enabledCount++</span>
        } else<span class="cov0" title="0"> {
                disabledCollectors = append(disabledCollectors, "zfs")
        }</span>

        <span class="cov0" title="0">logger.Success("%d collectors started", enabledCount)
        if len(disabledCollectors) &gt; 0 </span><span class="cov0" title="0">{
                logger.Info("Disabled collectors: %v", disabledCollectors)
        }</span>

        // Start HTTP server
        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                if err := apiServer.StartHTTP(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("API server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">logger.Success("API server started on port %d", o.ctx.Port)

        // Wait for shutdown signal
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)
        sig := &lt;-sigChan

        logger.Warning("Received %s signal, shutting down...", sig)

        // Graceful shutdown
        // 1. Cancel context to stop all goroutines
        cancel()

        // 2. Stop API server (which also cancels its internal goroutines)
        apiServer.Stop()

        // 3. Wait for all goroutines to complete
        logger.Info("Waiting for all goroutines to complete...")
        wg.Wait()

        logger.Info("Shutdown complete")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package main is the entry point for the Unraid Management Agent.
// It provides a REST API and WebSocket interface for monitoring and controlling Unraid systems.
package main

import (
        "io"
        "log"
        "os"
        "path/filepath"
        "strings"

        "github.com/alecthomas/kong"
        "github.com/cskr/pubsub"
        "gopkg.in/natefinch/lumberjack.v2"

        "github.com/ruaan-deysel/unraid-management-agent/daemon/cmd"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/domain"
        "github.com/ruaan-deysel/unraid-management-agent/daemon/logger"
)

// Version is the application version, set at build time via ldflags.
var Version = "dev"

// validCollectorNames contains all valid collector names for validation
var validCollectorNames = map[string]bool{
        "system":       true,
        "array":        true,
        "disk":         true,
        "docker":       true,
        "vm":           true,
        "ups":          true,
        "nut":          true,
        "gpu":          true,
        "shares":       true,
        "network":      true,
        "hardware":     true,
        "zfs":          true,
        "notification": true,
        "registration": true,
        "unassigned":   true,
}

var cli struct {
        LogsDir  string `default:"/var/log" help:"directory to store logs"`
        Port     int    `default:"8043" help:"HTTP server port"`
        Debug    bool   `default:"false" help:"enable debug mode with stdout logging"`
        LogLevel string `default:"warning" help:"log level: debug, info, warning, error"`

        // Collector disable flag (alternative to setting interval=0)
        DisableCollectors string `default:"" env:"UNRAID_DISABLE_COLLECTORS" help:"comma-separated list of collectors to disable (e.g., gpu,ups,zfs)"`

        // Collection intervals (overridable via environment variables)
        // Use 0 to disable a collector completely
        // Maximum interval: 86400 seconds (24 hours)
        IntervalSystem       int `default:"15" env:"INTERVAL_SYSTEM" help:"system metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalArray        int `default:"60" env:"INTERVAL_ARRAY" help:"array metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalDisk         int `default:"300" env:"INTERVAL_DISK" help:"disk metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalDocker       int `default:"30" env:"INTERVAL_DOCKER" help:"docker metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalVM           int `default:"60" env:"INTERVAL_VM" help:"VM metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalUPS          int `default:"60" env:"INTERVAL_UPS" help:"UPS metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalNUT          int `default:"0" env:"INTERVAL_NUT" help:"NUT plugin metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalGPU          int `default:"60" env:"INTERVAL_GPU" help:"GPU metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalShares       int `default:"60" env:"INTERVAL_SHARES" help:"shares metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalNetwork      int `default:"60" env:"INTERVAL_NETWORK" help:"network metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalHardware     int `default:"600" env:"INTERVAL_HARDWARE" help:"hardware metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalZFS          int `default:"300" env:"INTERVAL_ZFS" help:"ZFS metrics interval (seconds, 0=disabled, max 86400)"`
        IntervalNotification int `default:"30" env:"INTERVAL_NOTIFICATION" help:"notification interval (seconds, 0=disabled, max 86400)"`
        IntervalRegistration int `default:"600" env:"INTERVAL_REGISTRATION" help:"registration interval (seconds, 0=disabled, max 86400)"`
        IntervalUnassigned   int `default:"60" env:"INTERVAL_UNASSIGNED" help:"unassigned devices interval (seconds, 0=disabled, max 86400)"`

        Boot cmd.Boot `cmd:"" default:"1" help:"start the management agent"`
}

func main() <span class="cov0" title="0">{
        ctx := kong.Parse(&amp;cli)

        // Set log level based on CLI flag
        switch strings.ToLower(cli.LogLevel) </span>{
        case "debug":<span class="cov0" title="0">
                logger.SetLevel(logger.LevelDebug)</span>
        case "info":<span class="cov0" title="0">
                logger.SetLevel(logger.LevelInfo)</span>
        case "warning", "warn":<span class="cov0" title="0">
                logger.SetLevel(logger.LevelWarning)</span>
        case "error":<span class="cov0" title="0">
                logger.SetLevel(logger.LevelError)</span>
        default:<span class="cov0" title="0">
                logger.SetLevel(logger.LevelWarning)</span>
        }

        // Set up logging
        <span class="cov0" title="0">if cli.Debug </span><span class="cov0" title="0">{
                // Debug mode: direct stdout/stderr with no buffering
                log.SetOutput(os.Stdout)
                log.SetFlags(log.LstdFlags | log.Lshortfile)
                logger.SetLevel(logger.LevelDebug)
                log.Println("Debug mode enabled - logging to stdout")
        }</span> else<span class="cov0" title="0"> {
                // Production mode: log rotation with 5MB max size, NO backups
                fileLogger := &amp;lumberjack.Logger{
                        Filename:   filepath.Join(cli.LogsDir, "unraid-management-agent.log"),
                        MaxSize:    5,     // 5 MB max file size
                        MaxBackups: 0,     // No backup files - only keep current log
                        MaxAge:     0,     // No age-based retention
                        Compress:   false, // No compression
                }
                // Write to both file and stdout
                multiWriter := io.MultiWriter(fileLogger, os.Stdout)
                log.SetOutput(multiWriter)
        }</span>

        <span class="cov0" title="0">log.Printf("Starting Unraid Management Agent v%s (log level: %s)", Version, cli.LogLevel)

        // Parse disabled collectors from CLI/env and create a map
        disabledCollectors := make(map[string]bool)
        if cli.DisableCollectors != "" </span><span class="cov0" title="0">{
                for _, name := range strings.Split(cli.DisableCollectors, ",") </span><span class="cov0" title="0">{
                        name = strings.TrimSpace(strings.ToLower(name))
                        if name == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if name == "system" </span><span class="cov0" title="0">{
                                log.Printf("WARNING: Cannot disable system collector (always required), ignoring")
                                continue</span>
                        }
                        <span class="cov0" title="0">if !validCollectorNames[name] </span><span class="cov0" title="0">{
                                log.Printf("WARNING: Unknown collector name '%s' in disable list, ignoring", name)
                                continue</span>
                        }
                        <span class="cov0" title="0">disabledCollectors[name] = true
                        log.Printf("Collector '%s' disabled via UNRAID_DISABLE_COLLECTORS", name)</span>
                }
        }

        // Helper function to get interval (returns 0 if collector is disabled)
        <span class="cov0" title="0">getInterval := func(name string, cliInterval int) int </span><span class="cov0" title="0">{
                if disabledCollectors[name] </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">return cliInterval</span>
        }

        // Create application context with intervals from CLI/env
        <span class="cov0" title="0">appCtx := &amp;domain.Context{
                Config: domain.Config{
                        Version: Version,
                        Port:    cli.Port,
                },
                Hub: pubsub.New(1024), // Buffer size for event bus
                Intervals: domain.Intervals{
                        System:       getInterval("system", cli.IntervalSystem),
                        Array:        getInterval("array", cli.IntervalArray),
                        Disk:         getInterval("disk", cli.IntervalDisk),
                        Docker:       getInterval("docker", cli.IntervalDocker),
                        VM:           getInterval("vm", cli.IntervalVM),
                        UPS:          getInterval("ups", cli.IntervalUPS),
                        NUT:          getInterval("nut", cli.IntervalNUT),
                        GPU:          getInterval("gpu", cli.IntervalGPU),
                        Shares:       getInterval("shares", cli.IntervalShares),
                        Network:      getInterval("network", cli.IntervalNetwork),
                        Hardware:     getInterval("hardware", cli.IntervalHardware),
                        ZFS:          getInterval("zfs", cli.IntervalZFS),
                        Notification: getInterval("notification", cli.IntervalNotification),
                        Registration: getInterval("registration", cli.IntervalRegistration),
                        Unassigned:   getInterval("unassigned", cli.IntervalUnassigned),
                },
        }

        // Run the boot command
        err := ctx.Run(appCtx)
        ctx.FatalIfErrorf(err)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
